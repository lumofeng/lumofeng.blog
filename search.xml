<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JDBC 连接数据库的步骤</title>
    <url>/2022/12/03/JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h1 id="JDBC连接数据库的步骤"><a href="#JDBC连接数据库的步骤" class="headerlink" title="JDBC连接数据库的步骤"></a>JDBC连接数据库的步骤</h1><ol>
<li>注册驱动</li>
<li>获取连接对象</li>
<li>创建SQL语句</li>
<li>创建执行SQL语句的Statement对象</li>
<li>执行SQL语句</li>
<li>释放资源</li>
</ol>
<p>增删改操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//获取连接对象</span></span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&amp;useSSL=false&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//创建SQL语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into user values (null, &#x27;行小观&#x27;, &#x27;1234&#x27;)&quot;</span>;</span><br><span class="line">        <span class="comment">//创建Statement对象</span></span><br><span class="line">        stmt = conn.createStatement();</span><br><span class="line">        <span class="comment">//执行SQL语句</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;<span class="comment">//避免空指针异常</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();<span class="comment">//释放资源</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查询操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//获取连接对象</span></span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&amp;useSSL=false&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//创建SQL语句</span></span><br><span class="line">  		<span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;行小观&quot;</span>;</span><br><span class="line">         <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">         <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; and password = &#x27;&quot;</span> + password + <span class="string">&quot;&#x27;&quot;</span>;<span class="comment">//拼接字符串</span></span><br><span class="line">        <span class="comment">//创建Statement对象</span></span><br><span class="line">        stmt = conn.createStatement();</span><br><span class="line">        <span class="comment">//执行SQL语句</span></span><br><span class="line">        rs = stmt.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="type">float</span> <span class="variable">money</span> <span class="operator">=</span> rs.getFloat(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">            System.out.println(id + <span class="string">&quot;--&quot;</span> + name + <span class="string">&quot;--&quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;<span class="comment">//避免空指针异常</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();<span class="comment">//释放资源</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类的解释"><a href="#类的解释" class="headerlink" title="类的解释"></a>类的解释</h1><h2 id="1-DriverManager"><a href="#1-DriverManager" class="headerlink" title="1. DriverManager"></a>1. DriverManager</h2><p><strong>(1) 通过DriverManager注册驱动</strong></p>
<p><code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;)</code>将Driver类加载进内存。</p>
<p>我们翻看Driver类的源码发现静态代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        DriverManager.registerDriver(new Driver());</span><br><span class="line">    &#125; catch (SQLException var1) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>该静态代码块随着类被加载而执行，一旦执行，便通过<code>DriverManager.registerDriver(new Driver())</code>注册驱动。</p>
<p><strong>(2) 通过DriverManager获取Connection对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DriverManager.getConnection(url, username, password)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们只需提供三个参数：数据库的url，用户名，密码。</p>
<p>注意：url中需要加时区。</p>
<h2 id="2-Connection"><a href="#2-Connection" class="headerlink" title="2. Connection"></a>2. Connection</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conn.createStatement()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>通过Connection对象创建Statement对象</p>
<h2 id="3-Statement"><a href="#3-Statement" class="headerlink" title="3. Statement"></a>3. Statement</h2><p>该对象能够执行静态SQL语句并返回执行结果。</p>
<h2 id="4-ResultSet"><a href="#4-ResultSet" class="headerlink" title="4. ResultSet"></a>4. ResultSet</h2><p>表示数据库结果集的数据表，通常由执行查询数据库的语句生成。</p>
<p>可以使用<code>next()</code>方法遍历结果集</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>EasyExcel 的使用</title>
    <url>/2022/11/30/EasyExcel%E8%AF%BB%E5%8F%96%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="EasyExcel"><a href="#EasyExcel" class="headerlink" title="EasyExcel"></a>EasyExcel</h1><p>官方文档： <a href="https://easyexcel.opensource.alibaba.com/docs/current/">https://easyexcel.opensource.alibaba.com/docs/current/</a> </p>
<p>两种读对象的方式：</p>
<ol>
<li>确定表头：建立对象，和表头形成映射关系</li>
<li>不确定表头：每一行数据映射为 Map&lt;String, Object&gt;</li>
</ol>
<p>两种读取模式：</p>
<ol>
<li>监听器：先创建监听器、在读取文件时绑定监听器。单独抽离处理逻辑，代码清晰易于维护；一条一条处理，适用于数据量大的场景。</li>
<li>同步读：无需创建监听器，一次性获取完整数据。方便简单，但是数据量大时会有等待时常，也可能内存溢出。</li>
</ol>
<p>添加EasyExcel步骤：</p>
<h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.alibaba/easyexcel --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-定义读的对象"><a href="#2-定义读的对象" class="headerlink" title="2.定义读的对象"></a>2.定义读的对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XingQiuTableUserInfo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;成员编号&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String planetCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户昵称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;成员昵称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同步读取数据的方式"><a href="#同步读取数据的方式" class="headerlink" title="同步读取数据的方式"></a>同步读取数据的方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步读取数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">synchronousRead</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;E:\\yupi\\星球项目\\yupao-	 backend\\src\\main\\resources\\testExcle.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 需要指定读用哪个class去读，然后读取第一个sheet 同步读取会自动finish</span></span><br><span class="line">    List&lt;XingQiuTableUserInfo&gt; totalDataList =</span><br><span class="line">         					    EasyExcel.read(fileName).head(XingQiuTableUserInfo.class).sheet().doReadSync();</span><br><span class="line">    <span class="keyword">for</span> (XingQiuTableUserInfo xingQiuTableUserInfo : totalDataList) &#123;</span><br><span class="line">        System.out.println(xingQiuTableUserInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（1）定义一个主类启动即可"><a href="#（1）定义一个主类启动即可" class="headerlink" title="（1）定义一个主类启动即可"></a>（1）定义一个主类启动即可</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    synchronousRead(fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="采用监听器的方式读取数据"><a href="#采用监听器的方式读取数据" class="headerlink" title="采用监听器的方式读取数据"></a>采用监听器的方式读取数据</h2><h3 id="（1）定义一个监听器-tableListener-类"><a href="#（1）定义一个监听器-tableListener-类" class="headerlink" title="（1）定义一个监听器 tableListener 类"></a>（1）定义一个监听器 tableListener 类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有个很重要的点 XingQiuTableUserInfoListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TableListener</span> <span class="keyword">implements</span> <span class="title class_">ReadListener</span>&lt;XingQiuTableUserInfo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个每一条数据解析都会来调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data    one row value. Is is same as &#123;<span class="doctag">@link</span> AnalysisContext#readRowHolder()&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(XingQiuTableUserInfo data, AnalysisContext context)</span> &#123;</span><br><span class="line">        System.out.println(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有数据解析完成了 都会来调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里也要保存数据，确保最后遗留的数据也存储到数据库</span></span><br><span class="line">        System.out.println(<span class="string">&quot;已解析完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-封装为方法-readByListener"><a href="#2-封装为方法-readByListener" class="headerlink" title="(2)封装为方法 readByListener"></a>(2)封装为方法 readByListener</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听器读取数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readByListener</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;E:\\yupi\\星球项目\\yupao-backend\\src\\main\\resources\\testExcle.xlsx&quot;</span>;</span><br><span class="line">    EasyExcel.read(fileName, XingQiuTableUserInfo.class, <span class="keyword">new</span> <span class="title class_">TableListener</span>()).sheet().doRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-定义一个主类启动即可"><a href="#3-定义一个主类启动即可" class="headerlink" title="(3)定义一个主类启动即可"></a>(3)定义一个主类启动即可</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    readByListener(fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开源组件</category>
      </categories>
      <tags>
        <tag>EasyExcel</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL 语句</title>
    <url>/2022/12/03/MyBatis%20%E4%B8%AD%EF%BC%8CSQL%20%E8%AF%AD%E5%8F%A5%20#%20%E5%92%8C%20$%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="MyBatis-中，SQL-语句-和-的区别"><a href="#MyBatis-中，SQL-语句-和-的区别" class="headerlink" title="MyBatis 中，SQL 语句 # 和 $ 的区别"></a>MyBatis 中，SQL 语句 # 和 $ 的区别</h1><p>动态 SQL 是 mybatis 的强大特性之一，也是它优于其他 ORM 框架的一个重要原因。mybatis 在对 sql 语句进行预编译之前，会对 sql 进行动态解析，解析为一个 BoundSql 对象，也是在此处对动态 SQL 进行处理的。</p>
<p>在动态 SQL 解析阶段，#{} 会有两种不同的表现：</p>
<ol>
<li><p>都可以获取对象中的属性值，[name] 和 #[name] 相同</p>
</li>
<li><p>#会把传入的参数使用引号包起来参数值 ? : ‘name’</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user <span class="type">WHERE</span> <span class="variable">name</span> <span class="operator">=</span> ? <span class="type">AND</span> <span class="variable">password</span> <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>


</li>
<li><p>优点是 # 可以防止 SQL 注入。解析时，先把 # 的地方变成占位符 ? ,再设置参数值。<br>SQL 语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user <span class="type">WHERE</span> <span class="variable">name</span> <span class="operator">=</span> #&#123;name&#125; <span class="type">AND</span> <span class="variable">password</span>  <span class="operator">=</span> #&#123;password&#125;</span><br></pre></td></tr></table></figure>

<p>#{} 在动态解析时，会解析成一个参数标记符。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user <span class="type">WHERE</span> <span class="variable">name</span> <span class="operator">=</span> ?  <span class="type">AND</span> <span class="variable">password</span>  <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>

<p>在使用 $  的时候，SQL语句如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from user <span class="type">where</span> <span class="variable">name</span> <span class="operator">=</span> $&#123;name&#125;; </span><br></pre></td></tr></table></figure>

<p>${}在动态解析的时候，会将我们传入的参数当做 String 字符串填充到我们的语句中，就会变成下面的语句</p>
<p><strong>select * from user where name &#x3D; “xxx”;</strong><br>预编译之前的 SQL 语句已经不包含变量了，完全已经是常量数据了。相当于我们没有变量的普通 sql 了。 $ 会导致 sql 注入,但可以拼接 sql 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user <span class="type">WHERE</span> <span class="variable">name</span> <span class="operator">=</span> $[name] <span class="type">AND</span> <span class="variable">password</span>  <span class="operator">=</span> $[password]	</span><br></pre></td></tr></table></figure>

<p>假如 name &#x3D; OR 1 &#x3D; 1 OR; 最终上面的sql会变成——&gt;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user <span class="type">WHERE</span> <span class="variable">name</span> <span class="operator">=</span> OR <span class="number">1</span> = <span class="number">1</span> OR  <span class="type">AND</span> <span class="variable">password</span>  <span class="operator">=</span> 	</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>总结：</strong>一般使用 # 获取数据即可，在分组和排列操作值使用</p>
<p>如果需要连接一个参数值使用，<strong>拼接一段 SQL 使用，使用 $</strong> ,但是该方式无法防止 SQL 注入。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>SQL 注入</title>
    <url>/2022/12/03/SQL%20%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h1><p>静态 SQL 语句是使用字符串拼接起来的。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;行小观&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; and password = &#x27;&quot;</span> + password + <span class="string">&quot;&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>我们将变量代入后的效果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from user <span class="type">where</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&#x27;行小观&#x27;</span> <span class="type">and</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&#x27;1234&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样执行是没问题的。</p>
<p>但是现在情况变了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;行小观&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>我们将变量代入后的效果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from user <span class="type">where</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&#x27;行小观&#x27;</span> <span class="type">and</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> or <span class="string">&#x27;1&#x27;</span> = <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>因为<code>or &#39;1&#39;=&#39;1&#39;</code>的原因，导致 SQL 语句的 where 子句为 true，等价于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from user</span><br></pre></td></tr></table></figure>

<p>所以会将整张表给查询出来。</p>
<p>以上便是SQL注入。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Git 上传项目</title>
    <url>/2022/12/04/%E4%BD%BF%E7%94%A8%20Git%20%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="上传项目到GitHub"><a href="#上传项目到GitHub" class="headerlink" title="上传项目到GitHub"></a>上传项目到GitHub</h1><ol>
<li>全局绑定账户</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 绑定用户</span><br><span class="line">git config --global user.name <span class="string">&quot; &quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>2.进到本地项目目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git coommit - m &quot;第一次上传&quot;</span><br></pre></td></tr></table></figure>

<p>已将本地仓库建立好</p>
<p>3.关联 GitHub 仓库 (示例宠物医院管理系统仓库地址)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 关联 GitHub 仓库地址</span><br><span class="line">git remote add origin git@github.com:xxxx.git</span><br><span class="line"># 上传本地代码 使用 origin 来指定上传的分支</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>



<p>git remote add origin <a href="mailto:&#103;&#105;&#x74;&#64;&#103;&#105;&#x74;&#104;&#117;&#x62;&#46;&#x63;&#x6f;&#x6d;">&#103;&#105;&#x74;&#64;&#103;&#105;&#x74;&#104;&#117;&#x62;&#46;&#x63;&#x6f;&#x6d;</a>:lubenchu&#x2F;PetHospitalManagementSystem.git 报错解决</p>
<p>查看当前关联的仓库：git remote -v </p>
<p>解除当前关联仓库：git remote rm origin </p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>使用PreparedStatement防止SQL注入</title>
    <url>/2022/12/03/%E4%BD%BF%E7%94%A8PreparedStatement%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="使用PreparedStatement防止SQL注入"><a href="#使用PreparedStatement防止SQL注入" class="headerlink" title="使用PreparedStatement防止SQL注入"></a>使用PreparedStatement防止SQL注入</h1><p>使用Statement对象执行静态SQL语句，如果执行了特殊构造的语句，会导致SQL注入，出现安全漏洞。</p>
<p>使用PreparedStatement对象能够防止 SQL 注入。</p>
<p>PreparedStatement对象是<strong>预编译的SQL语句</strong>的对象，继承自Statement。</p>
<p>什么是预编译的SQL语句？</p>
<p>静态SQL语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; and password = &#x27; &quot;</span> + password + <span class="string">&quot;&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>改为预编译的SQL语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ? and password = ? &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>编写SQL语句时，不使用字符串进行拼接，而是使用问号？占位符代替变量。</p>
<p>使用JDBC的步骤有所变化：</p>
<ol>
<li>注册驱动</li>
<li>获取连接对象</li>
<li>创建SQL语句</li>
<li><strong>创建执行SQL语句的PreparedStatement对象</strong></li>
<li><strong>给 ? 赋值</strong></li>
<li>执行SQL语句</li>
<li>释放资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//获取连接对象</span></span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&amp;useSSL=false&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//创建SQL语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;行小观&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ? and password = ?&quot;</span>;</span><br><span class="line">        <span class="comment">//创建PreparedStatement对象</span></span><br><span class="line">        pstmt = conn.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//给?赋值</span></span><br><span class="line">        pstmt.setString(<span class="number">1</span>, username);</span><br><span class="line">        pstmt.setString(<span class="number">2</span>, password);</span><br><span class="line">        <span class="comment">//执行SQL语句</span></span><br><span class="line">        rs = pstmt.executeQuery();</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">unm</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            System.out.println(id + <span class="string">&quot;--&quot;</span>+ unm + <span class="string">&quot;--&quot;</span> + pwd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pstmt != <span class="literal">null</span>) &#123;<span class="comment">//避免空指针异常</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pstmt.close();<span class="comment">//释放资源</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL mysql 面试题</title>
    <url>/2022/12/03/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="mysql-面试题"><a href="#mysql-面试题" class="headerlink" title="mysql 面试题"></a>mysql 面试题</h1><h2 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a>数据库基础知识</h2><h3 id="为什么要使用数据库"><a href="#为什么要使用数据库" class="headerlink" title="为什么要使用数据库"></a>为什么要使用数据库</h3><ul>
<li><strong>数据保存在内存</strong><ul>
<li>优点： 存取速度快</li>
<li>缺点： 数据不能永久保存</li>
</ul>
</li>
<li><strong>数据保存在文件</strong><ul>
<li>优点： 数据永久保存</li>
<li>缺点：1、速度比内存操作慢，频繁的IO操作。2、查询数据不方便</li>
</ul>
</li>
<li><strong>数据保存在数据库</strong><ul>
<li>数据永久保存</li>
<li>使用SQL语句，查询方便效率高。</li>
<li>管理数据方便</li>
</ul>
</li>
</ul>
<h3 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h3><ul>
<li>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用：用于存取数据、查询、更新和管理关系数据库系统。</span><br></pre></td></tr></table></figure>

<h3 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL?"></a>什么是MySQL?</h3><ul>
<li>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</li>
</ul>
<h3 id="MySql-Oracle，Sql-Service的区别"><a href="#MySql-Oracle，Sql-Service的区别" class="headerlink" title="MySql, Oracle，Sql Service的区别"></a>MySql, Oracle，Sql Service的区别</h3><ol>
<li>Sql Service只能在Windows上使用，而MySql和Oracle可以在其他系统上使用，	而且可以支持数据库不同系统之间的移植</li>
<li>MySql开源免费的，Sql Service和Oracle要钱。</li>
<li>我从小到大排序哈，MySql很小，Sql Service居中，Oracle最大</li>
<li>Oracle支持大并发量，大访问量，Sql Service还行，而MySql的话压力没这么大，因此现在的MySql的话最好是要使用集群或者缓存来搭配使用</li>
<li>Oracle支持多用户不同权限来进行操作，而MySql只要有登录权限就可操作全部数据库</li>
<li>安装所用的空间差别也是很大的，Mysql安装完后才几百M而Oracle有几G左右，且使用的时候Oracle占用特别大的内存空间和其他机器性能。</li>
<li>做分页的话，MySql使用Limit，Sql Service使用top，Oracle使用row</li>
<li>Oracle没有自动增长类型，Mysql和Sql Service一般使用自动增长类型</li>
</ol>
<h3 id="数据库三大范式是什么"><a href="#数据库三大范式是什么" class="headerlink" title="数据库三大范式是什么"></a>数据库三大范式是什么</h3><ul>
<li>第一范式：每个列都不可以再拆分。</li>
<li>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</li>
<li>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</span><br></pre></td></tr></table></figure>

<h3 id="mysql有关权限的表都有哪几个"><a href="#mysql有关权限的表都有哪几个" class="headerlink" title="mysql有关权限的表都有哪几个"></a>mysql有关权限的表都有哪几个</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql\_install\_db脚本初始化。这些权限表分别user，db，table\_priv，columns\_priv和host。下面分别介绍一下这些表的结构和内容：</span><br></pre></td></tr></table></figure>

<ul>
<li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li>
<li>db权限表：记录各个帐号在各个数据库上的操作权限。</li>
<li>table_priv权限表：记录数据表级的操作权限。</li>
<li>columns_priv权限表：记录数据列级的操作权限。</li>
<li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li>
</ul>
<h3 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有三种格式，statement，row和mixed。</span><br></pre></td></tr></table></figure>

<ul>
<li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>
<li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li>
<li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</span><br></pre></td></tr></table></figure>

<h3 id="数据库经常使用的函数"><a href="#数据库经常使用的函数" class="headerlink" title="数据库经常使用的函数"></a>数据库经常使用的函数</h3><ul>
<li>count(*&#x2F;column)：返回行数</li>
<li>sum(column)： 返回指定列中唯一值的和</li>
<li>max(column)：返回指定列或表达式中的数值最大值</li>
<li>min(column)：返回指定列或表达式中的数值最小值</li>
<li>avg(column)：返回指定列或表达式中的数值平均值</li>
<li>date（Expression）: 返回指定表达式代表的日期值</li>
</ul>
<p>……</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="mysql有哪些数据类型"><a href="#mysql有哪些数据类型" class="headerlink" title="mysql有哪些数据类型"></a>mysql有哪些数据类型</h3><blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>类型名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>整数类型</td>
<td>tinyInt</td>
<td>很小的整数(8位二进制)</td>
</tr>
<tr>
<td>整数类型</td>
<td>smallint</td>
<td>小的整数(16位二进制)</td>
</tr>
<tr>
<td>整数类型</td>
<td>mediumint</td>
<td>中等大小的整数(24位二进制)</td>
</tr>
<tr>
<td>整数类型</td>
<td>int(integer)</td>
<td>普通大小的整数(32位二进制)</td>
</tr>
<tr>
<td>小数类型</td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td>小数类型</td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td>小数类型</td>
<td>decimal(m,d)</td>
<td>压缩严格的定点数</td>
</tr>
<tr>
<td>日期类型</td>
<td>year</td>
<td>YYYY 1901~2155</td>
</tr>
<tr>
<td>日期类型</td>
<td>time</td>
<td>HH:MM:SS -838:59:59~838:59:59</td>
</tr>
<tr>
<td>日期类型</td>
<td>date</td>
<td>YYYY-MM-DD 1000-01-01~9999-12-3</td>
</tr>
<tr>
<td>日期类型</td>
<td>datetime</td>
<td>YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td>
</tr>
<tr>
<td>日期类型</td>
<td>timestamp</td>
<td>YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>CHAR(M)</td>
<td>M为0~255之间的整数</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>VARCHAR(M)</td>
<td>M为0~65535之间的整数</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>TINYBLOB</td>
<td>允许长度0~255字节</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>BLOB</td>
<td>允许长度0~65535字节</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>MEDIUMBLOB</td>
<td>允许长度0~167772150字节</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>LONGBLOB</td>
<td>允许长度0~4294967295字节</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>TINYTEXT</td>
<td>允许长度0~255字节</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>TEXT</td>
<td>允许长度0~65535字节</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>MEDIUMTEXT</td>
<td>允许长度0~167772150字节</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>LONGTEXT</td>
<td>允许长度0~4294967295字节</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>VARBINARY(M)</td>
<td>允许长度0~M个字节的变长字节字符串</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>BINARY(M)</td>
<td>允许长度0~M个字节的定长字节字符串</td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li><p><code>1、整数类型</code>，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<br> <code>长度</code>：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。<br> <code>例子</code>，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p>
</li>
<li><p><code>2、实数类型</code>，包括FLOAT、DOUBLE、DECIMAL。<br> DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。<br> 而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。<br> 计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p>
</li>
<li><p><code>3、字符串类型</code>，包括VARCHAR、CHAR、TEXT、BLOB<br> VARCHAR用于存储可变长字符串，它比定长类型更节省空间。<br> VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。<br> VARCHAR存储的内容超出设置的长度时，内容会被截断。<br> CHAR是定长的，根据定义的字符串长度分配足够的空间。<br> CHAR会根据需要使用空格进行填充方便比较。<br> CHAR适合存储很短的字符串，或者所有值都接近同一个长度。<br> CHAR存储的内容超出设置的长度时，内容同样会被截断。</p>
<p><strong>使用策略：</strong><br> 对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。<br> 对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br> 使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br> 尽量避免使用TEXT&#x2F;BLOB类型，查询时会使用临时表，导致严重的性能开销。</p>
</li>
<li><p><code>4、枚举类型（ENUM）</code>，把不重复的数据存储为一个预定义的集合。<br> 有时可以使用ENUM代替常用的字符串类型。<br> ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。<br> ENUM在内部存储时，其实存的是整数。<br> 尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。<br> 排序是按照内部存储的整数</p>
</li>
<li><p><code>5、日期和时间类型</code>，尽量使用timestamp，空间效率高于datetime，<br> 用整数保存时间戳通常不方便处理。<br> 如果需要存储微妙，可以使用bigint存储。<br> 看到这里，这道真题是不是就比较容易回答了。</p>
</li>
</ul>
<h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><h3 id="MySQL存储引擎MyISAM与InnoDB区别"><a href="#MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别"></a>MySQL存储引擎MyISAM与InnoDB区别</h3><ul>
<li>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</li>
<li>常用的存储引擎有以下：<ul>
<li><strong>Innodb引擎</strong>：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li>
<li><strong>MyIASM引擎</strong>(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</li>
<li><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li>
</ul>
</li>
</ul>
<p><strong>MyISAM与InnoDB区别</strong></p>
<blockquote>
<table>
<thead>
<tr>
<th>比较</th>
<th>MyISAM</th>
<th>Innodb</th>
</tr>
</thead>
<tbody><tr>
<td>存储结构</td>
<td>每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td>
<td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td>
</tr>
<tr>
<td>存储空间</td>
<td>MyISAM可被压缩，存储空间较小</td>
<td>InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td>
</tr>
<tr>
<td>可移植性、备份及恢复</td>
<td>由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td>
<td>免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td>
</tr>
<tr>
<td>文件格式</td>
<td>数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td>
<td>数据和索引是集中存储的，<code>.ibd</code></td>
</tr>
<tr>
<td>记录存储顺序</td>
<td>按记录插入顺序保存</td>
<td>按主键大小有序插入</td>
</tr>
<tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td>
<td>表级锁定</td>
<td>行级锁定、表级锁定，锁定力度小并发能力高</td>
</tr>
<tr>
<td>SELECT</td>
<td>MyISAM更优</td>
<td>–</td>
</tr>
<tr>
<td>INSERT、UPDATE、DELETE</td>
<td>–</td>
<td>InnoDB更优</td>
</tr>
<tr>
<td>select count(*)</td>
<td>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td>
<td></td>
</tr>
<tr>
<td>索引的实现方式</td>
<td>B+树索引，myisam 是堆表</td>
<td>B+树索引，Innodb 是索引组织表</td>
</tr>
<tr>
<td>哈希索引</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h3><ul>
<li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li>
<li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li>
<li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>
<li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li>
</ul>
<h3 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a>InnoDB引擎的4大特性</h3><ul>
<li>插入缓冲（insert buffer)</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
<h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><ul>
<li>如果没有特别的需求，使用默认的<code>Innodb</code>即可。</li>
<li>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</li>
<li>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><ul>
<li>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</li>
<li>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</li>
<li>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</li>
</ul>
<h3 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h3><p><strong>索引的优点</strong></p>
<ul>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ul>
<p><strong>索引的缺点</strong></p>
<ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增&#x2F;改&#x2F;删的执行效率；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
<h3 id="怎么创建索引的，有什么好处，有哪些分类"><a href="#怎么创建索引的，有什么好处，有哪些分类" class="headerlink" title="怎么创建索引的，有什么好处，有哪些分类"></a>怎么创建索引的，有什么好处，有哪些分类</h3><ol>
<li>创建索引的语法：create index depe_unique_ide on depe(dept_no) tablespace idx_</li>
<li>创建索引可以增加查询速度，唯一索引可以保证数据库列的一致性，可以确定表与表之间的连接</li>
<li>索引的分类：             逻辑分类：单列索引，复合索引，唯一索引，非唯一索引，函数索引             物理分类：B数索引，反向键索引，位图索引</li>
</ol>
<h3 id="简述有哪些索引和作用"><a href="#简述有哪些索引和作用" class="headerlink" title="简述有哪些索引和作用"></a>简述有哪些索引和作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">索引的作用：通过索引可以大大的提高数据库的检索速度，改善数据库性能</span><br></pre></td></tr></table></figure>

<ol>
<li>唯一索引：不允许有俩行具有相同的值</li>
<li>主键索引：为了保持数据库表与表之间的关系</li>
<li>聚集索引：表中行的物理顺序与键值的逻辑（索引）顺序相同。</li>
<li>非聚集索引：聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致</li>
<li>复合索引：在创建索引时，并不是只能对一列进行创建索引，可以与主键一样，讲多个组合为索引</li>
<li>全文索引： 全文索引为在字符串数据中进行复杂的词搜索提供有效支持</li>
</ol>
<h3 id="索引使用场景"><a href="#索引使用场景" class="headerlink" title="索引使用场景"></a>索引使用场景</h3><ol>
<li>当数据多且字段值有相同的值得时候用普通索引。</li>
<li>当字段多且字段值没有重复的时候用唯一索引。</li>
<li>当有多个字段名都经常被查询的话用复合索引。</li>
<li>普通索引不支持空值，唯一索引支持空值。</li>
<li>但是，若是这张表增删改多而查询较少的话，就不要创建索引了，因为如果你给一列创建了索引，那么对该列进行增删改的时候，都会先访问这一列的索引，</li>
<li>若是增，则在这一列的索引内以新填入的这个字段名的值为名创建索引的子集，</li>
<li>若是改，则会把原来的删掉，再添入一个以这个字段名的新值为名创建索引的子集，</li>
<li>若是删，则会把索引中以这个字段为名的索引的子集删掉。</li>
<li>所以，会对增删改的执行减缓速度，</li>
<li>所以，若是这张表增删改多而查询较少的话，就不要创建索引了。</li>
<li>更新太频繁地字段不适合创建索引。</li>
<li>不会出现在where条件中的字段不该建立索引。</li>
</ol>
<h3 id="主键索引与唯一索引的区别"><a href="#主键索引与唯一索引的区别" class="headerlink" title="主键索引与唯一索引的区别"></a>主键索引与唯一索引的区别</h3><ol>
<li>主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。</li>
<li>主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。</li>
<li>唯一性索引列允许空值，而主键列不允许为空值。</li>
<li>主键列在创建时，已经默认为空值 ++    唯一索引了。</li>
<li>一个表最多只能创建一个主键，但可以创建多个唯一索引。</li>
<li>主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。</li>
<li>主键可以被其他表引用为外键，而唯一索引不能。   ？</li>
</ol>
<h3 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h3><p><strong>主键索引:</strong> 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p>
<p><strong>唯一索引:</strong> 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p>
<ul>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</li>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</li>
</ul>
<p><strong>普通索引:</strong> 基本的索引类型，没有唯一性的限制，允许为NULL值。</p>
<ul>
<li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name (column);</code>创建普通索引</li>
<li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code>创建组合索引</li>
</ul>
<p><strong>全文索引：</strong> 是目前搜索引擎使用的一种关键技术。</p>
<ul>
<li>可以通过<code>ALTER TABLE table_name ADD FULLTEXT (column);</code>创建全文索引</li>
</ul>
<h3 id="索引的数据结构（b树，hash）"><a href="#索引的数据结构（b树，hash）" class="headerlink" title="索引的数据结构（b树，hash）"></a>索引的数据结构（b树，hash）</h3><ul>
<li>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有<strong>Hash索引</strong>，<strong>B+树索引</strong>等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</li>
</ul>
<p><strong>1、B树索引</strong></p>
<ul>
<li>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c6ee6f5752~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>查询方式：<ul>
<li>主键索引区:PI(关联保存的时数据的地址)按主键查询,</li>
<li>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</li>
</ul>
</li>
<li>B+tree性质：<ol>
<li>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li>
<li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li>
<li>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li>
</ol>
</li>
</ul>
<p><strong>2、哈希索引</strong></p>
<ul>
<li>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c6ef9cb120~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<h3 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h3><ul>
<li>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</li>
<li>索引的原理很简单，就是把无序的数据变成有序的查询<ol>
<li>把创建了索引的列的内容进行排序</li>
<li>对排序结果生成倒排表</li>
<li>在倒排表内容上拼上数据地址链</li>
<li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li>
</ol>
</li>
</ul>
<h3 id="索引算法有哪些？"><a href="#索引算法有哪些？" class="headerlink" title="索引算法有哪些？"></a>索引算法有哪些？</h3><ul>
<li>索引算法有 BTree算法和Hash算法</li>
</ul>
<p><strong>1、BTree算法</strong></p>
<ul>
<li><p>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在&#x3D;,&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- 只要它的查询条件是一个不以通配符开头的常量</span><br><span class="line">select * from user where name like <span class="string">&#x27;jack%&#x27;</span>; </span><br><span class="line">-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span><br><span class="line">select * from user where name like <span class="string">&#x27;%jack&#x27;</span>; </span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、Hash算法</strong></p>
<ul>
<li>Hash Hash索引只能用于对等比较，例如&#x3D;,&lt;&#x3D;&gt;（相当于&#x3D;）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</li>
</ul>
<h3 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a>索引设计的原则？</h3><ol>
<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li>
<li>基数较小的类，索引效果较差，没有必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li>
</ol>
<h3 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a>创建索引的原则</h3><ul>
<li>索引虽好，但也不是无限制的使用，最好符合一下几个原则</li>
</ul>
<ol>
<li>最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>较频繁作为查询条件的字段才去创建索引</li>
<li>更新频繁字段不适合创建索引</li>
<li>若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li>
<li>定义有外键的数据列一定要建立索引。</li>
<li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li>
<li>对于定义为text、image和bit的数据类型的列不要建立索引。</li>
</ol>
<h3 id="创建索引的三种方式"><a href="#创建索引的三种方式" class="headerlink" title="创建索引的三种方式"></a>创建索引的三种方式</h3><ul>
<li><p>第一种方式：在执行CREATE TABLE时创建索引</p>
<p>CREATE TABLE user_index2 ( id INT auto_increment PRIMARY KEY, first_name VARCHAR (16), last_name VARCHAR (16), id_card VARCHAR (18), information text, KEY name (first_name, last_name), FULLTEXT KEY (information), UNIQUE KEY (id_card) );</p>
</li>
<li><p>第二种方式：使用ALTER TABLE命令去增加索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX <span class="title function_">index_name</span> <span class="params">(column_list)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</li>
<li>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</li>
<li>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</li>
</ul>
</li>
<li><p>第三种方式：使用CREATE INDEX命令创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE INDEX index_name ON <span class="title function_">table_name</span> <span class="params">(column_list)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</li>
</ul>
</li>
</ul>
<h3 id="如何删除索引"><a href="#如何删除索引" class="headerlink" title="如何删除索引"></a>如何删除索引</h3><ul>
<li><p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">alter table user_index drop KEY name;</span><br><span class="line">alter table user_index drop KEY id_card;</span><br><span class="line">alter table user_index drop KEY information;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>
</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c6ef8bc6a4~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<ul>
<li><p>需要取消自增长再行删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">alter table user_index</span><br><span class="line">-- 重新定义字段</span><br><span class="line">MODIFY id <span class="type">int</span>,</span><br><span class="line">drop PRIMARY KEY</span><br></pre></td></tr></table></figure>
</li>
<li><p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>
</li>
</ul>
<h3 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h3><ul>
<li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li>
</ul>
<h3 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</span><br></pre></td></tr></table></figure>

<ul>
<li>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I&#x2F;O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li>
<li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h3><ul>
<li>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增&#x2F;改&#x2F;删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</li>
</ul>
<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><ul>
<li>语法：<code>index(field(10))</code>，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</li>
<li>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</li>
<li>实操的难度：在于前缀截取的长度。</li>
<li>我们可以利用<code>select count(*)/count(distinct left(password,prefixLen));</code>，通过从调整<code>prefixLen</code>的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前<code>prefixLen</code>个字符几乎能确定唯一一条记录）</li>
</ul>
<h3 id="什么是最左前缀原则？什么是最左匹配原则"><a href="#什么是最左前缀原则？什么是最左匹配原则" class="headerlink" title="什么是最左前缀原则？什么是最左匹配原则"></a>什么是最左前缀原则？什么是最左匹配原则</h3><ul>
<li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>&#x3D;和in可以乱序，比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
</ul>
<h3 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h3><ul>
<li>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</li>
<li>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c6efdfc051~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<h3 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a>使用B树的好处</h3><ul>
<li>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</li>
</ul>
<h3 id="使用B-树的好处"><a href="#使用B-树的好处" class="headerlink" title="使用B+树的好处"></a>使用B+树的好处</h3><ul>
<li>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</li>
</ul>
<h3 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h3><ul>
<li>首先要知道Hash索引和B+树索引的底层实现原理：</li>
<li>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</li>
</ul>
<p><strong>那么可以看出他们有以下的不同：</strong></p>
<ul>
<li><p>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</p>
</li>
<li><p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p>
</li>
<li><p>hash索引不支持使用索引进行排序，原理同上。</p>
</li>
<li><p>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</p>
</li>
<li><p>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</p>
</li>
<li><p>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</p>
</li>
<li><p>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。</p>
</li>
</ul>
<h3 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a>数据库为什么使用B+树而不是B树</h3><ul>
<li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li>
<li>B+树空间利用率更高，可减少I&#x2F;O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I&#x2F;O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li>
<li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li>
<li>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li>
<li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li>
</ul>
<h3 id="B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，"><a href="#B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，" class="headerlink" title="B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，"></a>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</h3><ul>
<li>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</span><br></pre></td></tr></table></figure>

<h3 id="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"><a href="#什么是聚簇索引？何时使用聚簇索引与非聚簇索引" class="headerlink" title="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"></a>什么是聚簇索引？何时使用聚簇索引与非聚簇索引</h3><ul>
<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li>
<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li>
</ul>
<p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">何时使用聚簇索引与非聚簇索引</span><br></pre></td></tr></table></figure>



<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c6f013b994~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<h3 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h3><ul>
<li>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</li>
<li>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行<code>select age from employee where age &lt; 20</code>的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</li>
</ul>
<h3 id="联合索引是什么？为什么需要注意联合索引中的顺序？"><a href="#联合索引是什么？为什么需要注意联合索引中的顺序？" class="headerlink" title="联合索引是什么？为什么需要注意联合索引中的顺序？"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h3><ul>
<li>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</li>
</ul>
<p><strong>具体原因为:</strong></p>
<ul>
<li>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</li>
<li>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h3><ul>
<li>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</li>
<li>事务最经典也经常被拿出来说例子就是转账了。</li>
<li>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</li>
</ul>
<h3 id="事物的四大特性-ACID-介绍一下"><a href="#事物的四大特性-ACID-介绍一下" class="headerlink" title="事物的四大特性(ACID)介绍一下?"></a>事物的四大特性(ACID)介绍一下?</h3><ul>
<li>关系性数据库需要遵循ACID规则，具体内容如下：</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c6f098cc5d~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<ol>
<li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h3 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h3><ul>
<li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li>
<li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。<strong>（数据内存不一致）</strong></li>
<li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。<strong>（数据总量不一致）</strong></li>
</ul>
<h3 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h3><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p><strong>SQL 标准定义了四个隔离级别：</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</li>
<li>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</li>
<li>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是**READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</li>
<li>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="对MySQL的锁了解吗"><a href="#对MySQL的锁了解吗" class="headerlink" title="对MySQL的锁了解吗"></a>对MySQL的锁了解吗</h3><ul>
<li>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</li>
<li>就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</li>
</ul>
<h3 id="从锁的类别上分MySQL都有哪些锁呢？"><a href="#从锁的类别上分MySQL都有哪些锁呢？" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？"></a>从锁的类别上分MySQL都有哪些锁呢？</h3><p><strong>从锁的类别上来讲</strong>，有共享锁和排他锁。</p>
<ul>
<li>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁就是让多个线程同时获取一个锁。</li>
<li>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排它锁也称作独占锁，一个锁在某一时刻只能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</li>
</ul>
<h3 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h3><ul>
<li>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</li>
<li>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</li>
<li>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</li>
<li>SERIALIZABLE 是限制性最强的隔离级别，因为该级别<strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</li>
</ul>
<h3 id="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"><a href="#按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法" class="headerlink" title="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"></a>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</h3><ul>
<li>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</li>
<li><strong>MyISAM和InnoDB存储引擎使用的锁：</strong><ul>
<li>MyISAM采用表级锁(table-level locking)。</li>
<li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li>
</ul>
</li>
</ul>
<p><strong>行级锁，表级锁和页级锁对比</strong></p>
<ul>
<li><strong>行级锁</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。<ul>
<li>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
</ul>
</li>
<li><strong>表级锁</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。<ul>
<li>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</li>
</ul>
</li>
<li><strong>页级锁</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。<ul>
<li>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li>
</ul>
</li>
</ul>
<h3 id="MySQL中InnoDB引擎的行锁是怎么实现的？"><a href="#MySQL中InnoDB引擎的行锁是怎么实现的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是怎么实现的？"></a>MySQL中InnoDB引擎的行锁是怎么实现的？</h3><ul>
<li>InnoDB是基于索引来完成行锁</li>
<li>例: select * from tab_with_index where id &#x3D; 1 for update;</li>
<li>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起</li>
</ul>
<h3 id="InnoDB存储引擎的锁的算法有三种"><a href="#InnoDB存储引擎的锁的算法有三种" class="headerlink" title="InnoDB存储引擎的锁的算法有三种"></a>InnoDB存储引擎的锁的算法有三种</h3><ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<p><strong>相关知识点：</strong></p>
<ol>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ol>
<h3 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h3><ul>
<li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</li>
<li>常见的解决死锁的方法<ul>
<li>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li>
<li>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li>
<li>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果业务不好处理,可以用分布式事务锁或者使用乐观锁</span><br></pre></td></tr></table></figure>

<h3 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h3><ul>
<li><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
</li>
<li><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>核心<span class="keyword">SQL</span>,主要靠<span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">select</span> status <span class="keyword">from</span> t_goods <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>核心<span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> x<span class="operator">=</span>x<span class="operator">+</span><span class="number">1</span>, version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125; <span class="keyword">and</span> version<span class="operator">=</span>#&#123;version&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>两种锁的使用场景</strong></p>
<ul>
<li>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</li>
<li>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></li>
</ul>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="为什么要使用视图？什么是视图？"><a href="#为什么要使用视图？什么是视图？" class="headerlink" title="为什么要使用视图？什么是视图？"></a>为什么要使用视图？什么是视图？</h3><ul>
<li>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</li>
<li>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</li>
</ul>
<h3 id="视图有哪些特点？"><a href="#视图有哪些特点？" class="headerlink" title="视图有哪些特点？"></a>视图有哪些特点？</h3><p><strong>视图的特点如下:</strong></p>
<ul>
<li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li>
<li>视图是由基本表(实表)产生的表(虚表)。</li>
<li>视图的建立和删除不影响基本表。</li>
<li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li>
<li>当视图来自多个基本表时，不允许添加和删除数据。</li>
</ul>
<p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p>
<h3 id="视图的使用场景有哪些？"><a href="#视图的使用场景有哪些？" class="headerlink" title="视图的使用场景有哪些？"></a>视图的使用场景有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</span><br></pre></td></tr></table></figure>

<p><strong>下面是视图的常见使用场景：</strong></p>
<ul>
<li>重用SQL语句；</li>
<li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li>
<li>使用表的组成部分而不是整个表；</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<h3 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h3><ol>
<li>查询简单化。视图能简化用户的操作</li>
<li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li>
<li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li>
</ol>
<h3 id="视图的缺点"><a href="#视图的缺点" class="headerlink" title="视图的缺点"></a>视图的缺点</h3><ol>
<li><p>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p>
</li>
<li><p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</p>
<p>这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\SUM\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）</p>
</li>
</ol>
<h3 id="什么是游标？"><a href="#什么是游标？" class="headerlink" title="什么是游标？"></a>什么是游标？</h3><ul>
<li>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</li>
</ul>
<h2 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h2><h3 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h3><ul>
<li>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</li>
</ul>
<p><strong>优点</strong></p>
<ol>
<li>存储过程是预编译过的，执行效率高。</li>
<li>存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</li>
<li>安全性高，执行存储过程需要有一定权限的用户。</li>
<li>存储过程可以重复使用，减少数据库开发人员的工作量。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>调试麻烦，但是用 PL&#x2F;SQL Developer 调试很方便！弥补这个缺点。</li>
<li>移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</li>
<li>重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</li>
<li>如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</li>
</ol>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="什么是触发器？触发器的使用场景有哪些？"><a href="#什么是触发器？触发器的使用场景有哪些？" class="headerlink" title="什么是触发器？触发器的使用场景有哪些？"></a>什么是触发器？触发器的使用场景有哪些？</h3><ul>
<li>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>可以通过数据库中的相关表实现级联更改。</li>
<li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li>
<li>例如可以生成某些业务的编号。</li>
<li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li>
<li>大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li>
</ul>
<h3 id="MySQL中都有哪些触发器？"><a href="#MySQL中都有哪些触发器？" class="headerlink" title="MySQL中都有哪些触发器？"></a>MySQL中都有哪些触发器？</h3><p><strong>在MySQL数据库中有如下六种触发器：</strong></p>
<ul>
<li>Before Insert</li>
<li>After Insert</li>
<li>Before Update</li>
<li>After Update</li>
<li>Before Delete</li>
<li>After Delete</li>
</ul>
<h2 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h2><h3 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a>SQL语句主要分为哪几类</h3><ul>
<li><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p>
<p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p>
</li>
<li><p>数据查询语言DQL（Data Query Language）SELECT</p>
<p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p>
</li>
<li><p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p>
<p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p>
</li>
<li><p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p>
<p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p>
</li>
</ul>
<h3 id="SQL语句的语法顺序："><a href="#SQL语句的语法顺序：" class="headerlink" title="SQL语句的语法顺序："></a>SQL语句的语法顺序：</h3><ol>
<li>SELECT</li>
<li>FROM</li>
<li>JOIN</li>
<li>ON</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>UNION</li>
<li>ORDER BY</li>
<li>LIMIT</li>
</ol>
<h3 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h3><ul>
<li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li>
<li>候选键：是最小超键，即没有冗余元素的超键。</li>
<li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li>
<li>外键：在一个表中存在的另一个表的主键称此表的外键。</li>
</ul>
<h3 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a>SQL 约束有哪几种？</h3><blockquote>
<p>SQL 约束有哪几种？</p>
</blockquote>
<ul>
<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>
<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>
<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>
<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>
<li>CHECK: 用于控制字段的值范围。</li>
</ul>
<h3 id="六种关联查询"><a href="#六种关联查询" class="headerlink" title="六种关联查询"></a>六种关联查询</h3><ul>
<li><p>交叉连接（CROSS JOIN）</p>
</li>
<li><p>内连接（INNER JOIN）</p>
</li>
<li><p>外连接（LEFT JOIN&#x2F;RIGHT JOIN）</p>
</li>
<li><p>联合查询（UNION与UNION ALL）</p>
</li>
<li><p>全连接（FULL JOIN）</p>
</li>
<li><p>交叉连接（CROSS JOIN）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN <span class="title function_">B</span> <span class="params">(CROSS JOIN C)</span>#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id=B.id或者SELECT * FROM A INNER JOIN B ON A.id=B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>内连接分为三类</strong></p>
<ul>
<li>等值连接：ON A.id&#x3D;B.id</li>
<li>不等值连接：ON A.id &gt; B.id</li>
<li>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id&#x3D;T2.pid</li>
</ul>
<p><strong>外连接（LEFT JOIN&#x2F;RIGHT JOIN）</strong></p>
<ul>
<li>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</li>
<li>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</li>
</ul>
<p><strong>联合查询（UNION与UNION ALL）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * FROM A UNION SELECT * FROM B UNION ...</span><br></pre></td></tr></table></figure>

<ul>
<li>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</li>
<li>如果使用UNION ALL，不会合并重复的记录行</li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<p><strong>全连接（FULL JOIN）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM A LEFT JOIN B ON A.id=B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id=B.id</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>MySQL不支持全连接</li>
<li>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li>
</ul>
<h4 id="表连接面试题"><a href="#表连接面试题" class="headerlink" title="表连接面试题"></a>表连接面试题</h4><h5 id="有2张表。"><a href="#有2张表。" class="headerlink" title="有2张表。"></a>有2张表。</h5><ul>
<li>1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录</li>
</ul>
<p><strong>R表</strong></p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
</tr>
</tbody></table>
<p><strong>S表</strong></p>
<table>
<thead>
<tr>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h5 id="1、交叉连接-笛卡尔积"><a href="#1、交叉连接-笛卡尔积" class="headerlink" title="1、交叉连接(笛卡尔积)"></a>1、交叉连接(笛卡尔积)</h5><ul>
<li>SQL</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select r.*,s.* from r,s</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h5 id="2、内连接结果"><a href="#2、内连接结果" class="headerlink" title="2、内连接结果"></a>2、内连接结果</h5><ul>
<li>SQL</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select r.*,s.* from r inner join s on r.c=s.c</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
</tbody></table>
<h5 id="3、左连接结果"><a href="#3、左连接结果" class="headerlink" title="3、左连接结果"></a>3、左连接结果</h5><ul>
<li>SQL</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select r.*,s.* from r left join s on r.c=s.c</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="4、右连接结果"><a href="#4、右连接结果" class="headerlink" title="4、右连接结果"></a>4、右连接结果</h5><ul>
<li>SQL</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select r.*,s.* from r right join s on r.c=s.c</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h5 id="5、全表连接的结果（MySql不支持，Oracle支持）"><a href="#5、全表连接的结果（MySql不支持，Oracle支持）" class="headerlink" title="5、全表连接的结果（MySql不支持，Oracle支持）"></a>5、全表连接的结果（MySql不支持，Oracle支持）</h5><ul>
<li>SQL</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select r.*,s.* from r full join s on r.c=s.c</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h3 id="什么是子查询"><a href="#什么是子查询" class="headerlink" title="什么是子查询"></a>什么是子查询</h3><ol>
<li>条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果</li>
<li>嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</li>
</ol>
<h3 id="mysql中-in-和-exists-区别"><a href="#mysql中-in-和-exists-区别" class="headerlink" title="mysql中 in 和 exists 区别"></a>mysql中 in 和 exists 区别</h3><ul>
<li>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。<ol>
<li>如果查询的两个表大小相当，那么用in和exists差别不大。</li>
<li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</li>
<li>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</li>
</ol>
</li>
</ul>
<h3 id="varchar与char的区别"><a href="#varchar与char的区别" class="headerlink" title="varchar与char的区别"></a>varchar与char的区别</h3><p><strong>char的特点</strong></p>
<ul>
<li>char表示定长字符串，长度是固定的；</li>
<li>如果插入数据的长度小于char的固定长度时，则用空格填充；</li>
<li>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li>
<li>对于char来说，最多能存放的字符个数为255，和编码无关</li>
</ul>
<p><strong>varchar的特点</strong></p>
<ul>
<li>varchar表示可变长字符串，长度是可变的；</li>
<li>插入的数据是多长，就按照多长来存储；</li>
<li>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li>
<li>对于varchar来说，最多能存放的字符个数为65532</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</span><br></pre></td></tr></table></figure>

<h3 id="varchar-50-中50的涵义"><a href="#varchar-50-中50的涵义" class="headerlink" title="varchar(50)中50的涵义"></a>varchar(50)中50的涵义</h3><ul>
<li>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</li>
</ul>
<h3 id="int-20-中20的涵义"><a href="#int-20-中20的涵义" class="headerlink" title="int(20)中20的涵义"></a>int(20)中20的涵义</h3><ul>
<li>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；</li>
<li>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</li>
</ul>
<h3 id="mysql为什么这么设计"><a href="#mysql为什么这么设计" class="headerlink" title="mysql为什么这么设计"></a>mysql为什么这么设计</h3><ul>
<li>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</li>
</ul>
<h3 id="mysql中int-10-和char-10-以及varchar-10-的区别"><a href="#mysql中int-10-和char-10-以及varchar-10-的区别" class="headerlink" title="mysql中int(10)和char(10)以及varchar(10)的区别"></a>mysql中int(10)和char(10)以及varchar(10)的区别</h3><ul>
<li>int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。</li>
<li>char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间</li>
<li>varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符</li>
</ul>
<h3 id="FLOAT和DOUBLE的区别是什么？"><a href="#FLOAT和DOUBLE的区别是什么？" class="headerlink" title="FLOAT和DOUBLE的区别是什么？"></a>FLOAT和DOUBLE的区别是什么？</h3><ul>
<li>FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</li>
<li>DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</li>
</ul>
<h3 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h3><ul>
<li>三者都表示删除，但是三者有一些差别：</li>
</ul>
<table>
<thead>
<tr>
<th>比较</th>
<th>Delete</th>
<th>Truncate</th>
<th>Drop</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>属于DML</td>
<td>属于DDL</td>
<td>属于DDL</td>
</tr>
<tr>
<td>回滚</td>
<td>可回滚</td>
<td>不可回滚</td>
<td>不可回滚</td>
</tr>
<tr>
<td>删除内容</td>
<td>表结构还在，删除表的全部或者一部分数据行</td>
<td>表结构还在，删除表中的所有数据</td>
<td>从数据库中删除表，所有的数据行，索引和权限也会被删除</td>
</tr>
<tr>
<td>删除速度</td>
<td>删除速度慢，需要逐行删除</td>
<td>删除速度快</td>
<td>删除速度最快</td>
</tr>
</tbody></table>
<ul>
<li>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</li>
</ul>
<h3 id="UNION与UNION-ALL的区别？"><a href="#UNION与UNION-ALL的区别？" class="headerlink" title="UNION与UNION ALL的区别？"></a>UNION与UNION ALL的区别？</h3><ul>
<li>如果使用UNION ALL，不会合并重复的记录行</li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="说出一些数据库优化方面的经验"><a href="#说出一些数据库优化方面的经验" class="headerlink" title="说出一些数据库优化方面的经验?"></a>说出一些数据库优化方面的经验?</h3><ol>
<li>有外键约束的话会影响增删改的性能，如果应用程序可以保证数据库的完整性那就去除外键</li>
<li>Sql语句全部大写，特别是列名大写，因为数据库的机制是这样的，sql语句发送到数据库服务器，数据库首先就会把sql编译成大写在执行，如果一开始就编译成大写就不需要了把sql编译成大写这个步骤了</li>
<li>如果应用程序可以保证数据库的完整性，可以不需要按照三大范式来设计数据库</li>
<li>其实可以不必要创建很多索引，索引可以加快查询速度，但是索引会消耗磁盘空间</li>
<li>如果是jdbc的话，使用PreparedStatement不使用Statement，来创建SQl，PreparedStatement的性能比Statement的速度要快，使用PreparedStatement对象SQL语句会预编译在此对象中，PreparedStatement对象可以多次高效的执行</li>
</ol>
<h3 id="怎么优化SQL查询语句吗"><a href="#怎么优化SQL查询语句吗" class="headerlink" title="怎么优化SQL查询语句吗"></a>怎么优化SQL查询语句吗</h3><ol>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引</li>
<li>用索引可以提高查询</li>
<li>SELECT子句中避免使用*号，尽量全部大写SQL</li>
<li>应尽量避免在 where 子句中对字段进行 is null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，使用 IS NOT NULL</li>
<li>where 子句中使用 or 来连接条件，也会导致引擎放弃使用索引而进行全表扫描</li>
<li>in 和 not in 也要慎用，否则会导致全表扫描</li>
</ol>
<h3 id="你怎么知道SQL语句性能是高还是低"><a href="#你怎么知道SQL语句性能是高还是低" class="headerlink" title="你怎么知道SQL语句性能是高还是低"></a>你怎么知道SQL语句性能是高还是低</h3><ol>
<li>查看SQL的执行时间</li>
<li>使用explain关键字可以模拟优化器执行SQL查询语句，从而知道MYSQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</li>
</ol>
<h3 id="SQL的执行顺序"><a href="#SQL的执行顺序" class="headerlink" title="SQL的执行顺序"></a>SQL的执行顺序</h3><ol>
<li>FROM：将数据从硬盘加载到数据缓冲区，方便对接下来的数据进行操作。</li>
<li>WHERE：从基表或视图中选择满足条件的元组。（不能使用聚合函数）</li>
<li>JOIN（如right left 右连接——-从右边表中读取某个元组，并且找到该元组在左边表中对应的元组或元组集）</li>
<li>ON：join on实现多表连接查询，推荐该种方式进行多表查询，不使用子查询。</li>
<li>GROUP BY：分组，一般和聚合函数一起使用。</li>
<li>HAVING：在元组的基础上进行筛选，选出符合条件的元组。（一般与GROUP BY进行连用）</li>
<li>SELECT：查询到得所有元组需要罗列的哪些列。</li>
<li>DISTINCT：去重的功能。</li>
<li>UNION：将多个查询结果合并（默认去掉重复的记录）。</li>
<li>ORDER BY：进行相应的排序。</li>
<li>LIMIT 1：显示输出一条数据记录（元组）</li>
</ol>
<h3 id="如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？"><a href="#如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？" class="headerlink" title="如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？"></a>如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</h3><ul>
<li>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，<strong>对于查询语句，最重要的优化方式就是使用索引</strong>。 而<strong>执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等</strong>。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c720eda1ef~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<ul>
<li><p>执行计划包含的信息 </p>
<p>id</p>
<p> 有一组数字组成。表示一个查询中各个子查询的执行顺序;</p>
<ul>
<li>id相同执行顺序由上至下。</li>
<li>id不同，id值越大优先级越高，越先被执行。</li>
<li>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</li>
</ul>
</li>
</ul>
<p><strong>select_type</strong> 每个子查询的查询类型，一些常见的查询类型。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>不包含任何子查询或union等查询</td>
</tr>
<tr>
<td>2</td>
<td>PRIMARY</td>
<td>包含子查询最外层查询就显示为 PRIMARY</td>
</tr>
<tr>
<td>3</td>
<td>SUBQUERY</td>
<td>在select或 where字句中包含的查询</td>
</tr>
<tr>
<td>4</td>
<td>DERIVED</td>
<td>from字句中包含的查询</td>
</tr>
<tr>
<td>5</td>
<td>UNION</td>
<td>出现在union后的查询语句中</td>
</tr>
<tr>
<td>6</td>
<td>UNION RESULT</td>
<td>从UNION中获取结果集，例如上文的第三个例子</td>
</tr>
</tbody></table>
<ul>
<li><strong>table</strong> 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id <strong>partitions</strong> 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">create table <span class="title function_">tmp</span> <span class="params">(</span></span><br><span class="line"><span class="params">    id <span class="type">int</span> unsigned not <span class="literal">null</span> AUTO_INCREMENT,</span></span><br><span class="line"><span class="params">    name varchar(<span class="number">255</span>)</span>,</span><br><span class="line">    PRIMARY <span class="title function_">KEY</span> <span class="params">(id)</span></span><br><span class="line">) engine = innodb</span><br><span class="line">partition by <span class="title function_">key</span> <span class="params">(id)</span> partitions <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>type</strong>(非常重要，可以看到有没有走索引) 访问类型<ul>
<li>ALL 扫描全表数据</li>
<li>index 遍历索引</li>
<li>range 索引范围查找</li>
<li>index_subquery 在子查询中使用 ref</li>
<li>unique_subquery 在子查询中使用 eq_ref</li>
<li>ref_or_null 对Null进行索引的优化的 ref</li>
<li>fulltext 使用全文索引</li>
<li>ref 使用非唯一索引查找数据</li>
<li>eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</li>
</ul>
</li>
<li><strong>possible_keys</strong> 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</li>
<li><strong>key</strong> 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</li>
<li><strong>TIPS</strong>:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中</li>
<li><strong>key_length</strong> 索引长度</li>
<li><strong>ref</strong> 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
<li><strong>rows</strong> 返回估算的结果集数目，并不是一个准确的值。</li>
<li><strong>extra</strong> 的信息非常丰富，常见的有：<ol>
<li>Using index 使用覆盖索引</li>
<li>Using where 使用了用where子句来过滤结果集</li>
<li>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。</li>
<li>Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。 </span><br><span class="line">说明： </span><br><span class="line"><span class="number">1</span>） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 </span><br><span class="line"><span class="number">2</span>） ref 指的是使用普通的索引（normal index）。 </span><br><span class="line"><span class="number">3</span>） range 对索引进行范围检索。 </span><br><span class="line">反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</span><br></pre></td></tr></table></figure>

<h3 id="SQL的生命周期？"><a href="#SQL的生命周期？" class="headerlink" title="SQL的生命周期？"></a>SQL的生命周期？</h3><ol>
<li>应用服务器与数据库服务器建立一个连接</li>
<li>数据库进程拿到请求sql</li>
<li>解析并生成执行计划，执行</li>
<li>读取数据到内存并进行逻辑处理</li>
<li>通过步骤一的连接，发送结果到客户端</li>
<li>关掉连接，释放资源</li>
</ol>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c7211423d0~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<h3 id="大表数据查询，怎么优化"><a href="#大表数据查询，怎么优化" class="headerlink" title="大表数据查询，怎么优化"></a>大表数据查询，怎么优化</h3><ol>
<li>优化shema、sql语句+索引；</li>
<li>第二加缓存，memcached, redis；</li>
<li>主从复制，读写分离；</li>
<li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li>
<li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li>
</ol>
<h3 id="超大分页怎么处理？"><a href="#超大分页怎么处理？" class="headerlink" title="超大分页怎么处理？"></a>超大分页怎么处理？</h3><p><strong>超大的分页一般从两个方向上来解决.</strong></p>
<ul>
<li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于<code>select * from table where age &gt; 20 limit 1000000,10</code>这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为<code>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</code>.这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以<code>select * from table where id &gt; 1000000 limit 10</code>,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li>
<li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li>
</ul>
<p><strong>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可</strong></p>
<h3 id="mysql-分页"><a href="#mysql-分页" class="headerlink" title="mysql 分页"></a>mysql 分页</h3><ul>
<li><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</p>
<p>SELECT * FROM table LIMIT 5,10; &#x2F;&#x2F; 检索记录行 6-15</p>
</li>
<li><p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p>
<p>SELECT * FROM table LIMIT 95,-1; &#x2F;&#x2F; 检索记录行 96-last.</p>
</li>
<li><p>如果只给定一个参数，它表示返回最大的记录行数目：</p>
<p>SELECT * FROM table LIMIT 5; &#x2F;&#x2F;检索前 5 个记录行</p>
</li>
<li><p>换句话说，LIMIT n 等价于 LIMIT 0,n。</p>
</li>
</ul>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><blockquote>
<p>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。</p>
</blockquote>
<ul>
<li>开启慢查询日志</li>
<li>配置项：<code>slow_query_log</code></li>
<li>可以使用<code>show variables like ‘slov_query_log’</code>查看是否开启，如果状态值为<code>OFF</code>，可以使用<code>set GLOBAL slow_query_log = on</code>来开启，它会在<code>datadir</code>下产生一个<code>xxx-slow.log</code>的文件。</li>
<li>设置临界时间</li>
<li>配置项：<code>long_query_time</code></li>
<li>查看：<code>show VARIABLES like &#39;long_query_time&#39;</code>，单位秒</li>
<li>设置：<code>set long_query_time=0.5</code></li>
<li>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</li>
<li>查看日志，一旦SQL超过了我们设置的临界时间就会被记录到<code>xxx-slow.log</code>中</li>
</ul>
<h3 id="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a>关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h3><ul>
<li>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</li>
<li>慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？</li>
</ul>
<p><strong>所以优化也是针对这三个方向来的，</strong></p>
<ul>
<li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li>
<li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li>
<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li>
</ul>
<h3 id="为什么要尽量设定一个主键？"><a href="#为什么要尽量设定一个主键？" class="headerlink" title="为什么要尽量设定一个主键？"></a>为什么要尽量设定一个主键？</h3><ul>
<li>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</li>
</ul>
<h3 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h3><ul>
<li>推荐使用自增ID，不要使用UUID。</li>
<li>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总之，在数据量大一些的情况下，用自增主键性能会好一些。</span><br><span class="line">关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</span><br></pre></td></tr></table></figure>

<h3 id="字段为什么要求定义为not-null？"><a href="#字段为什么要求定义为not-null？" class="headerlink" title="字段为什么要求定义为not null？"></a>字段为什么要求定义为not null？</h3><ul>
<li>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</li>
</ul>
<h3 id="如果要存储用户的密码散列，应该使用什么字段进行存储？"><a href="#如果要存储用户的密码散列，应该使用什么字段进行存储？" class="headerlink" title="如果要存储用户的密码散列，应该使用什么字段进行存储？"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h3><ul>
<li>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</li>
</ul>
<h3 id="如何优化查询过程中的数据访问"><a href="#如何优化查询过程中的数据访问" class="headerlink" title="如何优化查询过程中的数据访问"></a>如何优化查询过程中的数据访问</h3><ul>
<li>访问数据太多导致查询性能下降</li>
<li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li>
<li>确认MySQL服务器是否在分析大量不必要的数据行</li>
<li>避免犯如下SQL语句错误</li>
<li>避免查询不需要的数据。解决办法：使用limit解决</li>
<li>多表关联返回全部列。解决办法：指定列名</li>
<li>总是返回全部列。解决办法：避免使用SELECT *</li>
<li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li>
<li>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</li>
<li>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li>
<li>改变数据库和表的结构，修改数据表范式</li>
<li>重写SQL语句，让优化器可以以更优的方式执行查询。</li>
</ul>
<h3 id="如何优化长难的查询语句"><a href="#如何优化长难的查询语句" class="headerlink" title="如何优化长难的查询语句"></a>如何优化长难的查询语句</h3><ul>
<li>分析是一个复杂查询还是多个简单查询速度快</li>
<li>MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</li>
<li>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</li>
<li>将一个大的查询分为多个小的相同的查询</li>
<li>一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</li>
<li>分解关联查询，让缓存的效率更高。</li>
<li>执行单个查询可以减少锁的竞争。</li>
<li>在应用层做关联更容易对数据库进行拆分。</li>
<li>查询效率会有大幅提升。</li>
<li>较少冗余记录的查询。</li>
</ul>
<h3 id="优化特定类型的查询语句"><a href="#优化特定类型的查询语句" class="headerlink" title="优化特定类型的查询语句"></a>优化特定类型的查询语句</h3><ul>
<li>count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)</li>
<li>MyISAM中，没有任何where条件的count(*)非常快。</li>
<li>当有where条件时，MyISAM的count统计不一定比其它引擎快。</li>
<li>可以使用explain查询近似值，用近似值替代count(*)</li>
<li>增加汇总表</li>
<li>使用缓存</li>
</ul>
<h3 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h3><ul>
<li>确定ON或者USING子句中是否有索引。</li>
<li>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li>
</ul>
<h3 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h3><ul>
<li>用关联查询替代</li>
<li>优化GROUP BY和DISTINCT</li>
<li>这两种查询据可以使用索引来优化，是最有效的优化方法</li>
<li>关联查询中，使用标识列分组的效率更高</li>
<li>如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</li>
<li>WITH ROLLUP超级聚合，可以挪到应用程序处理</li>
</ul>
<h3 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h3><ul>
<li>LIMIT偏移量大的时候，查询效率较低</li>
<li>可以记录上次查询的最大ID，下次查询时直接根据该ID来查询</li>
</ul>
<h3 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h3><ul>
<li>UNION ALL的效率高于UNION</li>
</ul>
<h3 id="优化WHERE子句"><a href="#优化WHERE子句" class="headerlink" title="优化WHERE子句"></a>优化WHERE子句</h3><ul>
<li>多数数据库都是从左往右的顺序处理条件的，把能够过滤更多数据的条件放到前面，把过滤少的条件放在后面</li>
</ul>
<h3 id="SQL语句优化的一些方法"><a href="#SQL语句优化的一些方法" class="headerlink" title="SQL语句优化的一些方法"></a>SQL语句优化的一些方法</h3><ul>
<li><p>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
</li>
<li><p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select id from t where num is <span class="literal">null</span></span><br><span class="line">-- 可以在num上设置默认值<span class="number">0</span>，确保表中num列没有<span class="literal">null</span>值，然后这样查询：</span><br><span class="line">select id from t where num=<span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3.应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p>
</li>
<li><p>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select id from t where num=<span class="number">10</span> or num=<span class="number">20</span></span><br><span class="line">-- 可以这样查询：</span><br><span class="line">select id from t where num=<span class="number">10</span> union all select id from t where num=<span class="number">20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>5.in 和 not in 也要慎用，否则会导致全表扫描，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select id from t where num <span class="title function_">in</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span> </span><br><span class="line">-- 对于连续的数值，能用 between 就不要用 in 了：</span><br><span class="line">select id from t where num between <span class="number">1</span> and <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</p>
</li>
<li><p>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select id from t where num=<span class="meta">@num</span></span><br><span class="line">-- 可以改为强制查询使用索引：</span><br><span class="line">select id from t <span class="title function_">with</span><span class="params">(index(索引名)</span>) where num=<span class="meta">@num</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select id from t where num/<span class="number">2</span>=<span class="number">100</span></span><br><span class="line">-- 应改为:</span><br><span class="line">select id from t where num=<span class="number">100</span>*<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select id from t where <span class="title function_">substring</span><span class="params">(name,<span class="number">1</span>,<span class="number">3</span>)</span>=’abc’</span><br><span class="line">-- name以abc开头的id应改为:</span><br><span class="line">select id from t where name like ‘abc%’</span><br></pre></td></tr></table></figure>
</li>
<li><p>10.不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
</li>
</ul>
<h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><h3 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a>为什么要优化</h3><ul>
<li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li>
<li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li>
<li>数据是存放在磁盘上的，读写速度无法和内存相比</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</span><br></pre></td></tr></table></figure>

<h3 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h3><ul>
<li>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</li>
<li>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</li>
</ul>
<p><strong>将字段很多的表分解成多个表</strong></p>
<ul>
<li>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</li>
<li>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li>
</ul>
<p><strong>增加中间表</strong></p>
<ul>
<li>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</li>
<li>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</li>
</ul>
<p><strong>增加冗余字段</strong></p>
<ul>
<li>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</li>
<li>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</li>
</ul>
<p><strong>注意：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</span><br></pre></td></tr></table></figure>

<h3 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h3><ul>
<li>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</li>
<li>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</li>
<li>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</li>
<li>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</li>
</ul>
<h3 id="大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？"><a href="#大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？" class="headerlink" title="大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？"></a>大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<ol>
<li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</li>
<li><strong>读&#x2F;写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li>
<li><strong>缓存：</strong> 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li>
</ol>
<p><strong>还有就是通过分库分表的方式进行优化，主要有垂直分区、垂直分表和水平分区、水平分表</strong></p>
<h4 id="1、垂直分区"><a href="#1、垂直分区" class="headerlink" title="1、垂直分区"></a>1、垂直分区</h4><ul>
<li><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</li>
<li><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c7259992ab~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<ul>
<li><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I&#x2F;O次数。此外，垂直分区可以简化表的结构，易于维护。</li>
<li><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li>
</ul>
<h4 id="2、垂直分表"><a href="#2、垂直分表" class="headerlink" title="2、垂直分表"></a>2、垂直分表</h4><ul>
<li>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c725b21e8e~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p><strong>适用场景</strong></p>
<ul>
<li>1、如果一个表中某些列常用，另外一些列不常用</li>
<li>2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I&#x2F;O次数</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</li>
<li>对于应用层来说，逻辑算法增加开发成本</li>
<li>管理冗余列，查询所有数据需要join操作</li>
</ul>
<h4 id="3、水平分区"><a href="#3、水平分区" class="headerlink" title="3、水平分区"></a>3、水平分区</h4><ul>
<li><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></li>
<li>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c7300b465e~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</li>
<li>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨界点Join性能较差，逻辑复杂。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</span><br></pre></td></tr></table></figure>

<h4 id="4、水平分表："><a href="#4、水平分表：" class="headerlink" title="4、水平分表："></a>4、水平分表：</h4><ul>
<li>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c744498a9a~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p><strong>适用场景</strong></p>
<ul>
<li>1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</li>
<li>2、需要把数据存放在多个介质上。</li>
</ul>
<p><strong>水平切分的缺点</strong></p>
<ul>
<li>1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作</li>
<li>2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</li>
</ul>
<h4 id="数据库分片的两种常见方案："><a href="#数据库分片的两种常见方案：" class="headerlink" title="数据库分片的两种常见方案："></a>数据库分片的两种常见方案：</h4><ul>
<li><strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li>
<li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
<h4 id="分库分表后面临的问题"><a href="#分库分表后面临的问题" class="headerlink" title="分库分表后面临的问题"></a>分库分表后面临的问题</h4><ul>
<li><p><strong>事务支持</strong> 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p>
</li>
<li><p><strong>跨库join</strong></p>
<p>只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</p>
</li>
<li><p><strong>跨节点的count,order by,group by以及聚合函数问题</strong> 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p>
</li>
<li><p><strong>数据迁移，容量规划，扩容等问题</strong> 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</p>
</li>
<li><p><strong>ID问题</strong></p>
</li>
<li><p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略</p>
<ul>
<li>UUID 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 <strong>Twitter的分布式自增ID算法Snowflake</strong> 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</li>
</ul>
</li>
<li><p><strong>跨分片的排序分页问题</strong></p>
<p>一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c750f5b2cc~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="MySQL的复制原理以及流程"><a href="#MySQL的复制原理以及流程" class="headerlink" title="MySQL的复制原理以及流程"></a>MySQL的复制原理以及流程</h3><ul>
<li>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</li>
</ul>
<h4 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h4><ol>
<li>主数据库出现问题，可以切换到从数据库。</li>
<li>可以进行数据库层面的读写分离。</li>
<li>可以在从数据库上进行日常备份。</li>
</ol>
<h4 id="MySQL主从复制解决的问题"><a href="#MySQL主从复制解决的问题" class="headerlink" title="MySQL主从复制解决的问题"></a>MySQL主从复制解决的问题</h4><ul>
<li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li>
<li>负载均衡：降低单个服务器的压力</li>
<li>高可用和故障切换：帮助应用程序避免单点失败</li>
<li>升级测试：可以用更高版本的MySQL作为从库</li>
</ul>
<h4 id="MySQL主从复制工作原理"><a href="#MySQL主从复制工作原理" class="headerlink" title="MySQL主从复制工作原理"></a>MySQL主从复制工作原理</h4><ul>
<li>在主库上把数据更高记录到二进制日志</li>
<li>从库将主库的日志复制到自己的中继日志</li>
<li>从库读取中继日志的事件，将其重放到从库数据中</li>
</ul>
<h4 id="基本原理流程，3个线程以及之间的关联"><a href="#基本原理流程，3个线程以及之间的关联" class="headerlink" title="基本原理流程，3个线程以及之间的关联"></a>基本原理流程，3个线程以及之间的关联</h4><ul>
<li><strong>主</strong>：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</li>
<li><strong>从</strong>：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</li>
<li><strong>从</strong>：sql执行线程——执行relay log中的语句；</li>
</ul>
<h4 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c75eb7e749~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>Binary log：主数据库的二进制日志</li>
<li>Relay log：从服务器的中继日志</li>
</ul>
<ol>
<li>master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</li>
<li>salve开启一个I&#x2F;O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I&#x2F;O线程最终的目的是将这些事件写入到中继日志中。</li>
<li>SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</li>
</ol>
<h3 id="读写分离有哪些解决方案？"><a href="#读写分离有哪些解决方案？" class="headerlink" title="读写分离有哪些解决方案？"></a>读写分离有哪些解决方案？</h3><ul>
<li>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求<code>slave</code>不能写只能读（如果对<code>slave</code>执行写操作，那么<code>show slave status</code>将会呈现<code>Slave_SQL_Running=NO</code>，此时你需要按照前面提到的手动同步一下<code>slave</code>）。</li>
</ul>
<p><strong>方案一</strong></p>
<ul>
<li>使用mysql-proxy代理</li>
<li>优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用</li>
<li>缺点：降低性能， 不支持事务</li>
</ul>
<p><strong>方案二</strong></p>
<ul>
<li>使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。</li>
<li>如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert&#x2F;update&#x2F;delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。</li>
</ul>
<p><strong>方案三</strong></p>
<ul>
<li>使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.</li>
<li>缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。</li>
</ul>
<h3 id="备份计划，mysqldump以及xtranbackup的实现原理"><a href="#备份计划，mysqldump以及xtranbackup的实现原理" class="headerlink" title="备份计划，mysqldump以及xtranbackup的实现原理"></a>备份计划，mysqldump以及xtranbackup的实现原理</h3><ul>
<li><strong>(1)备份计划</strong><ul>
<li>视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。</li>
<li>100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</li>
</ul>
</li>
<li><strong>(2)备份恢复时间</strong><ul>
<li>物理备份恢复快，逻辑备份恢复慢</li>
<li>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</li>
<li>20G的2分钟（mysqldump）</li>
<li>80G的30分钟(mysqldump)</li>
<li>111G的30分钟（mysqldump)</li>
<li>288G的3小时（xtra)</li>
<li>3T的4小时（xtra)</li>
<li>逻辑导入时间一般是备份时间的5倍以上</li>
</ul>
</li>
<li><strong>(3)备份恢复失败如何处理</strong><ul>
<li>首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</li>
</ul>
</li>
</ul>
<p><strong>(4)mysqldump和xtrabackup实现原理</strong></p>
<ul>
<li><p>mysqldump</p>
<p>mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION &#x2F;*!40100 WITH CONSISTENTSNAPSHOT *&#x2F;)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data&#x3D;1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p>
</li>
<li><p>Xtrabackup:</p>
<p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交</p>
</li>
<li><p>概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。</p>
</li>
</ul>
<h3 id="数据表损坏的修复方式有哪些？"><a href="#数据表损坏的修复方式有哪些？" class="headerlink" title="数据表损坏的修复方式有哪些？"></a>数据表损坏的修复方式有哪些？</h3><p>使用 myisamchk 来修复，具体步骤：</p>
<ul>
<li>1 修复前将mysql服务停止。</li>
<li>2 打开命令行方式，然后进入到mysql的&#x2F;bin目录。</li>
<li>3 执行myisamchk –recover 数据库所在路径&#x2F;*.MYI</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table\_name 修复表 OPTIMIZE TABLE table\_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）</span><br></pre></td></tr></table></figure>


<p>作者：小杰要吃蛋<br>链接：<a href="https://juejin.cn/post/6844904127047139335">https://juejin.cn/post/6844904127047139335</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现乐观锁和悲观锁？</title>
    <url>/2022/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="如何实现乐观锁和悲观锁？"><a href="#如何实现乐观锁和悲观锁？" class="headerlink" title="如何实现乐观锁和悲观锁？"></a>如何实现乐观锁和悲观锁？</h1><ul>
<li><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
</li>
<li><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//核心SQL,主要靠for update</span><br><span class="line">select status from t_goods where id=1 for update;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//核心SQL</span><br><span class="line">update table set x=x+1, version=version+1 where id=#&#123;id&#125; and version=#&#123;version&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>两种锁的使用场景</strong></p>
<ul>
<li>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</li>
<li>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>解决跨域问题</title>
    <url>/2022/11/30/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h1><h2 id="后端配置固定地址"><a href="#后端配置固定地址" class="headerlink" title="后端配置固定地址"></a>后端配置固定地址</h2><p>在项目中新建 config 目录，配置一个类，实现 WebMvcConfigurer 接口，具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfg</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//设置允许跨域的路径</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">//设置允许跨域请求的域名</span></span><br><span class="line">               .allowedOrigins(<span class="string">&quot;http://127.0.0.1:9527&quot;</span>,<span class="string">&quot;http://127.0.0.1:8000&quot;</span>)</span><br><span class="line">                <span class="comment">//是否允许证书 不再默认开启</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">//设置允许的方法</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">//跨域允许时间</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 Credentials 为 true 时,<strong>Access-Control-Allow-Origin</strong> 不能是 * ，可配置为具体的 ip </p>
]]></content>
  </entry>
  <entry>
    <title>索引失效的几种情况</title>
    <url>/2022/12/03/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E4%B8%83%E7%A7%8D%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h1 id="索引失效的几种情况"><a href="#索引失效的几种情况" class="headerlink" title="索引失效的几种情况"></a>索引失效的几种情况</h1><ol>
<li><strong>条件有 ‘or’。</strong>如果想使用 ‘or’ ，又想索引有效，只能将 ‘or’ 条件中的每个列都加上索引。</li>
<li><strong>复合索引未使用左列字段。</strong>如果不使用前列，后续列也将无法使用。</li>
<li>like 以 % 开头。</li>
<li><strong>需要类型转换。</strong>比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引。</li>
<li>where 中索引列有运算。</li>
<li><strong>where 中索引列使用了函数</strong>。</li>
<li><strong>如果 mysql 觉得全表查询更快时（数据少）</strong></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基础</title>
    <url>/2022/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="数据库相关基础"><a href="#数据库相关基础" class="headerlink" title="数据库相关基础"></a>数据库相关基础</h1><h1 id="一、-触发器的作用"><a href="#一、-触发器的作用" class="headerlink" title="一、 触发器的作用"></a>一、 触发器的作用</h1><p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库的操作从而不允许未经许可的更新和变化。可以联级运算。如：某表上的触发器包含对另一张表的数据操作，二该操作又会导致该表的触发器被触发。</p>
<h1 id="二、-什么是存储过程？用什么来调用？"><a href="#二、-什么是存储过程？用什么来调用？" class="headerlink" title="二、 什么是存储过程？用什么来调用？"></a>二、 什么是存储过程？用什么来调用？</h1><p>存储过程：是事先经过编译并存储在数据库中的一段 SQL 语句的集合。</p>
<p>调用：</p>
<p>（1）可以用一个命令对象来调用存储过程</p>
<p>（2）可供外部程序调用，如JAVA程序</p>
<h1 id="三、-存储过程的的优缺点"><a href="#三、-存储过程的的优缺点" class="headerlink" title="三、 存储过程的的优缺点"></a>三、 存储过程的的优缺点</h1><p>优点：</p>
<p>（1）   执行率高：存储过程是预编译过的，执行率高</p>
<p>（2）   较少网络流量：存储过程的代码存在数据库中，调用时值需要传递存储过程的名称和参数即可，因此降低了网络传输的数据量</p>
<p>（3）   安全性高：执行存储过程需要有一定权限的用户</p>
<p>（4）   重复使用：存储过程可以重复使用，从而减少数据库开发人员的工作量</p>
<p>缺点：</p>
<p>（1）   可移植性差</p>
<p>（2）   更改比较繁琐：更改参数，更改GetValue（）调用</p>
<h1 id="四、-存储过程与函数的区别"><a href="#四、-存储过程与函数的区别" class="headerlink" title="四、 存储过程与函数的区别"></a>四、 存储过程与函数的区别</h1><table>
<thead>
<tr>
<th>存储过程</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>用于在数据库中完成特定的操作或者任务（如插入、删除等）</td>
<td>用于特定的数据（如选择）</td>
</tr>
<tr>
<td>程序头部声明用procedure</td>
<td>程序头部声明用 function</td>
</tr>
<tr>
<td>程序头部声明时不需描述返回类型</td>
<td>程序头部声明要描述返回类型，而且PL&#x2F;SQL块中至少要包括一个有效的  return 语句</td>
</tr>
<tr>
<td>可以使用in&#x2F;out&#x2F;in  out 三种模式的参数</td>
<td>可以使用in&#x2F;out&#x2F;in  out 三种模式的参数</td>
</tr>
<tr>
<td>可作为一个独立的PL&#x2F;SQL语句来执行</td>
<td>不能独立执行，必须作为表达式的一部分调用</td>
</tr>
<tr>
<td>可以通过out&#x2F;in  out 返回零个或多个值</td>
<td>通过return 语句返回一个值，且改值要与声明部分一致，也可通过 out 类型的参数带出的变量</td>
</tr>
<tr>
<td>SQL语句(DML 或SELECT)中不可调用存储过程</td>
<td>SQL语句(DML 或SELECT)中可调用函数</td>
</tr>
</tbody></table>
<h1 id="五、-索引的作用？优缺点？"><a href="#五、-索引的作用？优缺点？" class="headerlink" title="五、 索引的作用？优缺点？"></a>五、 索引的作用？优缺点？</h1><p>作用：提高系统的性能</p>
<p>优点：</p>
<p>（1）   通过创建唯一索引，可保证数据库表中的每一行数据的唯一性</p>
<p>（2）   加快数据的检索速度</p>
<p>（3）   加速表与表之间的连接</p>
<p>（4）   在使用分组和排序语句进行数据检索时，显著减少查询分组和排序的时间</p>
<p>（5）   通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统性能</p>
<p>缺点：</p>
<p>（1）   耗费时间：创建和维护索引要耗费时间，且耗费时间随数据量增加而增加</p>
<p>（2）   耗费空间：索引需要占物理空间，如建立聚簇索引耗费更大的空间</p>
<p>（3）   维护数据速度慢：对表进行增、改、删时，索引也要动态维护</p>
<h1 id="六、-什么样的字段适合建索引？"><a href="#六、-什么样的字段适合建索引？" class="headerlink" title="六、 什么样的字段适合建索引？"></a>六、 什么样的字段适合建索引？</h1><p>（1）   唯一的字段</p>
<p>（2）   不为空的字段</p>
<p>（3）   经常被查询的字段</p>
<h1 id="七、-索引的类型有哪些？"><a href="#七、-索引的类型有哪些？" class="headerlink" title="七、 索引的类型有哪些？"></a>七、 索引的类型有哪些？</h1><ol>
<li><p>单行索引：Single column</p>
</li>
<li><p>多行索引：Concatenated </p>
</li>
<li><p>唯一索引：Unique </p>
</li>
<li><p>非唯一索引：NonUnique </p>
</li>
<li><p>函数索引：Function-based</p>
</li>
<li><p>分区索引：Partitioned </p>
</li>
<li><p>非分区索引：NonPartitioned</p>
</li>
</ol>
<h1 id="八、-什么是事务？什么是锁？"><a href="#八、-什么是事务？什么是锁？" class="headerlink" title="八、 什么是事务？什么是锁？"></a>八、 什么是事务？什么是锁？</h1><ol>
<li><p>事务：一条语句或者一组语句要么全部成功，对数据中的某些数据成功修改；要么全部失败，回滚，数据中的数据还原到这些语句执行前</p>
</li>
<li><p>锁：<br> （1）共享锁（S）：可以并发读取数据，但不能修改数据。也就是说当数据资源上存在共享锁的时候，所有的事务都不能对这个资源进行修改，直到数据读取完成，共享锁释放。<br> （2）排它锁（X）：如果你对数据资源进行增删改操作时，不允许其它任何事务操作这块资源，直到排它锁被释放，防止同时对同一资源进行多重操作。<br> （3）更新锁（U）：防止出现死锁的锁模式，两个事务对一个数据资源进行先读取在修改的情况下，使用共享锁和排它锁有时会出现死锁现象，而使用更新锁则可以避免死锁的出现。资源的更新锁一次只能分配给一个事务，如果需要对资源进行修改，更新锁会变成排他锁，否则变为共享锁。<br> （4）意向锁：SQL Server需要在层次结构中的底层资源上（如行，列）获取共享锁，排它锁，更新锁。例如表级放置了意向共享锁，就表示事务要对表的页或行上使用共享锁。在表的某一行上上放置意向锁，可以防止其它事务获取其它不兼容的的锁。意向锁可以提高性能，因为数据引擎不需要检测资源的每一列每一行，就能判断是否可以获取到该资源的兼容锁。意向锁包括三种类型：意向共享锁（IS），意向排他锁（IX），意向排他共享锁（SIX）。<br> （5）架构锁：防止修改表结构时，并发访问的锁。<br> （6）大容量更新锁：允许多个线程将大容量数据并发的插入到同一个表中，在加载的同时，不允许其它进程访问该表。</p>
</li>
</ol>
<p><strong>在多用户都用事务同时访问同一个数据资源的情况下，就会造成以下几种数据错误。</strong></p>
<p><strong>（1）</strong>   <code>更新丢失</code>：多个用户同时对一个数据资源进行更新，必定会产生被覆盖的数据，造成数据读写异常。</p>
<p><strong>（2）</strong>   <code>不可重复读</code>：如果一个用户在一个事务中多次读取一条数据，而另外一个用户则同时更新啦这条数据，造成第一个用户多次读取数据不一致。</p>
<p><strong>（3）</strong>   <code>脏读</code>：第一个事务读取第二个事务正在更新的数据表，如果第二个事务还没有更新完成，那么第一个事务读取的数据将是一半为更新过的，一半还没更新过的数据，这样的数据毫无意义。</p>
<p><strong>（4）</strong>   <code>幻读</code>：第一个事务读取一个结果集后，第二个事务，对这个结果集经行增删操作，然而第一个事务中再次对这个结果集进行查询时，数据发现丢失或新增。</p>
<h1 id="九、-什么叫视图？游标是什么？"><a href="#九、-什么叫视图？游标是什么？" class="headerlink" title="九、 什么叫视图？游标是什么？"></a>九、 什么叫视图？游标是什么？</h1><p>视图：是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。</p>
<p>游标：是对查询出来的结果集作为一个单元来有效的处理。</p>
<p>游标是SQL 的一种数据访问机制 ，游标是一种处理数据的方法。</p>
<p>众所周知，使用SQL的select查询操作返回的结果是一个包含一行或者是多行的数据集，如果我们要对查询的结果再进行查询，比如（查看结果的第一行、下一行、最后一行、前十行等等操作）简单的通过select语句是无法完成的，因为这时候索要查询的结果不是数据表，而是已经查询出来的结果集。游标就是针对这种情况而出现的。</p>
<p><strong>游标的操作步骤：声明游标—&gt;打开游标—&gt;读取数据—&gt;关闭游标—&gt;删除游标</strong></p>
<h1 id="十、-视图的优缺点？"><a href="#十、-视图的优缺点？" class="headerlink" title="十、 视图的优缺点？"></a>十、 视图的优缺点？</h1><p>优点：</p>
<p>（1）   对数据库的访问，视图可以有选择性的选区数据库里的一部分。可选表中的行或列的子集</p>
<p>（2）   通过简单的查询可以从复杂查询中得到结果</p>
<p>（3）   维护数据的独立性，视图可以从多个表检索数据</p>
<p>（4）   对于相同的数据可产生不同的视图</p>
<p>缺点：</p>
<p>（1）   性能：SQL Server必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，SQL Server也把它变成一个复杂的结合体，需要花费一定的时间。</p>
<p>（2）   修改限制：当用户试图修改视图的某些行时，SQL Server必须把它转化为对基本表的某些行的修改。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的。 </p>
<h1 id="十一、列举几种表的连接方式，有什么区别？"><a href="#十一、列举几种表的连接方式，有什么区别？" class="headerlink" title="十一、列举几种表的连接方式，有什么区别？"></a>十一、列举几种表的连接方式，有什么区别？</h1><p>内连接：只有两个元素表相匹配的才能在结果集中显示</p>
<p>外连接：</p>
<p>（1）   左外连接：左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示</p>
<p>（2）   右外连接：右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。</p>
<p>全外连接：连接的表中不匹配的数据全部会显示出来</p>
<p>交叉连接： 笛卡尔效应，显示的结果是链接表数的乘积。</p>
<h1 id="十二、主键和外键的区别？"><a href="#十二、主键和外键的区别？" class="headerlink" title="十二、主键和外键的区别？"></a>十二、主键和外键的区别？</h1><p>主键：在本表中是唯一的、不可唯空的，外键可以重复可以唯空</p>
<p>外键：外键和另一张表的主键关联，不能创建对应表中不存在的外键</p>
<h1 id="十三、在数据库中查询语句速度很慢，如何优化？"><a href="#十三、在数据库中查询语句速度很慢，如何优化？" class="headerlink" title="十三、在数据库中查询语句速度很慢，如何优化？"></a>十三、在数据库中查询语句速度很慢，如何优化？</h1><p>1.建索引 </p>
<p>2.减少表之间的关联 </p>
<p>3.优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据 量大的表排在前面 </p>
<p>4.简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据 </p>
<p>5.尽量用PreparedStatement来查询，不要用Statement</p>
<h1 id="十四、数据库的三范式是什么？"><a href="#十四、数据库的三范式是什么？" class="headerlink" title="十四、数据库的三范式是什么？"></a>十四、数据库的三范式是什么？</h1><p>第一范式：列不可再分 </p>
<p>第二范式：行可以唯一区分，主键约束 </p>
<p>第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束 且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上</p>
<h1 id="十五、Union-和-union-all-有什么不同？"><a href="#十五、Union-和-union-all-有什么不同？" class="headerlink" title="十五、Union 和 union all 有什么不同？"></a>十五、Union 和 union all 有什么不同？</h1><p>UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION。</p>
<p>UNION ALL只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。 从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用UNION ALL。</p>
<h1 id="十六、Varchar2-和-Varchar-有什么区别？"><a href="#十六、Varchar2-和-Varchar-有什么区别？" class="headerlink" title="十六、Varchar2 和 Varchar 有什么区别？"></a>十六、Varchar2 和 Varchar 有什么区别？</h1><p>Char的长度是固定的，而varchar2的长度是可以变化的，比如，存储字符串“abc”对于char(20)，表示你存储的字符将占20个字节，包含17个空，而同样的varchar2（20）只占了3个字节，20只是最大值，当你存储的字符小于20时，按实际长度存储。 char的效率要被varchar2的效率高。 目前varchar是varchar2的同义词，工业标准的varchar类型可以存储空字符串，但是oracle不能这样做，尽管它保留以后这样做的权利。Oracle自己开发了一个数据类型varchar2,这个类型不是一个标准的varchar，他将在数据库中varchar列可以存储空字符串的特性改为存储null值，如果你想有向后兼容的能力，oracle建议使用varchar2而不是varchar</p>
<h1 id="十七、Oracle-和-Mysql-的区别？"><a href="#十七、Oracle-和-Mysql-的区别？" class="headerlink" title="十七、Oracle 和 Mysql 的区别？"></a>十七、Oracle 和 Mysql 的区别？</h1><p>1）库函数不同。</p>
<p>2）Oracle是用表空间来管理的，Mysql不是。</p>
<p>3）显示当前所有的表、用户、改变连接用户、显示当前连接用户、执行外部脚本的语句的不同。</p>
<p>4）分页查询时候，mysql用limit oracle用rownum</p>
<p>\1. mysql&gt; <strong>SELECT</strong> * <strong>FROM</strong> <strong>table</strong> LIMIT 5,10; &#x2F;&#x2F; 检索记录行 6-15 &#x2F;&#x2F;为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： mysql&gt; <strong>SELECT</strong> * <strong>FROM</strong> <strong>table</strong> LIMIT 95,-1; &#x2F;&#x2F; 检索记录行 96-<strong>last</strong>. &#x2F;&#x2F;如果只给定一个参数，它表示返回最大的记录行数目： mysql&gt; <strong>SELECT</strong> * <strong>FROM</strong> <strong>table</strong> LIMIT 5; &#x2F;&#x2F;检索前 5 个记录行 &#x2F;&#x2F;换句话说，LIMIT n 等价于 LIMIT 0,n。 5）sql的语法的不同。</p>
<h1 id="十七、乐观锁和悲观锁"><a href="#十七、乐观锁和悲观锁" class="headerlink" title="十七、乐观锁和悲观锁"></a>十七、乐观锁和悲观锁</h1><p>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据，如果别人修改了数据则放弃操作，否则执行操作。</p>
<p>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁，上锁期间其他人不能修改数据。</p>
<p>悲观锁的实现方式是加锁，加锁既可以是对代码加锁（如Java 的 synchronized 关键字），也可以是对数据加锁（如 mysql 的排它锁）</p>
<p>Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<h2 id="乐观锁的实现方式：CAS-机制-和-版本号机制"><a href="#乐观锁的实现方式：CAS-机制-和-版本号机制" class="headerlink" title="乐观锁的实现方式：CAS 机制 和 版本号机制"></a>乐观锁的实现方式：CAS 机制 和 版本号机制</h2><h2 id="1-版本号控制"><a href="#1-版本号控制" class="headerlink" title="1.版本号控制"></a>1.版本号控制</h2><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>注意：使用版本号作为判断数据变化的标记，实际上可以根据实际情况选用其他能够标记数据版本的字段，如时间戳等</p>
<h2 id="2-CAS机制"><a href="#2-CAS机制" class="headerlink" title="2.  CAS机制"></a>2.  CAS机制</h2><p>CAS即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。</p>
<p><strong>CAS算法</strong>涉及到三个操作数</p>
<p>（1）   需要读写的内存值 V</p>
<p>（2）   进行比较的值 A</p>
<p>（3）   拟写入的新值 B</p>
<p>当且仅当 V 的值等于 A（A &#x3D;&#x3D; V） 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断地重试，直到操作成功为止</p>
<h2 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h2><ol>
<li><p>ABA问题：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 **”ABA”问题。<br>** 假设有两个线程——线程1和线程2，两个线程按照顺序进行以下操作：</p>
<p>(1)线程1读取内存中数据为A；</p>
<p>(2)线程2将该数据修改为B；</p>
<p>(3)线程2将该数据修改为A；</p>
<p>(4)线程1对数据进行CAS操作</p>
<p>在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题</p>
</li>
<li><p>循环时间长，开销大：自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
</li>
<li><p>只能保证一个共享变量的原子操作：CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p>
</li>
</ol>
<h2 id="悲观锁的实现"><a href="#悲观锁的实现" class="headerlink" title="悲观锁的实现"></a>悲观锁的实现</h2><p>场景：有用户A和用户B，在同一家店铺去购买同一个商品，但是商品的可购买数量只有一个</p>
<p>商品表t_goods</p>
<p>​                               </p>
<p>如果不加锁情况下，用户A和用户B同时下单会报错。</p>
<ul>
<li><p>加入当用户A对下单购买商品（臭豆腐）的时候，先去尝试对该数据（臭豆腐）加上悲观锁</p>
</li>
<li><p>加锁失败：说明商品（臭豆腐）正在被其他事务进行修改，当前查询需要等待或者抛出异常，具体返回的方式需要由开发者根据具体情况去定义</p>
</li>
<li><p>加锁成功：对商品（臭豆腐）进行修改，也就是只有用户A能买，用户B想买（臭豆腐）就必须一直等待。当用户A买好后，用户B再想去买（臭豆腐）的时候会发现数量已经为0，那么B看到后就会放弃购买 </p>
</li>
<li><p>在此期间如果有其他对该数据（臭豆腐）做修改或加锁的操作，都会等待我们解锁后或者直接抛出异常</p>
</li>
</ul>
<p>首先关闭 MySql 数据库的自动提交属性。因为 MYSQL默认使用的是 autocommit 模式，即当我们执行一个更新操作后，MYSQL 会立即将结果进行提交（SQL：set autocommit &#x3D; 0）</p>
<p>悲观锁加锁的SQL语句：select num t_goods where id &#x3D; 2 for update</p>
<p>事务A：查询数据 num &#x3D; 1</p>
<p>​    Select num from t_goods where id &#x3D; 2 for update;</p>
<p>事务B：事务B会一直等待事务A释放锁，如果事务A长期不释放锁，那么最终事务B会报错。报错：Lock wait timeout exceeded;try restarting transaction,表示语句被锁</p>
<h2 id="乐观锁的实现"><a href="#乐观锁的实现" class="headerlink" title="乐观锁的实现"></a>乐观锁的实现</h2><p>在进行更新语句的时候，加上版本号一起判断，如果版本号相同，则成功，版本号 version + 1；否则为失败，提示重新查询最新数据</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>项目部署上线（用户中心示例）</title>
    <url>/2022/12/04/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="项目部署上线-用户中心示例"><a href="#项目部署上线-用户中心示例" class="headerlink" title="项目部署上线-用户中心示例"></a>项目部署上线-用户中心示例</h1><h2 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h2><p>参考文章：<a href="https://blog.csdn.net/weixin_41701290/article/details/120173283">https://blog.csdn.net/weixin_41701290/article/details/120173283</a></p>
<p>本地开发：localhost（127.0.0.1）</p>
<p>多环境：指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上。</p>
<p>为什么需要？</p>
<ol>
<li>每个环境互不影响</li>
<li>区分不同的阶段：开发 &#x2F; 测试 &#x2F; 生产</li>
<li>对项目进行优化：<ol>
<li>本地日志级别</li>
<li>精简依赖，节省项目体积</li>
<li>项目的环境 &#x2F; 参数可以调整，比如 JVM 参数</li>
</ol>
</li>
</ol>
<p>针对不同环境做不同的事情。</p>
<p>多环境分类：</p>
<ol>
<li>本地环境（自己的电脑）localhost</li>
<li>开发环境（远程开发）大家连同一台机器，为了大家开发方便</li>
<li>测试环境（测试）开发 &#x2F; 测试 &#x2F; 产品，单元测试 &#x2F; 性能测试 &#x2F; 功能测试 &#x2F; 系统集成测试，独立的数据库、独立的服务器</li>
<li>预发布环境（体验服）：和正式环境一致，正式数据库，更严谨，查出更多问题</li>
<li>正式环境（线上，公开对外访问的项目）：尽量不要改动，保证上线前的代码是 “完美” 运行</li>
<li>沙箱环境（实验环境）：为了做实验</li>
</ol>
<h3 id="前端多环境实战"><a href="#前端多环境实战" class="headerlink" title="前端多环境实战"></a>前端多环境实战</h3><ul>
<li><p>请求地址</p>
<ul>
<li><p>开发环境：localhost:8000</p>
</li>
<li><p>线上环境：user-backend.code-nav.cn</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">startFront</span>(<span class="params">env</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(env === <span class="string">&#x27;prod&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 不输出注释 </span></span><br><span class="line">        <span class="comment">// 项目优化</span></span><br><span class="line">        <span class="comment">// 修改请求地址</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 保持本地开发逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用了 umi 框架，build 时会自动传入 NODE_ENV &#x3D;&#x3D; production 参数，start NODE_ENV 参数为 development</p>
</li>
<li><p>启动方式</p>
<ul>
<li>开发环境：npm run start（本地启动，监听端口、自动更新）</li>
<li>线上环境：npm run build（项目构建打包），可以使用 serve 工具启动（npm i -g serve）</li>
</ul>
</li>
<li><p>项目的配置</p>
<p>不同的项目（框架）都有不同的配置文件，umi 的配置文件是 config，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。参考文档：<a href="https://umijs.org/zh-CN/docs/deployment">https://umijs.org/zh-CN/docs/deployment</a></p>
<ul>
<li>开发环境：config.dev.ts</li>
<li>生产环境：config.prod.ts</li>
<li>公共配置：config.ts 不带后缀</li>
</ul>
</li>
</ul>
<h3 id="后端多环境实战"><a href="#后端多环境实战" class="headerlink" title="后端多环境实战"></a>后端多环境实战</h3><p>SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件</p>
<p>可以在启动项目时传入环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar .\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod</span><br></pre></td></tr></table></figure>

<p>主要是改：</p>
<ul>
<li><p>依赖的环境地址</p>
<ul>
<li><p>数据库地址</p>
</li>
<li><p>缓存地址</p>
</li>
<li><p>消息队列地址</p>
</li>
<li><p>项目端口号</p>
</li>
</ul>
</li>
<li><p>服务器配置</p>
</li>
</ul>
<h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>参考文章：<a href="https://www.bilibili.com/read/cv16179200">https://www.bilibili.com/read/cv16179200</a></p>
<p>需要 Linux 服务器（建议大家用 CentOS 8+ &#x2F; 7.6 以上）</p>
<h3 id="原始部署"><a href="#原始部署" class="headerlink" title="原始部署"></a>原始部署</h3><p>什么都自己装</p>
<h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>需要 web 服务器：<strong>nginx</strong> 、apache、tomcat</p>
<p>安装 nginx 服务器：</p>
<ol>
<li><p>用系统自带的软件包管理器快速安装，比如 centos 的 yum</p>
</li>
<li><p>自己到官网安装（参考文章）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o nginx-1.21.6.tar.gz http://nginx.org/download/nginx-1.21.6.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf nginx-1.21.6.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> nginx-1.21.6</span><br><span class="line"></span><br><span class="line">   37  2022-04-17 23:30:09 yum install pcre pcre-devel -y</span><br><span class="line">   39  2022-04-17 23:30:59 yum install openssl openssl-devel -y</span><br><span class="line">   41  2022-04-17 23:31:57 ./configure --with-http_ssl_module --with-http_v2_module --with-stream</span><br><span class="line">   42  2022-04-17 23:32:13 make</span><br><span class="line">   43  2022-04-17 23:32:54 make install</span><br><span class="line">   48  2022-04-17 23:33:40 <span class="built_in">ls</span> /usr/local/nginx/sbin/nginx</span><br><span class="line">   vim /etc/profile</span><br><span class="line">  在最后一行添加：<span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/nginx/sbin	</span><br><span class="line">  </span><br><span class="line">  nginx</span><br><span class="line">  </span><br><span class="line">  netstat -ntlp 查看启动情况</span><br></pre></td></tr></table></figure>

<p>注意 nginx 权限</p>
</li>
</ol>
<h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>java、maven</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y java-1.8.0-openjdk*</span><br><span class="line"></span><br><span class="line">curl -o apache-maven-3.8.5-bin.tar.gz https://dlcdn.apache.org/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> xxx 下载代码</span><br><span class="line"></span><br><span class="line">打包构建，跳过测试</span><br><span class="line">mvn package -DskipTests</span><br><span class="line"></span><br><span class="line">java -jar ./user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod</span><br></pre></td></tr></table></figure>



<h3 id="宝塔-Linux-部署"><a href="#宝塔-Linux-部署" class="headerlink" title="宝塔 Linux 部署"></a>宝塔 Linux 部署</h3><p>Linux 运维面板</p>
<p>官方安装教程：<a href="https://www.bt.cn/new/download.html">https://www.bt.cn/new/download.html</a></p>
<p>方便管理服务器、方便安装软件</p>
<h3 id="前端托管"><a href="#前端托管" class="headerlink" title="前端托管"></a>前端托管</h3><p>前端腾讯云 web 应用托管（比容器化更傻瓜式，不需要自己写构建应用的命令，就能启动前端项目）</p>
<blockquote>
<p><a href="https://console.cloud.tencent.com/webify/new">https://console.cloud.tencent.com/webify/new</a></p>
</blockquote>
<ul>
<li>小缺点：需要将代码放到代码托管平台上</li>
<li>优势：不用写命令、代码更新时自动构建</li>
</ul>
<h3 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h3><p>docker 是容器，可以将项目的环境（比如 java、nginx）和项目的代码一起打包成镜像，所有同学都能下载镜像，更容易分发和移植。</p>
<p>再启动项目时，不需要敲一大堆命令，而是直接下载镜像、启动镜像就可以了。</p>
<p>docker 可以理解为软件安装包。</p>
<p>Docker 安装：<a href="https://www.docker.com/get-started/">https://www.docker.com/get-started/</a> 或者宝塔安装</p>
<p>Dockerfile 用于指定构建 Docker 镜像的方法</p>
<p>Dockerfile 一般情况下不需要完全从 0 自己写，建议去 github、gitee 等托管平台参考同类项目（比如 springboot）</p>
<p>Dockerfile 编写：</p>
<ul>
<li>FROM 依赖的基础镜像</li>
<li>WORKDIR 工作目录</li>
<li>COPY 从本机复制文件</li>
<li>RUN 执行命令</li>
<li>CMD &#x2F; ENTRYPOINT（附加额外参数）指定运行容器时默认执行的命令</li>
</ul>
<p>根据 Dockerfile 构建镜像：</p>
<p><strong>一定要进入到对应的目录</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前端</span></span><br><span class="line">docker build -t user-center-frontend:v0.0.1 .</span><br><span class="line"><span class="comment"># 后端</span></span><br><span class="line">docker build -t user-center-backend:v0.0.1 .</span><br></pre></td></tr></table></figure>

<p>Docker 构建优化：减少尺寸、减少构建时间（比如多阶段构建，可以丢弃之前阶段不需要的内容）</p>
<ul>
<li><strong>-d:</strong> 后台运行容器，并返回容器ID；</li>
<li><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></li>
</ul>
<p>docker run 启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前端</span></span><br><span class="line">docker run -p 80:80 -d user-center-frontend:v0.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后端</span></span><br><span class="line">docker run -p 8080:8080 user-center-backend:v0.0.1</span><br></pre></td></tr></table></figure>

<p>虚拟化</p>
<ol>
<li>端口映射：把本机的资源（实际访问地址）和容器内部的资源（应用启动端口）进行关联</li>
<li>目录映射：把本机的端口和容器应用的端口进行关联</li>
</ol>
<p>进入容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -i -t  fee2bbb7c9ee /bin/bash</span><br><span class="line"><span class="comment"># fee2bbb7c9ee 为容器 Id，docker ps 进行查询 id </span></span><br></pre></td></tr></table></figure>



<p>查看进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps </span><br></pre></td></tr></table></figure>



<p>查看日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs -f [container-id]</span><br><span class="line"><span class="comment"># 添加 -f 跟踪日志输出</span></span><br></pre></td></tr></table></figure>



<p>杀死容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> </span><br><span class="line"><span class="comment"># docker kill abf5c6ebe2fe</span></span><br><span class="line"><span class="comment"># 指定镜像 Id </span></span><br></pre></td></tr></table></figure>



<p>强制删除镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi -f </span><br><span class="line"><span class="comment"># docker rmi -f repository 名称</span></span><br><span class="line"><span class="comment"># -f 为强制删除</span></span><br></pre></td></tr></table></figure>



<h3 id="Docker-平台部署"><a href="#Docker-平台部署" class="headerlink" title="Docker 平台部署"></a>Docker 平台部署</h3><ol>
<li>云服务商的容器平台（腾讯云、阿里云）</li>
<li>面向某个领域的容器平台（前端 &#x2F; 后端微信云托管）<strong>要花钱！</strong></li>
</ol>
<p>容器平台的好处：</p>
<ol>
<li>不用输命令来操作，更方便省事</li>
<li>不用在控制台操作，更傻瓜式、更简单</li>
<li>大厂运维，比自己运维更省心</li>
<li>额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩缩容、流水线）</li>
</ol>
<h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>用户中心（上线）1.mp4  时间：01:05:00</p>
<p>前端项目访问流程：用户输入网址 &#x3D;&gt; 域名解析服务器（把网址解析为 ip 地址 &#x2F; 交给其他的域名解析服务） &#x3D;&gt; 服务器 &#x3D;&gt;（防火墙）&#x3D;&gt; nginx 接收请求，找到对应的文件，返回文件给前端 &#x3D;&gt; 前端加载文件到浏览器中（js、css） &#x3D;&gt; 渲染页面</p>
<p>后端项目访问流程：用户输入网址 &#x3D;&gt; 域名解析服务器 &#x3D;&gt; 服务器 &#x3D;&gt; nginx 接收请求 &#x3D;&gt; 后端项目（比如 8080端口）</p>
<p>nginx 反向代理的作用：替服务器接收请求，转发请求</p>
<h2 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h2><p>浏览器为了用户的安全，仅允许向 <strong>同域名、同端口</strong> 的服务器发送请求。</p>
<p>如何解决跨域？</p>
<p>最直接的方式：把域名、端口改成相同的</p>
<h3 id="添加跨域头"><a href="#添加跨域头" class="headerlink" title="添加跨域头"></a>添加跨域头</h3><p>让服务器告诉浏览器：允许跨域（返回 cross-origin-allow 响应头）</p>
<h4 id="1-网关支持（Nginx）"><a href="#1-网关支持（Nginx）" class="headerlink" title="1. 网关支持（Nginx）"></a>1. 网关支持（Nginx）</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 跨域配置</span></span><br><span class="line"><span class="section">location</span><span class="regexp"> ^~</span> /api/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:8080/api/;</span><br><span class="line">    <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="variable">$http_origin</span>;</span><br><span class="line">    <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Methods <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Headers <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="variable">$http_origin</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="number">1728000</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Content-Type&#x27;</span> <span class="string">&#x27;text/plain; charset=utf-8&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Content-Length&#x27;</span> <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-修改后端服务–用户中心上线（2）-00-32-00"><a href="#2-修改后端服务–用户中心上线（2）-00-32-00" class="headerlink" title="2. 修改后端服务–用户中心上线（2） 00:32:00"></a>2. 修改后端服务–用户中心上线（2） 00:32:00</h4><ol>
<li><p>配置 @CrossOrigin 注解</p>
</li>
<li><p>添加 web 全局请求拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfg</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//设置允许跨域的路径</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">//设置允许跨域请求的域名</span></span><br><span class="line">                <span class="comment">//当**Credentials为true时，**Origin不能为星号，需为具体的ip地址【如果接口不带cookie,ip无需设成具体ip】</span></span><br><span class="line">                .allowedOrigins(<span class="string">&quot;http://localhost:9527&quot;</span>, <span class="string">&quot;http://127.0.0.1:9527&quot;</span>, <span class="string">&quot;http://127.0.0.1:8082&quot;</span>, <span class="string">&quot;http://127.0.0.1:8083&quot;</span>)</span><br><span class="line">                <span class="comment">//是否允许证书 不再默认开启</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">//设置允许的方法</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">//跨域允许时间</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义新的 corsFilter Bean，参考：<a href="https://www.jianshu.com/p/b02099a435bd">https://www.jianshu.com/p/b02099a435bd</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>项目部署上线</category>
      </categories>
      <tags>
        <tag>项目上线</tag>
      </tags>
  </entry>
  <entry>
    <title>匹配算法-优化</title>
    <url>/2022/12/08/12-13%20%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95-%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="12-13-匹配算法-优化"><a href="#12-13-匹配算法-优化" class="headerlink" title="12-13 匹配算法-优化"></a>12-13 匹配算法-优化</h1><p>主要内容：</p>
<ol>
<li>开发完成个人队伍页面、队伍检索等功能（前端、后端）</li>
<li>开发用户匹配功能（编辑距离算法）</li>
<li>优化用户匹配功能后端，开发前端用户匹配模式</li>
<li>优化前端加载效果，使用骨架屏</li>
<li>优化前端队伍操作权限</li>
<li>实现前端导航标题动态切换</li>
<li>优化前端、完善部分功能</li>
</ol>
<h2 id="前端不同页面怎么传递数据？"><a href="#前端不同页面怎么传递数据？" class="headerlink" title="前端不同页面怎么传递数据？"></a>前端不同页面怎么传递数据？</h2><ol>
<li>url querystring (xxx?id&#x3D;1) 比较适用于页面跳转</li>
<li>url (&#x2F;team&#x2F;:id,xxx&#x2F;1)</li>
<li>hash (&#x2F;team#1)</li>
<li>localStorage</li>
<li>context(全局变量，同页面或整个项目要访问的公共变量)</li>
</ol>
<h2 id="随机匹配"><a href="#随机匹配" class="headerlink" title="随机匹配"></a>随机匹配</h2><p>需求背景：为了帮助大家更快地发现和自己兴趣相同的朋友</p>
<p>思考：匹配一个还是多个？</p>
<p>答：匹配多个，并且按照匹配的相似度从高到低排序</p>
<p>思考：怎么匹配？（根据什么来进行匹配？）</p>
<p>答：根据标签 tags</p>
<p>还可以根据 user_team 匹配加入相同队伍的用户</p>
<p>问题本质：找到有相似标签的用户</p>
<h3 id="1-怎么匹配？"><a href="#1-怎么匹配？" class="headerlink" title="1.怎么匹配？"></a>1.怎么匹配？</h3><ol>
<li>找到有共同标签最多的用户（Top N）</li>
<li>共同标签越多，分数越高，月排在前面</li>
<li>如没有匹配的用户，随机推荐（降级方案）</li>
</ol>
<h4 id="两种算法"><a href="#两种算法" class="headerlink" title="两种算法"></a>两种算法</h4><ul>
<li>编辑距离算法：<a href="https://blog.csdn.net/DBC_121/article/details/104198838">https://blog.csdn.net/DBC_121/article/details/104198838</a></li>
</ul>
<p><u>最小编辑距离：字符串 1 通过最少多少次增删改字符的操作可以变成字符串 2</u></p>
<ul>
<li>余弦相似度算法（如果需要带权重计算，比如学什么方向最重要，性别相对次要）</li>
</ul>
<h3 id="2-怎么对所有用户匹配，去取TOP？"><a href="#2-怎么对所有用户匹配，去取TOP？" class="headerlink" title="2.怎么对所有用户匹配，去取TOP？"></a>2.怎么对所有用户匹配，去取TOP？</h3><p>直接取出所有用户，依次和当前用户计算分数，去 TOP N （54 秒）</p>
<h4 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h4><ol>
<li>切忌不要在数据量答的时候循环输出日志（取消日志后 20 秒）</li>
<li>Map 存了所有的分数信息，占用内存<br>解决：维护一个固定长度的有序集合（sortedSet），只保留分数最高的几个用户（时间换空间）</li>
<li>细节：剔除自己  √</li>
<li>尽量只查需要的数据：<br>a. 过滤掉标签为空的用户  √<br>b. 根据部分标签取用户（前提是能区分出来哪个标签比较重要）<br>c. 只查需要的数据 （比如 id 和 tags） √ （7 秒）</li>
<li>提前查？（定时任务）<br>a. 提前给所有用户给缓存（不适用于经常更新的数据）<br>b. 提前运算出来结果，缓存（针对一些重点用户，提前缓存）</li>
</ol>
<h4 id="类比大数据推荐机制"><a href="#类比大数据推荐机制" class="headerlink" title="类比大数据推荐机制"></a>类比大数据推荐机制</h4><p>大数据推荐场景：比如说几个亿个商品，难道要查出所有商品？难道要对所有数据计算一遍相似度？</p>
<p>大数据推荐流程：</p>
<ul>
<li>检索 &#x3D;&gt; 召回 &#x3D;&gt; 粗排 &#x3D;&gt; 精排 &#x3D;&gt; 重排序等</li>
<li>检索：尽可能多地查符合要求的数据（比如按记录查）</li>
<li>召回：查询可能要用到的数据（不做运算）</li>
<li>粗排：粗略排序，简单运算（运算相对轻量）</li>
<li>精排：精细排序，确定固定排位</li>
</ul>
<h4 id="分表学习建议"><a href="#分表学习建议" class="headerlink" title="分表学习建议"></a>分表学习建议</h4><ol>
<li>mycat、 sharding sphere 框架</li>
<li>一致性 hash 算法</li>
</ol>
<h2 id="队伍操作权限控制"><a href="#队伍操作权限控制" class="headerlink" title="队伍操作权限控制"></a>队伍操作权限控制</h2><h3 id="权限整理"><a href="#权限整理" class="headerlink" title="权限整理"></a>权限整理</h3><p>加入队伍：仅非队伍创建人、且未加入队伍的人可见</p>
<p>更新队伍：仅创建人可见</p>
<p>解散队伍：仅创建人可见</p>
<p>退出队伍：创建人不可见，仅加入队伍的人可见</p>
<h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>仅加入队伍和创建队伍的人看到队伍操作按钮（listTeam 接口要能获取我加入的队伍状态）</p>
<p>方案 1：前端查询我加入了哪些队伍列表，然后判断每个队伍 id 是否在列表中（前端要多发一次请求）</p>
<p>方案 2：在后端处理（推荐）</p>
<h2 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h2><ol>
<li><p>前端导航栏【标题】问题<br>解决：使用 router.beforeEach, 根据要跳转页面的 URL 路径匹配 config&#x2F;routes 配置 title 字段</p>
</li>
<li><p>强制登录，自动跳转到登录页 </p>
<p>解决：axios 全局配置响应拦截器、并且添加重定向</p>
</li>
<li><p>区别公开和加密队伍；加入有密码的队伍，要指定密码 </p>
</li>
<li><p>展示已加入队伍人数 </p>
</li>
<li><p>并发时，重复加入队伍的问题<br>解决：加锁、分布式锁</p>
</li>
</ol>
]]></content>
      <categories>
        <category>伙伴匹配系统</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>一次性定时任务</title>
    <url>/2022/12/08/6%E3%80%81%E4%B8%80%E6%AC%A1%E6%80%A7%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="6-一次性定时任务"><a href="#6-一次性定时任务" class="headerlink" title="6-一次性定时任务"></a>6-一次性定时任务</h1><p>主要内容：<br>1.主页前端开发（列表组件抽象）<br>2.批量插入数据功能开发+经验分享<br>3.定时任务注解<br>4.测试及优化批量导入功能（涉及性能优化+并发偏程知识）</p>
<h2 id="开发主页"><a href="#开发主页" class="headerlink" title="开发主页"></a>开发主页</h2><p>直接 list 列表组件实现</p>
<p>模拟 1000 万个用户， 再去查询</p>
<h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><h3 id="导入数据的方式"><a href="#导入数据的方式" class="headerlink" title="导入数据的方式"></a>导入数据的方式</h3><ol>
<li>用可视化界面:适合一次性导入、数据量可控</li>
<li>写程序：for 循环，但是尽量分批进行（可以用接口来控制）。<strong>保证可控、幂等，注意线上环境和测试环境是有区别的</strong></li>
<li>执行 SQL 语句：适用于小数据量</li>
</ol>
<h3 id="编写一次性任务"><a href="#编写一次性任务" class="headerlink" title="编写一次性任务"></a>编写一次性任务</h3><p>for 循环插入数据的特点：</p>
<ol>
<li>频繁建立和释放数据库连接（用批量查询解决）</li>
<li>for 循环是绝对线性的（可以并发提速）</li>
</ol>
<p><strong>注意：并发时不要用到非并发类的集合</strong></p>
<p>获取核心线程数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AVAILABLE_PROCESSORS</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors() - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>建立执行器（线程池）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(AVAILABLE_PROCESSORS, <span class="number">1000</span>, <span class="number">10000</span>, TimeUnit.MINUTES, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>));</span><br></pre></td></tr></table></figure>

<p>连接池的参数设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CPU 密集型：分配的核心线程数 = CPU - <span class="number">1</span></span><br><span class="line">IO  密集型：分配的核心线程数可以大于 CPU 核数</span><br></pre></td></tr></table></figure>

<p>建立一个测试类实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.yupi.yupao.model.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertUsersTest</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU 密集型：分配的核心线程数 = CPU - 1</span></span><br><span class="line">    <span class="comment">// IO  密集型：分配的核心线程数可以大于 CPU 核数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">40</span>, <span class="number">1000</span>, <span class="number">10000</span>, TimeUnit.MINUTES, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量插入用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doInsertUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INSERT_NUM</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; INSERT_NUM; i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setUsername(<span class="string">&quot;假墨枫&quot;</span>);</span><br><span class="line">            user.setUserAccount(<span class="string">&quot;fuckmofeng&quot;</span>);</span><br><span class="line">            user.setAvatarUrl(<span class="string">&quot;https://636f-codenav-8grj8px727565176-1256524210.tcb.qcloud.la/img/logo.png&quot;</span>);</span><br><span class="line">            user.setGender(<span class="number">0</span>);</span><br><span class="line">            user.setUserPassword(<span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">            user.setPhone(<span class="string">&quot;18963421945&quot;</span>);</span><br><span class="line">            user.setTags(<span class="string">&quot;[&#x27;男&#x27;,&#x27;java&#x27;]&quot;</span>);</span><br><span class="line">            user.setEmail(<span class="string">&quot;123456@qq.com&quot;</span>);</span><br><span class="line">            user.setUserStatus(<span class="number">0</span>);</span><br><span class="line">            user.setUserRole(<span class="number">0</span>);</span><br><span class="line">            user.setPlanetCode(<span class="string">&quot;112111&quot;</span>);</span><br><span class="line">            userList.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 20 秒 10 万条</span></span><br><span class="line">        userService.saveBatch(userList, <span class="number">10000</span>);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.println(stopWatch.getTotalTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>并发插入数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CPU 密集型：分配的核心线程数 = CPU - 1</span></span><br><span class="line"><span class="comment">// IO  密集型：分配的核心线程数可以大于 CPU 核数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">40</span>, <span class="number">1000</span>, <span class="number">10000</span>, TimeUnit.MINUTES, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发插入用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doConcurrencyInsertUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INSERT_NUM</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分十组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">//因为CompletableFuture实现了Future接口，我们先来回顾Future吧。</span></span><br><span class="line">    <span class="comment">//Future是Java5新加的一个接口，它提供了一种异步并行计算的功能。如果主线程需要执行一个很耗时的计算任务，我们就可以通过future把这个任务放到异步线程中执行。主线程继续处理其他任务，处理完成后，再通过Future获取计算结果。</span></span><br><span class="line">    List&lt;CompletableFuture&lt;Void&gt;&gt; futureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setUsername(<span class="string">&quot;假墨枫&quot;</span>);</span><br><span class="line">            user.setUserAccount(<span class="string">&quot;fuckmofeng&quot;</span>);</span><br><span class="line">            user.setAvatarUrl(<span class="string">&quot;https://636f-codenav-8grj8px727565176-1256524210.tcb.qcloud.la/img/logo.png&quot;</span>);</span><br><span class="line">            user.setGender(<span class="number">0</span>);</span><br><span class="line">            user.setUserPassword(<span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">            user.setPhone(<span class="string">&quot;18963421945&quot;</span>);</span><br><span class="line">            user.setTags(<span class="string">&quot;[&#x27;女&#x27;,&#x27;java&#x27;,&#x27;python&#x27;,&#x27;c++&#x27;]&quot;</span>);</span><br><span class="line">            user.setEmail(<span class="string">&quot;123456@qq.com&quot;</span>);</span><br><span class="line">            user.setUserStatus(<span class="number">0</span>);</span><br><span class="line">            user.setUserRole(<span class="number">0</span>);</span><br><span class="line">            user.setPlanetCode(<span class="string">&quot;112111&quot;</span>);</span><br><span class="line">            userList.add(user);</span><br><span class="line">            <span class="keyword">if</span>(j % batchSize == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新建异步任务,异步执行</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ThreadName:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            userService.saveBatch(userList, batchSize);</span><br><span class="line">        &#125;,executorService);</span><br><span class="line">        futureList.add(future);</span><br><span class="line">    &#125;</span><br><span class="line">    CompletableFuture.allOf(futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[]&#123;&#125;)).join();</span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    System.out.println(stopWatch.getTotalTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>伙伴匹配系统</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>整合 Swagger + Knife4j 接口文档</title>
    <url>/2022/12/08/Java%20%E5%90%8E%E7%AB%AF%E6%95%B4%E5%90%88%20Swagger%20+%20Knife4j%20%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="Java-后端整合-Swagger-Knife4j-接口文档"><a href="#Java-后端整合-Swagger-Knife4j-接口文档" class="headerlink" title="Java 后端整合 Swagger + Knife4j 接口文档"></a>Java 后端整合 Swagger + Knife4j 接口文档</h1><p>官方文档： <a href="https://doc.xiaominfo.com/docs/quick-start">https://doc.xiaominfo.com/docs/quick-start</a> </p>
<p>1.引入依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--引入Knife4j的官方start包,Swagger2基于Springfox2<span class="number">.10</span><span class="number">.5</span>项目--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">    &lt;!--使用Swagger2--&gt;</span><br><span class="line">    &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.0</span><span class="number">.9</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.添加配置类，<strong>注意：basePackage 需要填写 controller 的路径</strong></p>
<p>千万注意：线上环境不要把接口暴露出去！！！可以通过在 SwaggerConfig 配置文件开头加上 <code>@Profile(&#123;&quot;dev&quot;, &quot;test&quot;&#125;)</code> 限定配置仅在部分环境开启</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2WebMvc</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Knife4jConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;dockerBean&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">dockerBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//指定使用Swagger2规范</span></span><br><span class="line">        Docket docket=<span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(<span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                <span class="comment">//描述字段支持Markdown语法</span></span><br><span class="line">                .description(<span class="string">&quot;# Knife4j RESTful APIs&quot;</span>)</span><br><span class="line">                .termsOfServiceUrl(<span class="string">&quot;https://doc.xiaominfo.com/&quot;</span>)</span><br><span class="line">                .contact(<span class="string">&quot;xiaoymin@foxmail.com&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build())</span><br><span class="line">                <span class="comment">//分组名称</span></span><br><span class="line">                .groupName(<span class="string">&quot;用户服务&quot;</span>)</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//这里指定Controller扫描包路径</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.yupi.yupao.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> docket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 如果开发者使用的是Knife4j 2.x版本，并且Spring Boot版本高于2.4,那么需要在Spring Boot的yml文件中做如下配置： </p>
<p>3.在 application.yml 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    mvc:</span><br><span class="line">        pathmatch:</span><br><span class="line">            # 配置策略</span><br><span class="line">            matching-strategy: ant-path-matcher</span><br></pre></td></tr></table></figure>

<p>4.controller类中备注接口相应的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &quot;首页模块&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiImplicitParam(name = &quot;name&quot;,value = &quot;姓名&quot;,required = true)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;向客人问好&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sayHi&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">sayHi</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;)</span>String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;Hi:&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.访问地址，<strong>注意端口、实际的地址</strong></p>
<p>端口对应，正常访问<a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></p>
<p>如果配置类当中有配置路径，则需要加上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8888</span></span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /api</span><br></pre></td></tr></table></figure>

<p>该地址访问：<a href="http://localhost:8888/api/doc.html">http://localhost:8888/api/doc.html</a></p>
]]></content>
      <categories>
        <category>开源组件</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis plus 实现分页</title>
    <url>/2022/12/08/Mybatis%20plus%20%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="Mybatis-plus-分页"><a href="#Mybatis-plus-分页" class="headerlink" title="Mybatis plus 分页"></a>Mybatis plus 分页</h1><p>创建 MyBatisPlusConfig 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yupi.yupao.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题(该属性会在旧插件移除后一同移除)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>controller 代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/recommend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;Page&lt;User&gt;&gt; <span class="title function_">recommendUsers</span><span class="params">(<span class="type">long</span> pageSize, <span class="type">long</span> pageNum, HttpServletRequest request)</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    Page&lt;User&gt; userList = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(pageNum, pageSize), queryWrapper);</span><br><span class="line">    <span class="keyword">return</span> ResultUtils.success(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">onMounted(async () =&gt;&#123;</span><br><span class="line"><span class="comment">// Optionally the request above could also be done as</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">userListData</span> <span class="operator">=</span> await myAxios.get(<span class="string">&#x27;/user/recommend&#x27;</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      pageSize: <span class="number">8</span>,</span><br><span class="line">      pageNum: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">      .then(function (response) &#123;</span><br><span class="line">        console.log(<span class="string">&#x27;/user/recommend succeed&#x27;</span>, response);</span><br><span class="line">        Toast.success(<span class="string">&#x27;请求成功&#x27;</span>);</span><br><span class="line">        console.log(response.data.data)</span><br><span class="line">        <span class="keyword">return</span> response?.data?.records;</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="keyword">catch</span>(function (error) &#123;</span><br><span class="line">        console.error(<span class="string">&#x27;/user/recommend error&#x27;</span>, error);</span><br><span class="line">        Toast.fail(<span class="string">&#x27;请求失败&#x27;</span>);</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(userListData)&#123;</span><br><span class="line">    userListData.forEach(user =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(user.tags)&#123;</span><br><span class="line">        user.tags = JSON.parse(user.tags)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    userList.value = userListData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>伙伴匹配系统</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 缓存实现</title>
    <url>/2022/12/08/Redis%20%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E5%92%8C%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="Redis-缓存实现"><a href="#Redis-缓存实现" class="headerlink" title="Redis 缓存实现"></a>Redis 缓存实现</h2><p>NoSQL 数据库</p>
<p>key-value 存储系统（区别于 MYSQL 它存储的是键值对）</p>
<h3 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h3><p>基本数据结构：</p>
<ul>
<li>String 字符串类型：name:”mofeng”</li>
<li>List 列表：names:[“mofeng”,”dogmofeng”,”lu”]</li>
<li>Set 集合：names:[“mofeng”,”lu”] (值不能重复)</li>
<li>Hash 哈希：nameAge:{“mofeng”:1,”dogLu”:2}</li>
<li>Zset 集合：names[mofeng -9, doglu -12] (适合排行榜)</li>
</ul>
<p>高级：</p>
<ul>
<li>bloomfilter(布隆过滤器，主要从大量的数据中快速过滤值，比如邮件黑名单拦截)</li>
<li>geo(计算地理位置)</li>
<li>hyperloglog(pv&#x2F;uv)</li>
<li>pub&#x2F;sub(发布订阅，类以消息队列)</li>
<li>BitMap(1001010101010101010101010101)</li>
</ul>
<h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><p>为了防止写入 Redis 的数据乱码、浪费空间等，可以自定义序列化器，</p>
<p>新建 RedisTemplateConfig 类代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTemplateConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>controller 层代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主页 推荐用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageNum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/recommend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;Page&lt;User&gt;&gt; <span class="title function_">recommendUsers</span><span class="params">(<span class="type">long</span> pageSize, <span class="type">long</span> pageNum, HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">loginUser</span> <span class="operator">=</span> userService.getLoginUser(request);</span><br><span class="line">    <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> String.format(<span class="string">&quot;yupao:user:recommend:%s&quot;</span>, loginUser.getId());</span><br><span class="line">    ValueOperations&lt;String, Object&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">    <span class="comment">// 判断是否有缓存，有则直接读缓存</span></span><br><span class="line">    Page&lt;User&gt; userPage = (Page&lt;User&gt;) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">    <span class="keyword">if</span>(userPage != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ResultUtils.success(userPage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无缓存，则查询数据库</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    userPage = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(pageNum, pageSize), queryWrapper);</span><br><span class="line">    <span class="comment">//写缓存</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//指定缓存 30 秒过期</span></span><br><span class="line">        valueOperations.set(redisKey, userPage, <span class="number">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;redis set key error&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ResultUtils.success(userPage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-Spring-Data-Redis-操作-Redis"><a href="#使用-Spring-Data-Redis-操作-Redis" class="headerlink" title="使用 Spring Data Redis 操作 Redis"></a>使用 Spring Data Redis 操作 Redis</h3><p><strong>Spring Data Redis （推荐）</strong></p>
<p>地址：<a href="https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis">https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis</a></p>
<p>Spring Data：通用的数据访问框架，定义了一组 <strong>增删改查</strong>的接口</p>
<p>还可以操作：mysql、Redis、jpa</p>
<p>使用方式如下：</p>
<p>1）引入 Spring Data Redis 依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.6</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2）配置 Redis 地址</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># redis 配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="设计缓存-key"><a href="#设计缓存-key" class="headerlink" title="设计缓存 key"></a>设计缓存 key</h3><p>关键点：不同用户看到的数据不同</p>
<p>建议格式：</p>
<p>systemId:moduleld:fuc:options (防止其他系统的冲突)</p>
<p>比如：yupao:user:recommend:userId</p>
<p><strong>注意：Redis 内存不能无限增加，一定要设置过期时间！！！</strong></p>
<h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>问题：即使使用了缓存，第一个用户访问还是很慢</p>
<p>缓存预热的优点：</p>
<ol>
<li>解决第一个用户访问很慢，让用户始终快速访问</li>
<li>在一定程度上保护数据库</li>
</ol>
<p>缺点：</p>
<ol>
<li>增加开发成本（额外的开发、设计等）</li>
<li>预热的时机和时间错了，缓存的数据不对或者是未更新的数据</li>
<li>需要占用额外空间</li>
</ol>
<h3 id="怎么缓存预热"><a href="#怎么缓存预热" class="headerlink" title="怎么缓存预热"></a>怎么缓存预热</h3><ol>
<li>定时任务</li>
<li>手动触发</li>
</ol>
<h3 id="实现缓存预热"><a href="#实现缓存预热" class="headerlink" title="实现缓存预热"></a>实现缓存预热</h3><p>用定时任务，每天刷新所有用户的推荐列表</p>
<p>注意点：</p>
<ol>
<li>缓存预热的意义（新增少、总用户多）</li>
<li>缓存的空间不能太大，要预留给其他缓存空间</li>
<li>缓存数据的周期（此处为每天）</li>
</ol>
<p><strong>在 main 主类添加注解 @EnableScheduling</strong></p>
<p>cronTable 在线表达式生成，地址：<a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前面三个参数： 秒 分 时</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 38 6 * * *&quot;)</span></span><br></pre></td></tr></table></figure>

<p>新建 PreCacheJob 类实现缓存预热任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.yupi.yupao.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.yupi.yupao.model.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.yupi.yupao.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 预热缓存任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2022/11/10 6:03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreCacheJob</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; mainUserList = Arrays.asList(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每天执行预热推荐用户 cronTable 在线表达式生成 https://cron.qqe2.com/</span></span><br><span class="line">    <span class="comment">// 前面三个参数： 秒 分 时</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 38 6 * * *&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCacheRecommendUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Long userId : mainUserList) &#123;</span><br><span class="line">            QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">            Page&lt;User&gt; userPage = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">20</span>), queryWrapper);</span><br><span class="line">            <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> String.format(<span class="string">&quot;yupao:user:recommend:%s&quot;</span>, userId);</span><br><span class="line">            ValueOperations&lt;String, Object&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">            <span class="comment">//写缓存</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//指定缓存 30 秒过期</span></span><br><span class="line">                valueOperations.set(redisKey, userPage, <span class="number">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;redis set key error&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>伙伴匹配系统</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redisson 实现分布式锁</title>
    <url>/2022/12/08/Redisson%20%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E5%85%B7%E4%BD%93)/</url>
    <content><![CDATA[<h3 id="Redisson-实现分布式锁"><a href="#Redisson-实现分布式锁" class="headerlink" title="Redisson 实现分布式锁"></a>Redisson 实现分布式锁</h3><p>Redisson 是一个 Java 操作 Redis 的客户端，<strong>提供了大量的分布式数据集来简化对 Redis 的操作和使用，可以让开发者像使用本地集合一样使用 Redis（继承了和 Java 相同的集合类）</strong></p>
<p>关键词：Java Redis 客户端，分布式数据结构，实现了很多 Java 里支持的集合</p>
<h4 id="两种引用方式"><a href="#两种引用方式" class="headerlink" title="两种引用方式"></a>两种引用方式</h4><ol>
<li>spring boot starter 引入（不推荐，因为版本迭代太快，容易冲突）：<br><a href="https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter">https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter</a></li>
<li>直接引入：<a href="https://github.com/redisson/redisson#quick-start">https://github.com/redisson/redisson#quick-start</a></li>
</ol>
<p>(1)引入依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.17</span><span class="number">.5</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>(2)新建 RedissonConfig 配置类,配置地址、端口、创建实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Redisson 配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2022/11/10 23:58</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisAddress</span> <span class="operator">=</span> String.format(<span class="string">&quot;redis://%s:%s&quot;</span>, host, port);</span><br><span class="line">        config.useSingleServer().setAddress(redisAddress).setDatabase(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 2. 创建实例</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">        <span class="keyword">return</span> redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用Redisson"><a href="#使用Redisson" class="headerlink" title="使用Redisson"></a>使用Redisson</h4><p>创建分布式列表、Map，新建测试类示例代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//    list 数据存在本地 JVM   内存中</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;list:&quot;</span> + list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    数据存在 Redis 内存中</span></span><br><span class="line">    RList&lt;Object&gt; rList = redissonClient.getList(<span class="string">&quot;test-list&quot;</span>);</span><br><span class="line">    rList.add(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;RList:&quot;</span> + rList.get(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//rList.remove(0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    map</span></span><br><span class="line">    RMap&lt;Object, Object&gt; map = redissonClient.getMap(<span class="string">&quot;test-map&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;yupi&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    map.get(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;yupi&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分布式锁保证定时任务不重复执行"><a href="#分布式锁保证定时任务不重复执行" class="headerlink" title="分布式锁保证定时任务不重复执行"></a>分布式锁保证定时任务不重复执行</h4><p>实现代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testWatchDog</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;yupao:precachejob:docache:lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//只有一个线程获取到锁</span></span><br><span class="line">        <span class="keyword">if</span>(lock.tryLock(<span class="number">0</span>, -<span class="number">1</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">			<span class="comment">// TODO 实际要执行的方法</span></span><br><span class="line">            dosomething();</span><br><span class="line">            System.out.println(<span class="string">&quot;getLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//    只能释放自己的锁</span></span><br><span class="line">        <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;unLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>waitTime 设置为 0，只抢一次，抢不到就放弃</li>
<li>主要释放锁要写在 finally 语句块中，保证最后一定释放锁</li>
</ol>
<h4 id="Redisson-看门狗机制"><a href="#Redisson-看门狗机制" class="headerlink" title="Redisson 看门狗机制"></a>Redisson 看门狗机制</h4><p>Redisson 中提供的续期机制</p>
<p>开一个监听线程，如果方法还没执行完，就帮你重置 Redis 锁的过期时间</p>
<p><strong>原理：</strong></p>
<ol>
<li>监听当前线程，默认过期时间是 30 秒，每 10 秒续期一次（续期到 30 秒）</li>
<li>如果线程挂掉（注意 debug 模式也会被它当成服务器宕机），则不会续期</li>
</ol>
<p>详情参考文档：<a href="https://blog.csdn.net/qq_26222859/article/details/79645203">https://blog.csdn.net/qq_26222859/article/details/79645203</a></p>
<p>定时任务全部代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.yupi.yupao.model.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.yupi.yupao.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 预热缓存任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2022/11/10 6:03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreCacheJob</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; mainUserList = Arrays.asList(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每天执行预热推荐用户 cronTable 在线表达式生成 https://cron.qqe2.com/</span></span><br><span class="line">    <span class="comment">// 前面三个参数： 秒 分 时</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 37 1 * * *&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCacheRecommendUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取到 锁对象</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;yupao:precachejob:docache:lock&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//只有一个线程获取到锁</span></span><br><span class="line">            <span class="keyword">if</span>(lock.tryLock(<span class="number">0</span>, -<span class="number">1</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;getLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">                <span class="keyword">for</span> (Long userId : mainUserList) &#123;</span><br><span class="line">                    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">                    Page&lt;User&gt; userPage = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">20</span>), queryWrapper);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> String.format(<span class="string">&quot;yupao:user:recommend:%s&quot;</span>, userId);</span><br><span class="line">                    ValueOperations&lt;String, Object&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">                    <span class="comment">//写缓存</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//指定缓存 30 秒过期</span></span><br><span class="line">                        valueOperations.set(redisKey, userPage, <span class="number">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;redis set key error&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;doCacheRecommendUser error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//    只能释放自己的锁</span></span><br><span class="line">            <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;unLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>伙伴匹配系统</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Session 共享实现</title>
    <url>/2022/12/08/Session%20%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="Session-共享实现"><a href="#Session-共享实现" class="headerlink" title="Session 共享实现"></a>Session 共享实现</h3><h4 id="1-安装-Redis"><a href="#1-安装-Redis" class="headerlink" title="1. 安装 Redis"></a>1. 安装 Redis</h4><p>官网：<a href="https://redis.io/">https://redis.io/</a></p>
<p>windows 下载：</p>
<p>Redis 5.0.14 下载：</p>
<p>链接：<a href="https://pan.baidu.com/s/1XcsAIrdeesQAyQU2lE3cOg">https://pan.baidu.com/s/1XcsAIrdeesQAyQU2lE3cOg</a> </p>
<p>提取码：vkoi </p>
<p>redis 管理工具 quick redis：<a href="https://quick123.net/">https://quick123.net/</a></p>
<ol start="2">
<li>引入 redis，能够操作 redis：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>在 application.yml 中配置 Redis</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring</span><br><span class="line"># redis 配置</span><br><span class="line">  redis:</span><br><span class="line">    port: 6379</span><br><span class="line">    host: localhost</span><br><span class="line">    database: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入 spring-session 和 redis 的整合，使得自动将 session 存储到 redis 中：</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.session/spring-session-data-redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><pre><code class="xml">  session:
    timeout: 86400
    store-type: redis
</code></pre>
</li>
<li><p>修改 spring-session 存储配置 <code>spring.session.store-type</code></p>
<p>默认是 none，表示存储在单台服务器</p>
<p>store-type: redis，表示从 redis 读写 session</p>
</li>
</ol>
<p>JWT 的优缺点：<a href="https://zhuanlan.zhihu.com/p/108999941">https://zhuanlan.zhihu.com/p/108999941</a></p>
]]></content>
      <categories>
        <category>伙伴匹配系统</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 注解使用</title>
    <url>/2022/12/08/Spring%20%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Spring-注解使用"><a href="#Spring-注解使用" class="headerlink" title="Spring 注解使用"></a>Spring 注解使用</h1><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p> 该注解有一个prefix属性，通过指定的前缀，绑定配置文件中的配置，该注解可以放在类上，也可以放在方法上 </p>
<p> <strong>当将该注解作用于方法上时，如果想要有效的绑定配置，那么该方法需要有@Bean注解且所属Class需要有@Configuration注解。</strong> </p>
<p>application.yml 配置文件的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>使用参考代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisAddress</span> <span class="operator">=</span> String.format(<span class="string">&quot;redis://%s:%s&quot;</span>, host, port);</span><br><span class="line">        config.useSingleServer().setAddress(redisAddress).setDatabase(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 2. 创建实例</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">        <span class="keyword">return</span> redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Trancational-rollbackFor-x3D-Exception-class"><a href="#Trancational-rollbackFor-x3D-Exception-class" class="headerlink" title="@Trancational(rollbackFor &#x3D; Exception.class)"></a>@Trancational(rollbackFor &#x3D; Exception.class)</h2><p>声明式事务管理，添加位置为<strong>接口实现类、接口实现方法上</strong></p>
<p>默认配置下， Spring 只有抛出的异常为运行时， unchecked 异常时才会回滚该事务。即抛异常为 RunTimeException 的子类 （Error 也会导致事务回滚），抛出 checked 异常不会导致事务回滚。可通过 rollbackFor 来配置</p>
<h2 id="CrossOrigin"><a href="#CrossOrigin" class="headerlink" title="@CrossOrigin"></a>@CrossOrigin</h2><p>解决跨域问题，默认情况下允许在该注解中指定的所有源和 HTTP 方法</p>
<ul>
<li><strong>origins</strong>： 允许可访问的域列表</li>
<li><strong>maxAge</strong>:准备响应前的缓存持续的最大时间（以秒为单位）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &#123;&quot;http://127.0.0.1:5173/&quot;&#125;, allowCredentials = &quot;true&quot;)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>伙伴匹配系统</category>
      </categories>
      <tags>
        <tag>spring注解</tag>
      </tags>
  </entry>
  <entry>
    <title>伙伴匹配系统 bug</title>
    <url>/2022/12/08/bug%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="bug-解决"><a href="#bug-解决" class="headerlink" title="bug 解决"></a>bug 解决</h1><h2 id="前后端分离跨域问题"><a href="#前后端分离跨域问题" class="headerlink" title="前后端分离跨域问题"></a>前后端分离跨域问题</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &#123;&quot;http://127.0.0.1:5173/&quot;&#125;, allowCredentials = &quot;true&quot;)</span></span><br></pre></td></tr></table></figure>

<p>或者添加配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfg</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//设置允许跨域的路径</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">//设置允许跨域请求的域名</span></span><br><span class="line">               .allowedOrigins(<span class="string">&quot;http://127.0.0.1:9527&quot;</span>,<span class="string">&quot;http://127.0.0.1:8000&quot;</span>)</span><br><span class="line">                <span class="comment">//是否允许证书 不再默认开启</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">//设置允许的方法</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">//跨域允许时间</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="跨域请求不支持-cookie-操作"><a href="#跨域请求不支持-cookie-操作" class="headerlink" title="跨域请求不支持 cookie 操作"></a>跨域请求不支持 cookie 操作</h2><p>1.添加依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-session-core&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>添加配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.yupao.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.session.DefaultCookieSerializerCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.session.MapSessionRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.session.SessionRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.session.config.annotation.web.http.EnableSpringHttpSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.session.web.http.DefaultCookieSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSpringHttpSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SessionRepository <span class="title function_">sessionRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MapSessionRepository</span>(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DefaultCookieSerializerCustomizer <span class="title function_">cookieSerializerCustomizer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultCookieSerializerCustomizer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customize</span><span class="params">(DefaultCookieSerializer cookieSerializer)</span> &#123;</span><br><span class="line">                cookieSerializer.setSameSite(<span class="string">&quot;None&quot;</span>);</span><br><span class="line">                cookieSerializer.setUseSecureCookie(<span class="literal">true</span>); <span class="comment">// 此项必须，否则set-cookie会被chrome浏览器阻拦</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="加入加密队伍时，密码没正确验证"><a href="#加入加密队伍时，密码没正确验证" class="headerlink" title="加入加密队伍时，密码没正确验证"></a>加入加密队伍时，密码没正确验证</h2><p>修改 TeamServiceimpl 中 JoinTeam（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> team.getPassword();</span><br><span class="line"><span class="type">String</span> <span class="variable">requestPassword</span> <span class="operator">=</span> teamJoinRequest.getPassword();</span><br><span class="line"><span class="keyword">if</span>(TeamStatusEnum.SECRET.equals(teamStatusEnum))&#123;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(requestPassword) || !requestPassword.equals(team.getPassword()))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.PARAMS_ERROR, <span class="string">&quot;队伍密码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h2><p>&#x3D;&#x3D;SyntaxError: JSON.parse: unexpected character at line 1 colimn 2 of the JSON&#x3D;&#x3D;</p>
<p>JSON.parse 标准格式为单引号包裹双引号的格式 如 [“男”, “大一”]， 而 &#x3D;&#x3D;[‘南宁’, ‘本地’]&#x3D;&#x3D; 则会报错</p>
<p>参考地址：<a href="https://www.runoob.com/json/json-parse.html">https://www.runoob.com/json/json-parse.html</a></p>
]]></content>
      <tags>
        <tag>bug</tag>
        <tag>跨域</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>定时任务实现-Redisson实现分布式锁</title>
    <url>/2022/12/08/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0-Redisson%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="定时任务实现-Redisson实现分布式锁"><a href="#定时任务实现-Redisson实现分布式锁" class="headerlink" title="定时任务实现-Redisson实现分布式锁"></a>定时任务实现-Redisson实现分布式锁</h1><p>主要内容（后端）：</p>
<ol>
<li>分布式定时任务执行控制</li>
<li>锁的概念</li>
<li>分布式锁概念和常见问题</li>
<li>分布式锁实践</li>
</ol>
<h2 id="定时任务实现"><a href="#定时任务实现" class="headerlink" title="定时任务实现"></a>定时任务实现</h2><ol>
<li>Spring Scheduler (spring boot 默认整合了，推荐使用这种方式)</li>
<li>Quartz （独立于 Spring 存在的定时任务框架）</li>
<li>XXL-Job 之类的分布式任务调度平台（界面 + SDK）</li>
</ol>
<p>采用第一种方式：</p>
<ol>
<li>主类开启 @EnableScheduling</li>
<li>给要定时执行的方法添加 @Scheduling , 指定 cron 表达式或者执行频率</li>
</ol>
<p><strong>cron 表达式 用现成的工具即可：</strong><br><a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a><br><a href="https://www.matools.com/crontab/">https://www.matools.com/crontab/</a></p>
<h2 id="控制定时任务的执行"><a href="#控制定时任务的执行" class="headerlink" title="控制定时任务的执行"></a>控制定时任务的执行</h2><p>要控制定时任务在同一时间只有 1 台服务器能执行</p>
<p>原因：</p>
<ol>
<li>浪费资源</li>
<li>脏数据，比如重复插入</li>
</ol>
<p>如何做？</p>
<p>方案种类：</p>
<ol>
<li>分离定时任务程序和主程序，只在 1 个服务器运行定时任务，成本太大</li>
<li>写死配置，每个服务器都执行定时任务，但是只有 ip 符合配置的服务器才真正执行业务逻辑，其他的直接返回。成本最低；但是我们的 ip 可能不是固定的</li>
<li>动态配置，配置是可以轻松的、很方便地更新（代码无需重启），但是只有 ip 符合配置的服务器才真正执行业务逻辑。<ul>
<li>数据库</li>
<li>Redis</li>
<li>配置中心（Nacos、 Apollo、 Spring Cloud Config）</li>
</ul>
</li>
</ol>
<p>问题：服务器多了， ip 不可控还是很麻烦，还需要人工修改</p>
<ol start="4">
<li><p>分布式锁，只有抢到锁的服务器才能执行业务逻辑。<br>缺点：增加成本；<br>优点：不用手动配置，多少服务器都一样</p>
<p><strong>注意：只要是单机，就会存在单点故障</strong></p>
</li>
</ol>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>有限资源的情况下，控制同一时间（段）只有某些线程（用户 &#x2F;  服务器）能访问资源</p>
<p>Java 实现锁：sychronized 关键字、并发包的类</p>
<p>存在的问题：只对单个 JVM 有效</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="使用分布式锁的原因："><a href="#使用分布式锁的原因：" class="headerlink" title="使用分布式锁的原因："></a>使用分布式锁的原因：</h3><ol>
<li>有限资源的情况下，控制同一时间（段）只有某些线程（用户 &#x2F;  服务器）能访问资源</li>
<li>Java 实现锁：sychronized 关键字、并发包的类</li>
</ol>
<h3 id="分布式锁的关键"><a href="#分布式锁的关键" class="headerlink" title="分布式锁的关键"></a>分布式锁的关键</h3><h4 id="抢锁机制"><a href="#抢锁机制" class="headerlink" title="抢锁机制"></a>抢锁机制</h4><p>怎么保证同一时间只有 1 台服务器能抢到锁？</p>
<p><strong>核心思想：</strong>先来的人先把数据改成自己的标识（服务器 ip），后来的人发现标识已存在，就抢锁失败，继续等待</p>
<p>等待先来的人执行方法结束，把标识清空，其他人继续抢锁</p>
<p>MYSQL 数据库：select for update 行级锁（最简单），或者用乐观锁</p>
<p>Redis 实现：内存数据库，读写速度快。支持 setnx、 lua 脚本，比较方便我们实现分布式锁</p>
<p>setnx: set if not exists 如果不存在，则设置；只有设置成功才返回 true ，否则返回 false</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>1）用锁要释放</p>
<p>2）锁一定要加过期时间</p>
<p>3）如果方法执行时间过长，锁会提前过期</p>
<p>锁提前过期会导致的问题：</p>
<ol>
<li>连锁反应：释放掉别人的锁</li>
<li>仍然存在多个方法同时执行的情况</li>
</ol>
<p>解决方案：续期</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">end</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(!end)&#123;</span><br><span class="line">        <span class="comment">//续期</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">end = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>4)释放锁的时候，有可能先判断出自己的锁，但这时锁过期了，最后也可能释放别人的锁</p>
<p>解决方案：Redis + lua 脚本保证操作原子性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原子操作</span></span><br><span class="line"><span class="keyword">if</span>(get lock == A)&#123;</span><br><span class="line">    <span class="comment">// set lock B</span></span><br><span class="line">    del lock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5)Redis 如果是集群（不是只有一个 Redis），如果分布式锁的数据不同步怎么办？</p>
<p>解决方案：<a href="https://blog.csdn.net/feiying0canglang/article/details/113258494">https://blog.csdn.net/feiying0canglang/article/details/113258494</a></p>
<h3 id="Redisson-实现分布式锁"><a href="#Redisson-实现分布式锁" class="headerlink" title="Redisson 实现分布式锁"></a>Redisson 实现分布式锁</h3><p>Redisson 是一个 Java 操作 Redis 的客户端，<strong>提供了大量的分布式数据集来简化对 Redis 的操作和使用，可以让开发者像使用本地集合一样使用 Redis（继承了和 Java 相同的集合类）</strong></p>
<p>关键词：Java Redis 客户端，分布式数据结构，实现了很多 Java 里支持的集合</p>
<h4 id="两种引用方式"><a href="#两种引用方式" class="headerlink" title="两种引用方式"></a>两种引用方式</h4><ol>
<li>spring boot starter 引入（不推荐，因为版本迭代太快，容易冲突）：<br><a href="https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter">https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter</a></li>
<li>直接引入：<a href="https://github.com/redisson/redisson#quick-start">https://github.com/redisson/redisson#quick-start</a></li>
</ol>
<h4 id="使用Redisson"><a href="#使用Redisson" class="headerlink" title="使用Redisson"></a>使用Redisson</h4><p>示例代码，创建分布式列表、Map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    list 数据存在本地 JVM   内存中</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list:&quot;</span> + list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//    数据存在 Redis 内存中</span></span><br><span class="line">RList&lt;Object&gt; rList = redissonClient.getList(<span class="string">&quot;test-list&quot;</span>);</span><br><span class="line">rList.add(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;RList:&quot;</span> + rList.get(<span class="number">0</span>));</span><br><span class="line"><span class="comment">//rList.remove(0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    map</span></span><br><span class="line">RMap&lt;Object, Object&gt; map = redissonClient.getMap(<span class="string">&quot;test-map&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;yupi&quot;</span>, <span class="number">10</span>);</span><br><span class="line">map.get(<span class="string">&quot;yupi&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="分布式锁保证定时任务不重复执行"><a href="#分布式锁保证定时任务不重复执行" class="headerlink" title="分布式锁保证定时任务不重复执行"></a>分布式锁保证定时任务不重复执行</h4><p>实现代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testWatchDog</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;yupao:precachejob:docache:lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//只有一个线程获取到锁</span></span><br><span class="line">        <span class="keyword">if</span>(lock.tryLock(<span class="number">0</span>, -<span class="number">1</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">			<span class="comment">// TODO 实际要执行的方法</span></span><br><span class="line">            dosomething();</span><br><span class="line">            System.out.println(<span class="string">&quot;getLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//    只能释放自己的锁</span></span><br><span class="line">        <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;unLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>waitTime 设置为 0，只抢一次，抢不到就放弃</li>
<li>主要释放锁要写在 finally 语句块中，保证最后一定释放锁</li>
</ol>
<h4 id="Redisson-看门狗机制"><a href="#Redisson-看门狗机制" class="headerlink" title="Redisson 看门狗机制"></a>Redisson 看门狗机制</h4><p>Redisson 中提供的续期机制</p>
<p>开一个监听线程，如果方法还没执行完，就帮你重置 Redis 锁的过期时间</p>
<p><strong>原理：</strong></p>
<ol>
<li>监听当前线程，默认过期时间是 30 秒，每 10 秒续期一次（续期到 30 秒）</li>
<li>如果线程挂掉（注意 debug 模式也会被它当成服务器宕机），则不会续期</li>
</ol>
<p>详情参考文档：<a href="https://blog.csdn.net/qq_26222859/article/details/79645203">https://blog.csdn.net/qq_26222859/article/details/79645203</a></p>
]]></content>
      <categories>
        <category>伙伴匹配系统</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库表设计</title>
    <url>/2022/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><h4 id="队伍表-team"><a href="#队伍表-team" class="headerlink" title="队伍表 team"></a>队伍表 team</h4><p>字段：</p>
<ul>
<li>id 主键 bigint （最简单、连续，放 URL 上比较简短，但缺点是爬虫）</li>
<li>name 队伍名称</li>
<li>decription 描述</li>
<li>maxNum 最大人数</li>
<li>expireTime 过期时间</li>
<li>userId 创建人</li>
<li>status 0 - 公开， 1- 私密， 2 - 加密</li>
<li>password 队伍密码</li>
<li>createTime 创建时间</li>
<li>updateTime 更新时间</li>
<li>isDelete 是否删除</li>
</ul>
<h4 id="用户-队伍表-user-team"><a href="#用户-队伍表-user-team" class="headerlink" title="用户-队伍表 user_team"></a>用户-队伍表 user_team</h4><p>关系：</p>
<ol>
<li>用户加入了哪些队伍？</li>
<li>队伍有哪些用户？</li>
</ol>
<p>两种实现方式：</p>
<ol>
<li>建立用户-队伍关系表 teamId userId （便于修改，查询性能高一点，不用全表遍历）</li>
<li>用户表补充已加入的队伍字段，队伍表补充已加入的用户字段（便于查询，不用写多对多连表查询代码，可以直接根据队伍查用户、根据用户查队伍）</li>
</ol>
<p>字段：</p>
<ul>
<li>id 主键</li>
<li>userId 用户 id</li>
<li>teamId 队伍 id</li>
<li>joinTime 加入时间</li>
<li>createTime 创建时间</li>
<li>updateTime 更新时间</li>
<li>isDelete 是否删除</li>
</ul>
<h3 id="为什么需要请求参数包装类？"><a href="#为什么需要请求参数包装类？" class="headerlink" title="为什么需要请求参数包装类？"></a>为什么需要请求参数包装类？</h3><ol>
<li>请求参数名称 &#x2F; 类型和实体类不一样</li>
<li>有一些参数用不到，如果要自动生成接口文档，会增加理解成本（参数太多，冗余）</li>
<li>对个实体类映射到同一个对象</li>
</ol>
<h3 id="为什么需要包装类？"><a href="#为什么需要包装类？" class="headerlink" title="为什么需要包装类？"></a>为什么需要包装类？</h3><ol>
<li>存在有些字段需要隐藏，不能返回给前端，如用户密码</li>
</ol>
]]></content>
      <categories>
        <category>伙伴匹配系统</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 缓存实现-定时任务</title>
    <url>/2022/12/08/%E7%AC%AC%E4%B8%83%E9%9B%86-Redis%20%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="7、Redis-缓存实现-定时任务"><a href="#7、Redis-缓存实现-定时任务" class="headerlink" title="7、Redis 缓存实现-定时任务"></a>7、Redis 缓存实现-定时任务</h1><p>主要内容（后端）：<br>1.缓存和分布式缓存讲解<br>2.Redis介绍(5种数据结构等)<br>3.Java操作Redis的方法(4种方法+对比分析)<br>4.Java Redis Template序列化（包含源码追踪）<br>5.首页缓存开发与注意事项<br>6.缓存预热设计与实现<br>7.定时任务介绍和实现</p>
<h2 id="数据查询慢怎么办？"><a href="#数据查询慢怎么办？" class="headerlink" title="数据查询慢怎么办？"></a>数据查询慢怎么办？</h2><ul>
<li><p>用缓存：提前把数据取出来保存好（通过保存到读写更快的介质，比如内存）</p>
</li>
<li><p>用定时任务：预加载缓存，定时更新缓存</p>
</li>
</ul>
<p>思考：多个机器要执行同一个任务吗？</p>
<p>可以用用分布式锁解决：控制同一时间只有一台机器去执行定时任务，其他机器不用重复执行了</p>
<h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><p>分布式缓存：</p>
<ul>
<li>Redis（分布式缓存）</li>
<li>mencached(分布式)</li>
<li>Etcd （云原生架构的一个分布式存储，<strong>存储配置</strong>，扩容能力）</li>
</ul>
<p>单机缓存：</p>
<ul>
<li>ehcache</li>
<li>Java 内存集合，如 HashMap</li>
<li>Caffeine （Java 内存缓存性能之王，高性能）</li>
<li>Google Guava</li>
</ul>
<h2 id="Redis-缓存实现"><a href="#Redis-缓存实现" class="headerlink" title="Redis 缓存实现"></a>Redis 缓存实现</h2><p>NoSQL 数据库</p>
<p>key-value 存储系统（区别于 MYSQL 它存储的是键值对）</p>
<h3 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h3><p>基本数据结构：</p>
<ul>
<li>String 字符串类型：name:”mofeng”</li>
<li>List 列表：names:[“mofeng”,”dogmofeng”,”lu”]</li>
<li>Set 集合：names:[“mofeng”,”lu”] (值不能重复)</li>
<li>Hash 哈希：nameAge:{“mofeng”:1,”dogLu”:2}</li>
<li>Zset 集合：names[mofeng -9, doglu -12] (适合排行榜)</li>
</ul>
<p>高级：</p>
<ul>
<li>bloomfilter(布隆过滤器，主要从大量的数据中快速过滤值，比如邮件黑名单拦截)</li>
<li>geo(计算地理位置)</li>
<li>hyperloglog(pv&#x2F;uv)</li>
<li>pub&#x2F;sub(发布订阅，类以消息队列)</li>
<li>BitMap(1001010101010101010101010101)</li>
</ul>
<h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><p>为了防止写入 Redis 的数据乱码、浪费空间等，可以自定义序列化器，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.yupao.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTemplateConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-操作-Redis"><a href="#Java-操作-Redis" class="headerlink" title="Java 操作 Redis"></a>Java 操作 Redis</h3><p><strong>Spring Data Redis （推荐）</strong></p>
<p>地址：<a href="https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis">https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis</a></p>
<p>Spring Data：通用的数据访问框架，定义了一组 <strong>增删改查</strong>的接口</p>
<p>还可以操作：mysql、Redis、jpa</p>
<p>使用方式如下：</p>
<p>1）引入 Spring Data Redis 依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.6</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2）配置 Redis 地址</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># redis 配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>独立与 Spring 操作 Redis 的 Java 客户端</p>
<p>要配合 Jedis Pool 使用</p>
<h4 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h4><p><strong>高阶</strong>的操作 Redis 的 Java 客户端</p>
<p>异步、连接池</p>
<h4 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h4><p>分布式操作 Redis 的 Java 客户端，像使用本地集合一样操作 Redis （分布式 Redis 数据网络）</p>
<h4 id="几种库对比"><a href="#几种库对比" class="headerlink" title="几种库对比"></a>几种库对比</h4><ol>
<li>如果项目用的是 Spring，并且没有过多的定制化要求，可以用 Spring Data Redis，最方便</li>
<li>如果项目用的不是 Spring，并且追求简单，并且没有过高的性能要求，可以 Jedis + Jedis Pool</li>
<li>如果项目用的不是 Spring，并且追求高性能、高定制化，可以用 Lettuce ，支持异步、连接池</li>
<li>如果是分布式项目，需要用到一些分布式的特性（比如分布式锁、分布式集合），推荐使用 Redisson</li>
</ol>
<h3 id="设计缓存-key"><a href="#设计缓存-key" class="headerlink" title="设计缓存 key"></a>设计缓存 key</h3><p>关键点：不同用户看到的数据不同</p>
<p>建议格式：</p>
<p>systemId:moduleld:fuc:options (防止其他系统的冲突)</p>
<p>比如：yupao:user:recommend:userId</p>
<p><strong>注意：Redis 内存不能无限增加，一定要设置过期时间！！！</strong></p>
<h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>问题：即使使用了缓存，第一个用户访问还是很慢</p>
<p>缓存预热的优点：</p>
<ol>
<li>解决第一个用户访问很慢，让用户始终快速访问</li>
<li>在一定程度上保护数据库</li>
</ol>
<p>缺点：</p>
<ol>
<li>增加开发成本（额外的开发、设计等）</li>
<li>预热的时机和时间错了，缓存的数据不对或者是未更新的数据</li>
<li>需要占用额外空间</li>
</ol>
<h3 id="怎么缓存预热"><a href="#怎么缓存预热" class="headerlink" title="怎么缓存预热"></a>怎么缓存预热</h3><ol>
<li>定时任务</li>
<li>手动触发</li>
</ol>
<h3 id="实现缓存预热"><a href="#实现缓存预热" class="headerlink" title="实现缓存预热"></a>实现缓存预热</h3><p>用定时任务，每天刷新所有用户的推荐列表</p>
<p>注意点：</p>
<ol>
<li>缓存预热的意义（新增少、总用户多）</li>
<li>缓存的空间不能太大，要预留给其他缓存空间</li>
<li>缓存数据的周期（此处为每天）</li>
</ol>
]]></content>
      <categories>
        <category>伙伴匹配系统</category>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title>组队功能设计</title>
    <url>/2022/12/08/%E7%BB%84%E9%98%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="组队功能"><a href="#组队功能" class="headerlink" title="组队功能"></a>组队功能</h1><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>需要跟自己一起参加竞赛、做项目、学习，可以发起队伍或者加入别人的队伍</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ol>
<li><p>用户可以<strong>创建</strong>队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0<br>队长、剩余的人数</p>
<p>聊天</p>
<p>公开或私密或加密</p>
<p>用户最多创建 5 个队伍</p>
</li>
<li><p>展示队伍列表，根据名称搜索队伍 P0，信息流中不展示已过期的队伍</p>
</li>
<li><p>修改队伍信息  P0~P1</p>
</li>
<li><p>用户可以加入队伍（其他人、未满人、未过期），允许加入多个队伍，但是有上限 P0 </p>
</li>
<li><p>是否需要队长同意？筛选审批？</p>
</li>
<li><p>用户可以退出队伍（如果队长退出，权限转移给第二早加入的用户 – 先来先到）P1</p>
</li>
<li><p>队长可以解散队伍 P0</p>
</li>
<li><p>分享队伍 &#x3D;&gt; 邀请其他用户加入队伍 P1 </p>
<p>业务流程：<br>（1）生成分享连接（分享二维码）<br>（2）用户访问链接，可以点击加入</p>
</li>
</ol>
<p>	</p>
<h3 id="系统（接口）设计"><a href="#系统（接口）设计" class="headerlink" title="系统（接口）设计"></a>系统（接口）设计</h3><h4 id="1-创建队伍"><a href="#1-创建队伍" class="headerlink" title="1.创建队伍"></a>1.创建队伍</h4><p>用户可以<strong>创建</strong>队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0<br>队长、剩余的人数</p>
<p>聊天</p>
<p>公开或私密或加密</p>
<p>用户最多创建 5 个队伍</p>
<ol>
<li>请求参数是否为空</li>
<li>是否登录，为登录不允许创建</li>
<li>校验信息<br>a. 队伍人数 &gt; 1 且 &lt;&#x3D; 20<br>b. 队伍标题小于 20<br>c. 描述 &lt;&#x3D; 512<br>d. status 是否公开（int）不传默认为0（公开）<br>e. 如果 status 是加密状态，一定要有密码，且密码 &lt;&#x3D; 32<br>f. 超时时间 &gt; 当前时间<br>g.校验用户最多创建 5 个队伍</li>
<li>插入队伍信息到队伍表</li>
<li>插入用户 &#x3D;&gt; 队伍关系到关系表</li>
</ol>
<h4 id="2-查询队伍列表"><a href="#2-查询队伍列表" class="headerlink" title="2.查询队伍列表"></a>2.查询队伍列表</h4><p>展示队伍列表，根据名称搜索队伍 P0，信息流中不展示已过期的队伍</p>
<ol>
<li>从请求参数中取出队伍名称等查询条件，如果存在则作为查询条件</li>
<li>不展示已过期的队伍（根据过期时间筛选）</li>
<li>可以通过某个<strong>关键字</strong>同时对名称和描述查询</li>
<li><strong>只有管理员才能查看加密还有非公开的队伍</strong></li>
<li>关联查询已加入队伍的用户信息</li>
<li><strong>关联查询已加入队伍的用户信息（可能耗费性能，建议用 SQL 实现）</strong></li>
</ol>
<p>实现方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询队伍和创建人信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> team t <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> t.userId <span class="operator">=</span> u.id</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询队伍和已加入队伍成员的信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> team t</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> user_team ut <span class="keyword">on</span> t.id <span class="operator">=</span> ut.teamId</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> ut.userId <span class="operator">=</span> u.id</span><br></pre></td></tr></table></figure>



<h4 id="3-修改队伍信息"><a href="#3-修改队伍信息" class="headerlink" title="3.修改队伍信息"></a>3.修改队伍信息</h4><ol>
<li>判断请求参数是否为空</li>
<li>查询队伍是否存在</li>
<li>只有管理员或者队伍的创建者可以修改</li>
<li>如果传入的新值和老值一致，则不需要 update （降低数据库使用次数）</li>
<li><strong>如果队伍状态为加密，修改时必须带密码</strong></li>
<li>更新队伍信息</li>
</ol>
<h4 id="4-用户可以加入队伍"><a href="#4-用户可以加入队伍" class="headerlink" title="4.用户可以加入队伍"></a>4.用户可以加入队伍</h4><p>其他人、队伍未满、未过期、允许加入过个队伍，但是有上线 P0</p>
<ol>
<li>用户最多加入 5 个队伍</li>
<li>队伍必须存在，只能加入未满员、未过期的队伍</li>
<li>不能加入自己的队伍，不能重复加入已加入的队伍（幂等性）</li>
<li>禁止加入私有的队伍</li>
<li>如果加入的队伍是加密的，需要匹配密码</li>
<li>修改队伍信息，补充人数</li>
<li>新增队伍-用户关联信息</li>
</ol>
<p><strong>注意，加上事务注解 @Trancational</strong></p>
<h4 id="5-用户退出队伍"><a href="#5-用户退出队伍" class="headerlink" title="5.用户退出队伍"></a>5.用户退出队伍</h4><p>请求参数：队伍 id</p>
<ol>
<li>校验请求参数</li>
<li>校验队伍是否存在</li>
<li>校验我是否已加入队伍</li>
<li>如果队伍<ol>
<li>只剩下一人，解散队伍</li>
<li>如果是队长退出，权限转移给第二个人（根据 JoinTime)</li>
<li>非队长，自己退出队伍，队伍人数 -1</li>
</ol>
</li>
</ol>
<h4 id="6-队长解散队伍"><a href="#6-队长解散队伍" class="headerlink" title="6.队长解散队伍"></a>6.队长解散队伍</h4><p>请求参数：队伍 id</p>
<ol>
<li>校验请求参数</li>
<li>校验队伍是否存在</li>
<li>校验是否为队长</li>
<li>移除所有加入队伍的关联信息</li>
<li>删除队伍</li>
</ol>
<p><strong>注意：一定要加上事务注解！</strong></p>
<h4 id="7-获取当前用户已加入的队伍"><a href="#7-获取当前用户已加入的队伍" class="headerlink" title="7.获取当前用户已加入的队伍"></a>7.获取当前用户已加入的队伍</h4><h4 id="8-获取当前用户创建的队伍"><a href="#8-获取当前用户创建的队伍" class="headerlink" title="8.获取当前用户创建的队伍"></a>8.获取当前用户创建的队伍</h4><p>复用 listTeam 方法，只新增查询条件，不做修改（开闭原则）</p>
<h3 id="使用事务注解"><a href="#使用事务注解" class="headerlink" title="使用事务注解"></a>使用事务注解</h3><p>@Trancational(rollbackFor &#x3D; Exception.class)</p>
]]></content>
      <categories>
        <category>伙伴匹配系统</category>
      </categories>
  </entry>
  <entry>
    <title>GateWay 转发请求</title>
    <url>/2022/12/22/GateWay-%E8%BD%AC%E5%8F%91%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h1 id="五、Gateway-转发请求"><a href="#五、Gateway-转发请求" class="headerlink" title="五、Gateway 转发请求"></a>五、Gateway 转发请求</h1><h2 id="使用到的特性"><a href="#使用到的特性" class="headerlink" title="使用到的特性"></a>使用到的特性</h2><ol>
<li>路由</li>
<li><del>负载均衡（需要用到注册中心）</del></li>
<li>统一鉴权</li>
<li><del>跨域</del></li>
<li>统一业务处理（缓存）</li>
<li>访问控制</li>
<li><del>发布控制</del></li>
<li>流量染色</li>
<li><del>接口保护</del><ol>
<li>限制请求</li>
<li>信息脱敏</li>
<li>降级（熔断）</li>
<li>限流：学习令牌桶算法、学习漏桶算法，学习一下 RedisLimitHandler</li>
<li>超时时间</li>
</ol>
</li>
<li>统一日志</li>
<li><del>统一文档</del></li>
</ol>
<h2 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h2><ol>
<li>用户发送请求到 API 网关</li>
<li>请求日志</li>
<li>（黑白名单）</li>
<li>用户鉴权（判断 accessKey, secretKey 是否合法）</li>
<li>请求的模拟接口是否存在</li>
<li><strong>请求转发，调用模拟接口</strong></li>
<li>响应日志</li>
<li>调用成功，次数 + 1</li>
<li>调用失败，返回一个规范的错误码</li>
</ol>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="1-请求转发"><a href="#1-请求转发" class="headerlink" title="1.请求转发"></a>1.请求转发</h3><p>使用前缀匹配断言：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-path-route-predicate-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-path-route-predicate-factory</a></p>
<p>所有路径为： &#x2F;api&#x2F;** 的请求进行转发，转发到 <a href="http://localhost:8123/api/">http://localhost:8123/api/</a>**</p>
<p>比如请求网关： <a href="http://localhost:8090/api/name/get/?name=mofeng">http://localhost:8090/api/name/get/?name=mofeng</a></p>
<p>转发到：<a href="http://localhost:8123/api/name/get/?name=mofeng">http://localhost:8123/api/name/get/?name=mofeng</a></p>
<p>配置文件添加内容， application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">api_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8123</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/api/**</span></span><br></pre></td></tr></table></figure>

<h3 id="2-编写业务逻辑"><a href="#2-编写业务逻辑" class="headerlink" title="2.编写业务逻辑"></a>2.编写业务逻辑</h3><p>使用了 GlobalFilter （编程式），全局请求拦截处理（类似 AOP）</p>
<p>因为网关项目没引入 MyBatis 等操作数据库的类库，如果该操作较为复杂，可以有 backend 增删改查项目提供接口，直接调用，不需要重复写逻辑。</p>
<ul>
<li>HTTP 请求（HTTPClient、 用 RestTemplate、 Feign）</li>
<li>RPC（Dubbo)</li>
</ul>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>预期等模拟接口调用完成，才记录响应日志、统计调用次数</p>
<p>但现实是 chain.filter 方法立即返回了，知道 filter 过滤器 return 后才调用模拟接口</p>
<p>原因是：chain.filter 是一个异步操作，理解为前端的 promise</p>
<p>解决方案：利用 response 装饰者，增强原有 response 的处理能力</p>
<p>参考博客：<a href="https://blog.csdn.net/qq_19636353/article/details/126759522">https://blog.csdn.net/qq_19636353/article/details/126759522</a></p>
<p>其他参考：</p>
<p><a href="https://blog.csdn.net/zx156955/article/details/121670681">https://blog.csdn.net/zx156955/article/details/121670681</a></p>
<p><a href="https://blog.csdn.net/weixin_43933728/article/details/121359727?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_43933728/article/details/121359727?spm=1001.2014.3001.5501</a></p>
<p><a href="https://blog.csdn.net/qq_39529562/article/details/108911983">https://blog.csdn.net/qq_39529562/article/details/108911983</a></p>
]]></content>
      <categories>
        <category>API 开放平台</category>
      </categories>
      <tags>
        <tag>星球项目</tag>
      </tags>
  </entry>
  <entry>
    <title>API 开放平台设计</title>
    <url>/2022/12/22/%E4%B8%80%E3%80%81API%20%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="API-开放平台"><a href="#API-开放平台" class="headerlink" title="API 开放平台"></a>API 开放平台</h1><h2 id="第一期"><a href="#第一期" class="headerlink" title="第一期"></a>第一期</h2><p>项目背景：</p>
<ol>
<li>前端开发需要用到后端接口</li>
<li>使用现成的系统的功能（<a href="http://api.btstu.cn/%EF%BC%89">http://api.btstu.cn/）</a></li>
</ol>
<p>API 接口平台：</p>
<ol>
<li>防止攻击（安全性）</li>
<li>不能随便调用（限制、开通）</li>
<li><strong>统计调用次数</strong></li>
<li>计费</li>
<li>流量保护</li>
<li>API 接口</li>
</ol>
<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>做一个提供 API 接口调用的平台，用户可以注册登录，开通接口调用权限，用户可以使用接口，并且每次调用会进行统计。管理员可以发布接口、下线接口、接入接口，以及可视化接口的调用情况、数据。</p>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul>
<li>Ant Design Pro</li>
<li>React</li>
<li>Ant Design Procompoments</li>
<li>Umi</li>
<li>Umi Request (Axios 的封装)</li>
</ul>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul>
<li>Java Spring Boot</li>
<li>Sring Boot Starter （SDK 开发）</li>
</ul>
<h2 id="项目计划"><a href="#项目计划" class="headerlink" title="项目计划"></a>项目计划</h2><h3 id="第一期-—-初始化展示"><a href="#第一期-—-初始化展示" class="headerlink" title="第一期 —- 初始化展示"></a>第一期 —- 初始化展示</h3><p>项目介绍、设计、技术选型</p>
<p>基础项目搭建</p>
<p>接口管理</p>
<p>用户查看接口</p>
<h3 id="第二期-—-接口调用"><a href="#第二期-—-接口调用" class="headerlink" title="第二期 —- 接口调用"></a>第二期 —- 接口调用</h3><ol>
<li>继续开发接口管理前端页面</li>
<li>开发调用这个接口的代码</li>
<li>保证调用的安全性<strong>（API 签名认证）</strong></li>
<li>客户端 SDK  的开发</li>
<li>管理员接口 <strong>发布</strong> 与调用</li>
<li>接口文档展示、接口在线调用</li>
</ol>
<h3 id="第三期-—–-接口计费与保护"><a href="#第三期-—–-接口计费与保护" class="headerlink" title="第三期 —– 接口计费与保护"></a>第三期 —– 接口计费与保护</h3><p>统计用户调用接口次数</p>
<p>限流</p>
<p>计费</p>
<p>日志</p>
<p>开通</p>
<h3 id="第四期-—-管理、统计分析"><a href="#第四期-—-管理、统计分析" class="headerlink" title="第四期 —- 管理、统计分析"></a>第四期 —- 管理、统计分析</h3><p>提供可视化平台，用图表的方展示所有接口的调用情况，便于调整业务</p>
<p><strong>实现预警</strong></p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol>
<li>管理员可以对接口信息进行增删改查</li>
<li>用户可以访问前台，查看接口信息</li>
</ol>
<h2 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h2><h3 id="接口信息表"><a href="#接口信息表" class="headerlink" title="接口信息表"></a>接口信息表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 接口信息表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> mofeng.`interface_info`</span><br><span class="line">(</span><br><span class="line">    `id` <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;主键&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">    `description` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">null</span> comment <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">    `url` <span class="type">varchar</span>(<span class="number">512</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;接口地址&#x27;</span>,</span><br><span class="line">    `requestHeader` text <span class="keyword">null</span> comment <span class="string">&#x27;请求头&#x27;</span>,</span><br><span class="line">    `responseHeader` text <span class="keyword">null</span> comment <span class="string">&#x27;响应头&#x27;</span>,</span><br><span class="line">    `userId` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">    `status` <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;接口状态（0 - 关闭， 1 - 开启））&#x27;</span>,</span><br><span class="line">    `<span class="keyword">method</span>` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;请求类型&#x27;</span>,</span><br><span class="line">    `createTime` datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    `updateTime` datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    `isDelete` tinyint <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;是否删除(0-未删, 1-已删)&#x27;</span></span><br><span class="line">    ) comment <span class="string">&#x27;接口信息表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="项目脚手架"><a href="#项目脚手架" class="headerlink" title="项目脚手架"></a>项目脚手架</h2><p>前端：Ant Design Pro 脚手架</p>
<p>后端：Spring Boot 通用模板</p>
<h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><p>增删改查、登录（复制、粘贴）</p>
<p>前端接口调用：oneapi 插件自动生成</p>
<p>openapi  的规范</p>
]]></content>
      <categories>
        <category>API 开放平台</category>
      </categories>
      <tags>
        <tag>星球项目</tag>
      </tags>
  </entry>
  <entry>
    <title>二、API 开放平台-模拟接口</title>
    <url>/2022/12/22/%E4%BA%8C%E3%80%81API%20%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E6%A8%A1%E6%8B%9F%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="二、API-开放平台-模拟接口"><a href="#二、API-开放平台-模拟接口" class="headerlink" title="二、API 开放平台-模拟接口"></a>二、API 开放平台-模拟接口</h1><h2 id="模拟接口项目-mofeng-interface"><a href="#模拟接口项目-mofeng-interface" class="headerlink" title="模拟接口项目 mofeng-interface"></a>模拟接口项目 mofeng-interface</h2><p>提供三个模拟接口</p>
<ol>
<li>GET 接口</li>
<li>POST 接口（URL 传参）</li>
<li>POST 接口 （Restful)</li>
</ol>
<h3 id="调用接口"><a href="#调用接口" class="headerlink" title="调用接口"></a>调用接口</h3><p>几种 HTTP 调用方式：</p>
<ol>
<li>HttpClient</li>
<li>RestTemplate</li>
<li>第三方库（OKHTTP、Hutool)</li>
</ol>
<p>Hutool:<a href="https://hutool.cn/docs/#/">https://hutool.cn/docs/#/</a></p>
<p>Http 工具类：<a href="https://hutool.cn/docs/#/http/Http%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E5%85%B7%E7%B1%BB-HttpUtil">https://hutool.cn/docs/#/http/Http%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E5%85%B7%E7%B1%BB-HttpUtil</a></p>
<h3 id="API-签名认证"><a href="#API-签名认证" class="headerlink" title="API 签名认证"></a>API 签名认证</h3><p>本质：</p>
<ol>
<li>签名签发</li>
<li>使用签名（校验签名）</li>
</ol>
<p>为什么需要签名认证？</p>
<p>保证安全性，防止恶意调用</p>
<h3 id="如何实现-API-签名认证呢？"><a href="#如何实现-API-签名认证呢？" class="headerlink" title="如何实现 API 签名认证呢？"></a>如何实现 API 签名认证呢？</h3><p>通过 http request header 头传递参数</p>
<ul>
<li><p>参数1： accessKey 调用的标识 userA, userB (复杂、无序、无规律)</p>
</li>
<li><p>参数2： secretKey 密钥 （复杂、无序、无规律），<strong>该参数不能放在请求头中</strong></p>
<p>类似于用户名和密码，区别：accessKey、 secretKey 是无状态的</p>
<p>密钥一般不用在服务器之间的传递，因为在传递过程中可能被拦截</p>
</li>
<li><p>参数3： 用户请求参数</p>
</li>
<li><p>参数4： sign</p>
</li>
<li><p>参数5：加 none 随机数， 只能用一次（服务端要保存用过的随机数）</p>
</li>
<li><p>参数6： 加 timestamp 时间戳， 校验时间戳是否过期</p>
</li>
</ul>
<p>加密方式：对称加密、非对称加密、md5 签名（不可解密）</p>
<p>用户参数 + 密钥 &#x3D;&gt; <strong>签名生成算法(MD5、Hmac、Sha1)</strong> &#x3D;&gt; 不可解密的值</p>
<p>如：abc + abcdefgh &#x3D;&gt; sfasfafffsfsa</p>
<p>如何验证签名？</p>
<p><strong>服务端用一模一样的参数和算法去生成签名，只要和用户传的一致，就表示一致。</strong></p>
<p>如果防止重放？</p>
<p><strong>服务端要保存用过的随机数</strong></p>
<p><strong>API 签名认证是一个很灵活的设计，具体要有哪个参数、参数名如何需要根据场景来设计。比如： userId、 appId、version、固定值等</strong></p>
<h2 id="开发一个简单易用的-SDK"><a href="#开发一个简单易用的-SDK" class="headerlink" title="开发一个简单易用的 SDK"></a>开发一个简单易用的 SDK</h2><p>理想状态下：开发者只需要关心调用哪些接口、传递哪些参数、就跟调用自己写的代码一样。</p>
<p>开发 starter 的好处：开发者引入后，可以直接在 application.yml 中写配置，自动创建客户端</p>
<p><strong>spring-boot-configuration-processor 的作用是自动生成配置的代码提示</strong></p>
<h3 id="starter-的开发流程"><a href="#starter-的开发流程" class="headerlink" title="starter 的开发流程"></a>starter 的开发流程</h3><p>初始化，环境依赖（一定要移除 build）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">   &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">   &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>编写配置类（启动类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 能读取 application 中的配置属性</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;mofeng.client&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MofengClientConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MofengApiClient <span class="title function_">mofengApiClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MofengApiClient</span>(accessKey, secretKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册配置类</p>
<p>resources&#x2F;META_INF&#x2F;spring.factories</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># starter</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.mofeng.mofengclientsdk.MofengClientConfig</span><br></pre></td></tr></table></figure>

<p>mvn install 打包为本地项目</p>
<p>创建新项目（复用 server 项目）、测试</p>
]]></content>
      <categories>
        <category>API 开放平台</category>
      </categories>
      <tags>
        <tag>星球项目</tag>
      </tags>
  </entry>
  <entry>
    <title>创建 starter 步骤</title>
    <url>/2022/12/22/%E5%88%9B%E5%BB%BAstarter%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h1 id="创建starter步骤"><a href="#创建starter步骤" class="headerlink" title="创建starter步骤"></a>创建starter步骤</h1><p>1.新建一个 spring boot 初始化项目<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230811084.png" alt="image-20221123081123307"></p>
<p>2.添加依赖，Lombok, Spring Configuration Processor</p>
<p>Spring Configuration Processor 的作用是自动生成代码提示<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230812657.png" alt="image-20221123081227014"></p>
<p>3.修改 pom 文件的版本号，并删除 build<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230816110.png" alt="image-20221123081554107"></p>
<p>​		<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230817635.png" alt="image-20221123081718280"></p>
<p>4.删除原本自动创建的主类，新建一个类, 并添加需要用到的依赖</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230823121.png" alt="image-20221123082308530"></p>
<p>5.在 resources 目录下新建 META-INF 目录，并创建 spring.factories 文件，并指定配置类的目录</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230828618.png" alt="image-20221123082817937"></p>
<p>6.install 打包构建在本地的仓库</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230831488.png" alt="image-20221123083107829"></p>
<p>7.复制 groupId, artifactId, version,可以在其他项目中添加为依赖</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230833985.png" alt="image-20221123083345988"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230834598.png" alt="image-20221123083425190"></p>
<p>8.在配置文件当中就可以引用 starter 当中设置的属性</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230836055.png" alt="image-20221123083608433"></p>
<p>刚才在 starter 配置类中定义的属性</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230838324.png" alt="image-20221123083825791"></p>
<p>可以引入 starter 当中的类或者属性</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230839280.png" alt="image-20221123083950711"></p>
]]></content>
      <categories>
        <category>API 开放平台</category>
      </categories>
      <tags>
        <tag>星球项目</tag>
      </tags>
  </entry>
  <entry>
    <title>API 开放平台四-网关</title>
    <url>/2022/12/22/%E5%9B%9B%E3%80%81API-%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<h1 id="四、网关"><a href="#四、网关" class="headerlink" title="四、网关"></a>四、网关</h1><ol>
<li>开发接口调用次数的设计</li>
<li>优化整个系统的架构（API 网关）<ol>
<li>网关是什么？</li>
<li>网关的作用</li>
<li>网关的应用场景及实现</li>
<li>结合业务应用网关</li>
</ol>
</li>
</ol>
<h2 id="接口调用次数统计"><a href="#接口调用次数统计" class="headerlink" title="接口调用次数统计"></a>接口调用次数统计</h2><p>需求：</p>
<ol>
<li><strong>用户每次调用接口成功，次数 + 1</strong></li>
<li>给用户分配或者用户自主申请接口调用次数</li>
</ol>
<p>业务流程：</p>
<ol>
<li>用户调用接口</li>
<li>修改数据库，调用次数 + 1</li>
</ol>
<p>设计库表：</p>
<p>哪个用户？哪个接口？</p>
<p>用户 &#x3D;&gt; 接口 （多对多关系）</p>
<p>用户调用接口关系表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 用户调用接口关系表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> user_interface_info</span><br><span class="line">(</span><br><span class="line">    id            <span class="type">bigint</span> auto_increment comment <span class="string">&#x27;id&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">    userId        <span class="type">bigint</span>  comment <span class="string">&#x27;调用用户 id&#x27;</span>,</span><br><span class="line">    interfaceInfoId        <span class="type">bigint</span>  comment <span class="string">&#x27;接口 id&#x27;</span>,</span><br><span class="line">    totalNum       <span class="type">int</span>     <span class="keyword">default</span> <span class="number">0</span> comment <span class="string">&#x27;总调用次数&#x27;</span>,</span><br><span class="line">    leftNum       <span class="type">int</span>     <span class="keyword">default</span> <span class="number">0</span> comment <span class="string">&#x27;剩余调用次数&#x27;</span>,</span><br><span class="line">    status       <span class="type">int</span>     <span class="keyword">default</span> <span class="number">0</span> comment <span class="string">&#x27;0-正常， 1-禁用&#x27;</span>,</span><br><span class="line">    createTime    datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    updateTime    datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    isDelete      tinyint  <span class="keyword">default</span> <span class="number">0</span>                 <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;是否删除&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;用户调用接口关系表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<ol>
<li>开发基本的增删改查（给管理员用）</li>
<li>开发用户调用接口次数 + 1 的功能（service）</li>
</ol>
<p>问题：</p>
<p>如果每个接口的方法都写调用次数 + 1， 过于麻烦</p>
<p>致命问题：接口开发者需要自己去添加统计代码</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221204192719518.png" alt="image-20221204192719518"></p>
<p>使用 AOP 切面的优点：独立于接口，在每个接口调用后次数 + 1</p>
<p>AOP 切面的缺点：只存在单个项目中，如果每个团队都要开发自己的模拟接口，那么都要写一个切面</p>
<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><h3 id="网关的作用"><a href="#网关的作用" class="headerlink" title="网关的作用"></a>网关的作用</h3><ol>
<li>路由</li>
<li>负载均衡</li>
<li>统一鉴权</li>
<li>跨域</li>
<li>统一业务处理（缓存）</li>
<li>访问控制</li>
<li>发布控制</li>
<li>流量染色</li>
<li>接口保护<ol>
<li>限制请求</li>
<li>信息脱敏</li>
<li>降级（熔断）</li>
<li>限流：学习令牌桶算法、学习漏桶算法，学习一下 RedisLimitHandler</li>
<li>超时时间</li>
</ol>
</li>
<li>统一日志</li>
<li>统一文档</li>
</ol>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>起到转发的作用，比如有接口 A 和接口 B， 网关会记录这些信息，根据用户访问的地址和参数，转发请求到对应的接口（服务器&#x2F;集群）</p>
<p>&#x2F;a &#x3D;&gt; 接口 A</p>
<p>&#x2F;b &#x3D;&gt; 接口 B</p>
<p>Gateway 路由：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories</a></p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>在路由的基础上</p>
<p>&#x2F;c &#x3D;&gt; 服务 A &#x2F; 集群 A （随机转发到其中的某一个机器）</p>
<p>uri 从固定地址改成 lb:xxxx</p>
<h3 id="统一处理跨域"><a href="#统一处理跨域" class="headerlink" title="统一处理跨域"></a>统一处理跨域</h3><p>网关统一处理跨域，不用在每个项目里单独处理</p>
<p>GateWay 处理跨域：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#cors-configuration">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#cors-configuration</a></p>
<h3 id="发布控制"><a href="#发布控制" class="headerlink" title="发布控制"></a>发布控制</h3><p>灰度发布，比如上线新接口，先给新接口分配 20% 的流量，老接口 80%， 再慢慢调整比例</p>
<p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-weight-route-predicate-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-weight-route-predicate-factory</a></p>
<h3 id="流量染色"><a href="#流量染色" class="headerlink" title="流量染色"></a>流量染色</h3><p>给请求（流量）添加一些标识，一般是设置请求头中，添加新的请求头</p>
<p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-addrequestheader-gatewayfilter-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-addrequestheader-gatewayfilter-factory</a></p>
<p>全局染色：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#default-filters">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#default-filters</a></p>
<h3 id="统一接口保护"><a href="#统一接口保护" class="headerlink" title="统一接口保护"></a>统一接口保护</h3><ol>
<li>限制请求：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#requestheadersize-gatewayfilter-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#requestheadersize-gatewayfilter-factory</a></li>
<li>信息脱敏：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-removerequestheader-gatewayfilter-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-removerequestheader-gatewayfilter-factory</a></li>
<li>降级（熔断）：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#fallback-headers">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#fallback-headers</a></li>
<li>限流：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-requestratelimiter-gatewayfilter-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-requestratelimiter-gatewayfilter-factory</a></li>
<li>超时时间：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#http-timeouts-configuration">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#http-timeouts-configuration</a></li>
<li>重试（业务保护）：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-retry-gatewayfilter-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-retry-gatewayfilter-factory</a></li>
</ol>
<h3 id="统一业务处理"><a href="#统一业务处理" class="headerlink" title="统一业务处理"></a>统一业务处理</h3><p>把每个项目中都要做的通用逻辑放到上层（网关），统一处理，比如本项目的次数统计</p>
<h3 id="统一鉴权"><a href="#统一鉴权" class="headerlink" title="统一鉴权"></a>统一鉴权</h3><p>判断用户是否有权限进行操作，无论访问什么接口，都统一验证权限，避免重复写验证权限操作。</p>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>黑白名单，比如限制 DDOS IP</p>
<h3 id="统一日志"><a href="#统一日志" class="headerlink" title="统一日志"></a>统一日志</h3><p>统一的请求、响应信息记录</p>
<h3 id="统一文档"><a href="#统一文档" class="headerlink" title="统一文档"></a>统一文档</h3><p>将下游项目的文档进行聚合，在一个页面统一查看</p>
<p>可以使用 knife4j : <a href="https://doc.xiaominfo.com/docs/middleware-sources/aggregation-introduction">https://doc.xiaominfo.com/docs/middleware-sources/aggregation-introduction</a></p>
<h2 id="网关的分类"><a href="#网关的分类" class="headerlink" title="网关的分类"></a>网关的分类</h2><ol>
<li>全局网关（接入层网关）： 作用是负载均衡、请求日志等，不和业务逻辑绑定</li>
<li>业务网关（微服务网关）： 存在一些业务逻辑，作用是将请求转发到不同的业务&#x2F;项目&#x2F;接口&#x2F;服务</li>
</ol>
<p>参考文章：<a href="https://blog.csdn.net/qq_21040559/article/details/122961395">https://blog.csdn.net/qq_21040559/article/details/122961395</a></p>
<h2 id="实现网关"><a href="#实现网关" class="headerlink" title="实现网关"></a>实现网关</h2><ol>
<li>Nginx （全局网关）、Kong 网关 （API 网关， Kong: <a href="https://github.com/Kong/kong">https://github.com/Kong/kong</a>), 编程成本相对高点</li>
<li>Spring Cloud GateWay (取代了 Zuul ) , 性能高、可以用 Java 代码来写逻辑，适合学习</li>
</ol>
<p>网关的技术选型：<a href="https://zhuanlan.zhihu.com/p/500587132">https://zhuanlan.zhihu.com/p/500587132</a></p>
<h2 id="Spring-Cloud-GateWay-用法"><a href="#Spring-Cloud-GateWay-用法" class="headerlink" title="Spring Cloud GateWay 用法"></a>Spring Cloud GateWay 用法</h2><p>官网：<a href="https://spring.io/projects/spring-cloud-gateway/">https://spring.io/projects/spring-cloud-gateway/</a></p>
<p>官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/</a></p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>路由（根据什么条件，转发到哪里去）</p>
<p>断言：一组规则、条件， 用来确定如何转发路由</p>
<p>过滤器： 对请求进行一系列的处理， 比如添加请求头、添加请求参数</p>
<p>请求流程：</p>
<ol>
<li>客户端发起请求</li>
<li>Handler Mapping: 根据断言，将请求转发到对应的路由</li>
<li>Web Handler： 处理请求（一层层经过过滤器）</li>
<li>实际调用服务</li>
</ol>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221204202459676.png" alt="image-20221204202459676"></p>
<h3 id="两种配置方式"><a href="#两种配置方式" class="headerlink" title="两种配置方式"></a>两种配置方式</h3><ol>
<li>配置式（方便、规范）<ol>
<li>简化版</li>
<li>全称版</li>
</ol>
</li>
<li>编程式（灵活、相对麻烦）</li>
</ol>
<h3 id="开启日志"><a href="#开启日志" class="headerlink" title="开启日志"></a>开启日志</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org:</span></span><br><span class="line">      <span class="attr">springframework:</span></span><br><span class="line">        <span class="attr">cloud:</span></span><br><span class="line">          <span class="attr">gateway:</span> <span class="string">trace</span></span><br></pre></td></tr></table></figure>

<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><ol>
<li>After 在 xx 时间之后</li>
<li>Before 在 xx 时间之前</li>
<li>Between 在 xx 时间之间</li>
<li>请求类别</li>
<li>请求头（包含 cookie）</li>
<li>查询参数</li>
<li>客户端地址</li>
<li><strong>权重</strong></li>
</ol>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>基本功能：对请求头、请求参数、响应头的增删改查</p>
<ol>
<li>添加请求头</li>
<li>添加请求参数</li>
<li>添加响应头</li>
<li>降级</li>
<li>限流</li>
<li>重试</li>
</ol>
<p>引入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-circuitbreaker-reactor-resilience4j&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>API 开放平台</category>
      </categories>
      <tags>
        <tag>星球项目</tag>
      </tags>
  </entry>
  <entry>
    <title>三、API 开放平台-接口发布</title>
    <url>/2022/12/22/%E4%B8%89%E3%80%81API%20%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E6%8E%A5%E5%8F%A3%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<h1 id="三、接口发布-下线-调用"><a href="#三、接口发布-下线-调用" class="headerlink" title="三、接口发布-下线-调用"></a>三、接口发布-下线-调用</h1><ol>
<li>开发接口发布、下线的功能（管理员）</li>
<li>前端去浏览接口、查看接口文档、申请签名（注册）</li>
<li>在线调试（用户）</li>
<li>统计用户调用接口的次数</li>
<li>优化系统 - API 网关</li>
</ol>
<h2 id="开发接口发布-x2F-下线功能"><a href="#开发接口发布-x2F-下线功能" class="headerlink" title="开发接口发布&#x2F;下线功能"></a>开发接口发布&#x2F;下线功能</h2><p>后台接口：</p>
<p>发布接口（仅管理员可操作）</p>
<ol>
<li>校验该接口是否存在</li>
<li>判断该接口是否可以调用</li>
<li>修改接口数据库中的状态字段为 1</li>
</ol>
<p>下线接口（仅管理员可操作）</p>
<ol>
<li>校验接口是否存在</li>
<li>修改接口数据库中的状态字段为 0</li>
</ol>
<h2 id="查看接口文档"><a href="#查看接口文档" class="headerlink" title="查看接口文档"></a>查看接口文档</h2><p>动态路由，用 url 来传递 id, 加载不同的接口信息</p>
<h2 id="申请签名"><a href="#申请签名" class="headerlink" title="申请签名"></a>申请签名</h2><p>用户在注册成功时，自动分配 accessKey、secretKey </p>
<p>扩展点：用户可以申请更换签名</p>
<h2 id="在线调用"><a href="#在线调用" class="headerlink" title="在线调用"></a>在线调用</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;username&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;string&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>先跑通整个接口流程，再去针对不同的请求头或者接口类型来设计界面和表单，给用户更好的体验。（可以参考 swagger、postman、knife4j)</p>
<h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202212041910410.png" alt="image-20221204191022426"></p>
<p>流程：</p>
<ol>
<li>前端将用户输入的请求参数和要测试的接口 id 发给平台后端</li>
<li>在调用前可以做一些校验</li>
<li>平台后端去调用模拟接口</li>
</ol>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>判断该接口是否可以调用时有固定方法名改为根据测试地址来调用</li>
<li>用户测试接口固定方法名改为根据测试地址来调用</li>
<li>模拟接口改为从数据库校验 accessKey</li>
</ul>
]]></content>
      <categories>
        <category>API 开放平台</category>
      </categories>
      <tags>
        <tag>星球项目</tag>
      </tags>
  </entry>
  <entry>
    <title>六、Dubbo 框架</title>
    <url>/2023/01/03/%E5%85%AD%E3%80%81Dubbo-%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="六、Dubbo-框架"><a href="#六、Dubbo-框架" class="headerlink" title="六、Dubbo 框架"></a>六、Dubbo 框架</h1><h2 id="网关业务逻辑"><a href="#网关业务逻辑" class="headerlink" title="网关业务逻辑"></a>网关业务逻辑</h2><p>问题：网关项目比较纯净，没有操作数据库的包、并且还要调用我们之前写过的代码？复制粘贴维护麻烦</p>
<p>解决：直接请求到其他项目的方法</p>
<h3 id="如何调用其他项目的方法"><a href="#如何调用其他项目的方法" class="headerlink" title="如何调用其他项目的方法"></a>如何调用其他项目的方法</h3><ol>
<li>复制代码、依赖和环境</li>
<li>HTTP 请求（提供一个接口，供其他项目使用）</li>
<li>RPC</li>
<li>把公共的代码打包 JAR 包，其他项目引用（客户端 SDK）</li>
</ol>
<h3 id="HTTP-请求如何调用？"><a href="#HTTP-请求如何调用？" class="headerlink" title="HTTP 请求如何调用？"></a>HTTP 请求如何调用？</h3><ol>
<li>提供开发一个接口（地址、请求方法、参数、返回值）</li>
<li>调用方使用 HTTP Client 之类的代码包去发送 HTTP 请求</li>
</ol>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p><strong>作用：像本地方法一样调用远程方法</strong></p>
<ol>
<li>对开发者更透明，减少了很多的沟通 成本</li>
<li>RPC 想远程服务器发送请求时，未必要使用 HTTP 请求，比如还可以用 TCP&#x2F;IP，性能更高（内部服务更适用）</li>
</ol>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202212272020718.png" alt="image-20221227202039865"></p>
<h3 id="Dubbo-框架（RPC-实现）"><a href="#Dubbo-框架（RPC-实现）" class="headerlink" title="Dubbo 框架（RPC 实现）"></a>Dubbo 框架（RPC 实现）</h3><p>GRPC、TRPC</p>
<p>阅读官方文档：<a href="https://cn.dubbo.apache.org/zh/docs3-v2/java-sdk/quick-start/spring-boot/">https://cn.dubbo.apache.org/zh/docs3-v2/java-sdk/quick-start/spring-boot/</a></p>
<p>两种使用方式：</p>
<ol>
<li>Spring Boot 代码（注解 + 编程式）：写 Java 接口，服务提供者和消费者都去引用这个接口</li>
<li>IDL（接口调用语言）：创建一个公共的接口定义文件，服务提供者和消费者都去读取这个文件。优点是跨语言，所有的框架都熟悉。</li>
</ol>
<p>底层是 Triple 协议：<a href="https://cn.dubbo.apache.org/zh/docs3-v2/java-sdk/concepts-and-architecture/triple/">https://cn.dubbo.apache.org/zh/docs3-v2/java-sdk/concepts-and-architecture/triple/</a></p>
<h4 id="示例学习"><a href="#示例学习" class="headerlink" title="示例学习"></a>示例学习</h4><p>zookeeper 注册中心：通过内嵌的方式运行，更方便</p>
<p>最先启动注册中心，先启动服务提供者，在启动服务消费者</p>
<h3 id="整合运用"><a href="#整合运用" class="headerlink" title="整合运用"></a>整合运用</h3><ol>
<li>backend 项目作为服务提供者，提供 3 个方法：<ol>
<li>实际情况应该是去数据库中查是否已分配给用户</li>
<li>从数据库中查询模拟接口是否存在，以及请求方法是否匹配（还可以校验请求参数）</li>
<li>调用成功，接口调用次数 + 1 invokeCount</li>
</ol>
</li>
<li>gateway 项目作为服务调用者，调用这 3 个方法</li>
</ol>
<p>整合 Nacos 注册中心：<a href="https://cn.dubbo.apache.org/zh/docs3-v2/java-sdk/reference-manual/registry/nacos/">https://cn.dubbo.apache.org/zh/docs3-v2/java-sdk/reference-manual/registry/nacos/</a></p>
<p>注意：</p>
<ol>
<li>服务调用类必须在同一包下，建议是抽象出一个公共项目（放接口、实体类等）</li>
<li>设置注解（比如启动类的 EnableDubbo、接口实现类和 Bean 引用的注解）</li>
<li>添加配置</li>
<li>服务调用项目和提供者项目尽量引入相同的依赖和配置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.apache.dubbo/dubbo --&gt;</span></span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;<span class="number">3.1</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;<span class="number">2.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>API 开放平台</category>
      </categories>
      <tags>
        <tag>星球项目</tag>
      </tags>
  </entry>
  <entry>
    <title>七、API 接口分析功能</title>
    <url>/2023/01/12/%E4%B8%83%E3%80%81API-%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h1 id="七、API-接口分析功能"><a href="#七、API-接口分析功能" class="headerlink" title="七、API 接口分析功能"></a>七、API 接口分析功能</h1><p>主要内容：</p>
<ol>
<li>开发抽象公共服务</li>
<li>实现网关核心业务流程</li>
<li>开发管理员接口分析功能</li>
<li>上线分析和发展</li>
</ol>
<h2 id="梳理网关业务流程"><a href="#梳理网关业务流程" class="headerlink" title="梳理网关业务流程"></a>梳理网关业务流程</h2><p>一下操作可以复用：</p>
<ol>
<li>实际情况应该是去数据库中查询是否已分配给用户秘钥（accessKey, secretKey 是否合法）<ol>
<li>先根据 accessKey 判断用户是否存在，查到 secretKey</li>
<li>对比 secretKey 和用户传的加密后的 secretKey 是否一致</li>
</ol>
</li>
<li>从数据库中查询模拟接口是否存在，以及请求方法是否匹配（还可以校验参数）</li>
<li>调用成功，接口调用次数 + 1 invokeCount</li>
</ol>
<h2 id="临时问题：如何获取接口转发服务器的地址"><a href="#临时问题：如何获取接口转发服务器的地址" class="headerlink" title="临时问题：如何获取接口转发服务器的地址"></a>临时问题：如何获取接口转发服务器的地址</h2><p>思路：网关启动时，获取所有的接口信息，维护到内存的 hashmap 中；有请求时，根据请求的 URL 路径或其他参数（比如 host 请求头） 来判断应该转发到哪台服务器、以及用户校验接口是否存在</p>
<h2 id="抽象公共服务"><a href="#抽象公共服务" class="headerlink" title="抽象公共服务"></a>抽象公共服务</h2><p>项目名：mofeng-common</p>
<p>目的是让方法、实体类在多个项目之间复用，提高代码复用率。</p>
<p>服务抽取：</p>
<ol>
<li>数据库中查询是否已分配给用户秘钥（根据 accessKey, 拿到用户信息，返回用户信息，为空表示不存在）</li>
<li>从数据库中查询模拟接口是否存在（请求方法、请求路径、请求参数、返回接口信息，为空表示不存在）</li>
<li>调用成功，接口调用次数 + 1 invokeCount （accessKey、secretKey （标识用户），请求接口路径）</li>
</ol>
<p>步骤：</p>
<ol>
<li>新建干净的 maven 项目，只保留必要的公共依赖</li>
<li>抽取 service 和实体类</li>
<li>install 本地 maven 包</li>
<li>让服务提供者引入 common 包，测试是否正常运行</li>
<li>让服务消费者引入 common 包</li>
</ol>
<h2 id="统计分析功能"><a href="#统计分析功能" class="headerlink" title="统计分析功能"></a>统计分析功能</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>各接口的总调用次数占比（饼图）取调用最多的前 3 个接口，从而分析哪些属于废弃接口（降低资源、或者下线），高频接口（增加资源、提高收费）</p>
<p>用饼图展示</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>可以使用现成的库</p>
<p>比如：</p>
<ul>
<li>ECharts:<a href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a>    (推荐)</li>
<li>AntV:<a href="https://antv.vision/">https://antv.vision/</a>     （推荐）</li>
<li>BizCharts</li>
</ul>
<p>如果是 React 项目，ECharts 用这个库：<a href="https://github.com/hustcc/echarts-for-react">https://github.com/hustcc/echarts-for-react</a></p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>编写一个接口，得到下列示例数据：</p>
<p>接口 A：2 次（调用）</p>
<p>接口 B：4 次（调用）</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301122208482.png" alt="image-20230112220759966"></p>
<p>步骤：</p>
<ol>
<li><p>SQL 查询调用数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> interfaceInfoId,<span class="built_in">sum</span>(totalNum) <span class="keyword">as</span> totalNum</span><br><span class="line"><span class="keyword">from</span> user_interface_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> interfaceInfoId</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> totalNum <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>业务层去关联查询接口信息</p>
</li>
</ol>
<h2 id="上线计划"><a href="#上线计划" class="headerlink" title="上线计划"></a>上线计划</h2><p>前端：直接打包部署即可</p>
<p>后端：</p>
<ul>
<li>backend 项目：web 项目，部署 spring boot 的 jar 包（对外）</li>
<li>gateway 项目：web 项目，部署 spring boot 的 jar 包（对外）</li>
<li>interface 项目：web 项目，部署 spring boot 的 jar 包（对内）</li>
</ul>
<p><strong>关键：网络必须联通</strong></p>
<p>项目由自己学习使用：单个服务器部署这三个项目就足够了</p>
<p>安全可靠：多个服务器建议在 <strong>同一内网</strong>，内网交互会更快、且更安全</p>
<h2 id="扩展思路"><a href="#扩展思路" class="headerlink" title="扩展思路"></a>扩展思路</h2><h3 id="1-用户可以申请更换签名"><a href="#1-用户可以申请更换签名" class="headerlink" title="1.用户可以申请更换签名"></a>1.用户可以申请更换签名</h3><h3 id="2-怎么让其他用户也上传接口？"><a href="#2-怎么让其他用户也上传接口？" class="headerlink" title="2.怎么让其他用户也上传接口？"></a>2.怎么让其他用户也上传接口？</h3><ul>
<li><p>需要提供一个机制（界面），让用户输入自己的接口 host （服务器地址）、接口信息，将接口信息写入数据库，可以在 interfaceInfo 表里添加一个 host 字段，区分服务器地址，让接口提供者更地接入系统</p>
</li>
<li><p>将接口信息写入数据库之前，要对接口进行校验（比如检查地址是否遵循规则，测试调用），保证接口使用正常</p>
</li>
<li><p>将接口信息写入数据库之前遵循本系统的要求（并且使用本系统的 SDK）</p>
</li>
<li><p>在接入时，平台需要测试调用这个接口，保证接口可以正常使用</p>
</li>
</ul>
<h3 id="3-网关校验是否还有调用次数"><a href="#3-网关校验是否还有调用次数" class="headerlink" title="3.网关校验是否还有调用次数"></a>3.网关校验是否还有调用次数</h3><p>需要考虑并发问题，防止瞬间调用超额</p>
<h3 id="4-网关优化"><a href="#4-网关优化" class="headerlink" title="4.网关优化"></a>4.网关优化</h3><p>比如增加限流 &#x2F; 降级保护，提高性能等。还可以考虑搭配 Nginx 网关使用</p>
<h3 id="5-更能增强"><a href="#5-更能增强" class="headerlink" title="5.更能增强"></a>5.更能增强</h3><p>可以针对不同的请求头或者接口类型来设计前端界面和表单，便于用户调用，获得更好的体验。</p>
<p>可以参考 swagger、postman、knife4j 的页面。</p>
]]></content>
      <categories>
        <category>API 开放平台</category>
      </categories>
      <tags>
        <tag>星球项目</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/2023/02/09/%E5%A2%A8%E6%9E%AB%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="1-MQ的相关概念"><a href="#1-MQ的相关概念" class="headerlink" title="1.MQ的相关概念"></a>1.MQ的相关概念</h2><h3 id="1-1什么是-MQ"><a href="#1-1什么是-MQ" class="headerlink" title="1.1什么是 MQ"></a>1.1什么是 MQ</h3><p>​		MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。</p>
<h3 id="1-2为什么要用-MQ"><a href="#1-2为什么要用-MQ" class="headerlink" title="1.2为什么要用 MQ"></a>1.2为什么要用 MQ</h3><ol>
<li><p>流量消峰 举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正 常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限 制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体 验要好。</p>
</li>
<li><p>应用解耦 以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于 消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p>
</li>
</ol>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302011220299.png" alt="image-20230201122049081"></p>
<ol start="3">
<li>异步处理 有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可 以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此 消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不 用做这些操作。A 服务还能及时的得到异步处理成功的消息。</li>
</ol>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302011221858.png" alt="image-20230201122130327"></p>
<h3 id="1-3MQ-的分类"><a href="#1-3MQ-的分类" class="headerlink" title="1.3MQ 的分类"></a>1.3MQ 的分类</h3><ol>
<li><p>ActiveMQ<br><strong>优点：</strong>单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据<br>**缺点:**官方社区现在对 ActiveMQ 5.x <strong>维护越来越少，高吞吐量场景较少使用。</strong><br>尚硅谷官网视频: <a href="http://www.gulixueyuan.com/course/322">http://www.gulixueyuan.com/course/322</a></p>
</li>
<li><p>Kafka 大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为大数据而生的消息中间件， 以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。<br><strong>优点:</strong> 性能卓越，单机写入 TPS 约在百万条&#x2F;秒，最大的优点，就是<strong>吞吐量高</strong>。时效性 ms 级可用性非 常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方 Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持： 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及<strong>日志采集</strong>被大规模使用<br><strong>缺点：</strong>Kafka 单机超过 64 个队列&#x2F;分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，社区更新较慢； </p>
</li>
<li><p>RocketMQ RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场 景。<br><strong>优点:单机吞吐量十万级</strong>,可用性非常高，分布式架构,<strong>消息可以做到 0 丢失</strong>,MQ 功能较为完善，还是分 布式的，扩展性好,<strong>支持 10 亿级别的消息堆积</strong>，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 MQ<br><strong>缺点：支持的客户端语言不多</strong>，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在 MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码 </p>
</li>
<li><p>RabbitMQ 2007 年发布，是一个在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，<strong>是当前最 主流的消息中间件之一。</strong><br><strong>优点:<strong>由于 erlang 语言的</strong>高并发特性</strong>，性能较好；<strong>吞吐量到万级</strong>，MQ 功能比较完备,健壮、稳定、易 用、跨平台、<strong>支持多种语言</strong> 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,<strong>社区活跃度高</strong>；<br>更新频率相当高 <a href="https://www.rabbitmq.com/news.html">https://www.rabbitmq.com/news.html</a><br><strong>缺点：</strong>商业版需要收费,学习成本较高</p>
</li>
</ol>
<h3 id="1-4MQ-的选择"><a href="#1-4MQ-的选择" class="headerlink" title="1.4MQ 的选择"></a>1.4MQ 的选择</h3><ol>
<li><p>Kafka<br>Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集 和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能， 肯定是首选 kafka 了。尚硅谷官网 kafka 视频连接 <a href="http://www.gulixueyuan.com/course/330/tasks">http://www.gulixueyuan.com/course/330/tasks</a></p>
</li>
<li><p>RocketMQ<br>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削 峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p>
</li>
<li><p>RabbitMQ<br>结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。</p>
</li>
</ol>
<h2 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2.RabbitMQ"></a>2.RabbitMQ</h2><h3 id="2-1-RabbitMQ-的概念"><a href="#2-1-RabbitMQ-的概念" class="headerlink" title="2.1 RabbitMQ 的概念"></a>2.1 RabbitMQ 的概念</h3><p>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包 裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。</p>
<h3 id="2-2-四大核心概念"><a href="#2-2-四大核心概念" class="headerlink" title="2.2 四大核心概念"></a>2.2 四大核心概念</h3><ol>
<li><p>生产者</p>
<p>产生数据发送消息的程序是生产者</p>
</li>
<li><p>交换机</p>
<p>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息</p>
<p>推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推</p>
<p>送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p>
</li>
<li><p>队列</p>
<p>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存</p>
<p>储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可</p>
<p>以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p>
</li>
<li><p>消费者</p>
<p>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费</p>
<p>者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p>
</li>
</ol>
<h3 id="2-3-RabbitMQ-核心部分"><a href="#2-3-RabbitMQ-核心部分" class="headerlink" title="2.3 RabbitMQ 核心部分"></a>2.3 RabbitMQ 核心部分</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302011234736.png" alt="image-20230201123408865"></p>
<h3 id="2-5各个名词介绍"><a href="#2-5各个名词介绍" class="headerlink" title="2.5各个名词介绍"></a>2.5各个名词介绍</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302011234537.png" alt="image-20230201123452541"></p>
<ul>
<li><p><strong>Broker：</strong>接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p>
</li>
<li><p><strong>Virtual host：</strong>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似</p>
<p>于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出</p>
<p>多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p>
</li>
<li><p><strong>Connection：</strong>publisher／consumer 和 broker 之间的 TCP 连接</p>
</li>
<li><p><strong>Channel：</strong>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP </p>
<p>Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程</p>
<p>序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客</p>
<p>户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的</p>
<p><strong>Connection 极大减少了操作系统建立 TCP connection 的开销</strong> </p>
</li>
<li><p><strong>Exchange：</strong>message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发</p>
<p>消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout </p>
<p>(multicast)</p>
</li>
<li><p><strong>Queue：</strong>消息最终被送到这里等待 consumer 取走</p>
</li>
<li><p><strong>Binding：</strong>exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保</p>
</li>
<li><p>存到 exchange 中的查询表中，用于 message 的分发依据</p>
</li>
</ul>
<h3 id="2-6RabbitMQ-安装"><a href="#2-6RabbitMQ-安装" class="headerlink" title="2.6RabbitMQ 安装"></a>2.6RabbitMQ 安装</h3><ol>
<li><p>官网地址下载<br><a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a></p>
</li>
<li><p>文件上传<br>上传到 &#x2F;usr&#x2F;local&#x2F;software 目录下（可以使用 Xftp 上传）<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151047302.png" alt="image-20230115104710973"></p>
</li>
<li><p>安装文件（按照顺序安装）<br>rpm -ivh erlang-21.3-1.el7.x86_64.rpm    安装 Erlang </p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151049919.png" alt="image-20230115104905385">yum install socat -y	安装依赖包</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151054823.png" alt="image-20230115105402243">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230115105503632.png" alt="image-20230115105503632">注：i 命令表示 install 安装；vh 命令显示安装进度；yum 命令需要联网</p>
</li>
<li><p>常用命令（按顺序）<br>添加开机启动 RabbitMQ 服务<br>chkconfig rabbitmq-server on<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151058073.png" alt="image-20230115105835506"></p>
<p>启动服务<br>&#x2F;sbin&#x2F;service rabbitmq-server start<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151102110.png" alt="image-20230115110208280"><br>查看服务状态<br>&#x2F;sbin&#x2F;service rabbitmq-server status<br>Active: active (running)    表示启动好了</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151103464.png" alt="image-20230115110311101"></p>
</li>
</ol>
<p>​		停止服务（选择执行）<br>​		 &#x2F;sbin&#x2F;service rabbitmq-server stop<br>​		开启 web 插件<br>​			rabbitmq-plugins enable rabbitmq_management<br>​		查看防火墙的状态<br>​		systemctl status firewalld<br>​		关闭防火墙<br>​		systemctl stop firewalld<br>​		开机时防火墙不再开启<br>​		systemctl enable firewalld<br>​		用默认账号密码(guest)访问地址 <a href="http://47.115.185.244:15672/%E5%87%BA%E7%8E%B0%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98">http://47.115.185.244:15672/出现权限问题</a>(服务器需要开放 15672 端口)</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151119523.png" alt="image-20230115111908386"></p>
<ol start="5">
<li><p>添加一个新用户</p>
<ol>
<li><p>创建账号 rabbitmqctl add_user admin 123 </p>
</li>
<li><p>设置用户角色 rabbitmqctl set_user_tags admin administrator </p>
</li>
<li><p>设置用户权限 set_permissions [-p ] <user> <conf> <wirte> <read></p>
<p>执行命令： rabbitmqctl set_permissions -p “&#x2F;“ admin “.<em>“ “.</em>“ “.*”</p>
<p>用户 user_admin 具有&#x2F;vhost1 这个 virtual host 中所有资源的配置、写、读权限 当前用户和角色</p>
<p>展示 rabbitmq 的用户：rabbitmqctl list_users</p>
<p>输入账户密码 admin 123 登录即可</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151135084.png" alt="image-20230115113515504"><strong>注：rebbitmqctl 命令表示设置权限；不同的 Virtual Hosts 交换机（Exchanges)和队列(Queuees)是不一样的</strong></p>
</li>
</ol>
</li>
<li><p>重置命令</p>
<ol>
<li>关闭应用命令 rabbitmqctl stop_app</li>
<li>清除命令 rabbitmqctl resest</li>
<li>重新启动命令 rabbitmqctl start_app</li>
</ol>
</li>
</ol>
<h2 id="3-RabbitMQ"><a href="#3-RabbitMQ" class="headerlink" title="3.RabbitMQ"></a>3.RabbitMQ</h2><h3 id="3-1Hello-World-案例"><a href="#3-1Hello-World-案例" class="headerlink" title="3.1Hello World 案例"></a>3.1Hello World 案例</h3><p>在本教程的这一部分中，我们将用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印 出来的消费者。我们将介绍 Java API 中的一些细节。</p>
<p> 在下图中，“ P”是我们的生产者，“ C”是我们的消费者。中间的框是一个队列-RabbitMQ 代 表使用者保留的消息缓冲区<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151155281.png" alt="image-20230115115509389"></p>
<h4 id="3-1-1配置环境"><a href="#3-1-1配置环境" class="headerlink" title="3.1.1配置环境"></a>3.1.1配置环境</h4><p>创建一个空项目，然后创建 rabbitmq-hello 模块，在 rabbitmq-hello 添加依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--指定 jdk 编译版本--&gt;</span><br><span class="line">   &lt;build&gt;</span><br><span class="line">       &lt;plugins&gt;</span><br><span class="line">           &lt;plugin&gt;</span><br><span class="line">               &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">               &lt;configuration&gt;</span><br><span class="line">                   &lt;source&gt;<span class="number">8</span>&lt;/source&gt;</span><br><span class="line">                   &lt;target&gt;<span class="number">8</span>&lt;/target&gt;</span><br><span class="line">               &lt;/configuration&gt;</span><br><span class="line">           &lt;/plugin&gt;</span><br><span class="line">       &lt;/plugins&gt;</span><br><span class="line">   &lt;/build&gt;</span><br><span class="line">   &lt;dependencies&gt;</span><br><span class="line">       &lt;!--rabbitmq 依赖客户端--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">5.8</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--操作文件流的一个依赖--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">2.6</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">1.7</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2消费生产者"><a href="#3-1-2消费生产者" class="headerlink" title="3.1.2消费生产者"></a>3.1.2消费生产者</h4><p>RabbitMQ 工作原理图<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151447611.png" alt="image-20230115144729758"></p>
<p>步骤：</p>
<ol>
<li>创建连接工厂</li>
<li>设置连接 RabbitMQ 的 IP 地址</li>
<li>设置用户名和密码</li>
<li>创建连接</li>
<li>获取信道</li>
<li>生成队列</li>
<li>发送消息</li>
</ol>
<p>创建一个生产者类 Producer，发送消息 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 生产者：发送消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/1/15 12:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RABBITMQ_HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 工厂 IP 连接 RabbitMQ 的队列</span></span><br><span class="line">        connectionFactory.setHost(RABBITMQ_HOST);</span><br><span class="line">        <span class="comment">// 用户名</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 密码</span></span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">// 获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.队列里面的消息是否持久化（磁盘） 默认情况下消息存储在内存中</span></span><br><span class="line"><span class="comment">         * 3.该队列是否只供一个消费者消费，是否进行消息共享，true: 多个消费者消费 flase: 只能一个消费者消费</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除，最后一个消费者端开连接以后 该队列是否自动删除，true 自动删除 false 不自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 发消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消费</span></span><br><span class="line"><span class="comment">         * 1.发送到哪个交换机</span></span><br><span class="line"><span class="comment">         * 2.路由的 key 值是哪个 本次队列的名称</span></span><br><span class="line"><span class="comment">         * 3.其他参数信息</span></span><br><span class="line"><span class="comment">         * 4.发送消息的本体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送成功后可以在管理客户端中 Queues 中查看详情</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151256110.png" alt="image-20230115125655206"></p>
<h4 id="3-1-3消息消费者"><a href="#3-1-3消息消费者" class="headerlink" title="3.1.3消息消费者"></a>3.1.3消息消费者</h4><p>创建一个消费者 Consumer 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 生产者：发送消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/1/15 12:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RABBITMQ_HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 工厂 IP 连接 RabbitMQ 的队列</span></span><br><span class="line">        connectionFactory.setHost(RABBITMQ_HOST);</span><br><span class="line">        <span class="comment">// 用户名</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 密码</span></span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">// 获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.队列里面的消息是否持久化（磁盘） 默认情况下消息存储在内存中</span></span><br><span class="line"><span class="comment">         * 3.该队列是否只供一个消费者消费，是否进行消息共享，true: 多个消费者消费 flase: 只能一个消费者消费</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除，最后一个消费者端开连接以后 该队列是否自动删除，true 自动删除 false 不自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 发消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消费</span></span><br><span class="line"><span class="comment">         * 1.发送到哪个交换机</span></span><br><span class="line"><span class="comment">         * 2.路由的 key 值是哪个 本次队列的名称</span></span><br><span class="line"><span class="comment">         * 3.其他参数信息</span></span><br><span class="line"><span class="comment">         * 4.发送消息的本体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-1-4常见报错以及解决"><a href="#3-1-4常见报错以及解决" class="headerlink" title="3.1.4常见报错以及解决"></a>3.1.4常见报错以及解决</h4><ol>
<li>SQL4J 错误</li>
</ol>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151235731.png" alt="image-20230115123511995"></p>
<p>添加 SLF4J 依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.7</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建连接java.net.ConnectException: Connection timed out: connect</li>
</ol>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151254283.png" alt="image-20230115125416151"></p>
<p>​		原因：服务器的 5672 端口没有开启，在服务器开启 5672 端口，重新启动即可</p>
<h3 id="3-2-Work-Queues-案例"><a href="#3-2-Work-Queues-案例" class="headerlink" title="3.2 Work Queues 案例"></a>3.2 Work Queues 案例</h3><p>工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p>
<p><img src="E:\java\Learn\消息队列\墨枫消息队列.assets\202301151502309.png" alt="image-20230115150241640"></p>
<h4 id="3-2-1-轮询分发消息"><a href="#3-2-1-轮询分发消息" class="headerlink" title="3.2.1 轮询分发消息"></a>3.2.1 轮询分发消息</h4><p>在这个案例中我们会启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程 是如何工作的。</p>
<h4 id="3-2-2-抽取工具类"><a href="#3-2-2-抽取工具类" class="headerlink" title="3.2.2 抽取工具类"></a>3.2.2 抽取工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接工厂创建信道的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqUtils</span> &#123;</span><br><span class="line">  <span class="comment">// 队列名称</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RABBITMQ_HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//创建一个连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(RABBITMQ_HOST);</span><br><span class="line">    factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">    <span class="keyword">return</span> channel;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-启动两个线程"><a href="#3-2-3-启动两个线程" class="headerlink" title="3.2.3 启动两个线程"></a>3.2.3 启动两个线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 工作线程（相当于之前的消费者）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/1/15 15:13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 取消消息时的回调</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">&quot;消费者取消消接口回调逻辑！！&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;A1 等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="comment">// System.out.println(&quot;A2 等待接收消息.....&quot;);</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费者消费</span></span><br><span class="line"><span class="comment">         * 1.消费哪个队列</span></span><br><span class="line"><span class="comment">         * 2.消费成功后是否需要自动应答 true 代表自动应答 false 代表手动应答</span></span><br><span class="line"><span class="comment">         * 3.消费者未成功消费的回调</span></span><br><span class="line"><span class="comment">         * 4.消费者取录消费的回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>IDEA 配置</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301152127541.png" alt="image-20230115212723655"></p>
<p>点击 Modify options </p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301152129021.png" alt="image-20230115212858945"></p>
<p>勾选 Allow mutiple instances 即可</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301152129589.png" alt="image-20230115212929005"></p>
<p>启动后控制台输出</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301152131294.png" alt="image-20230115213101094"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301152131294.png" alt="image-20230115213113872"></p>
<h4 id="3-2-4-启动一个发送线程"><a href="#3-2-4-启动一个发送线程" class="headerlink" title="3.2.4 启动一个发送线程"></a>3.2.4 启动一个发送线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 生产者 发送大量消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/1/15 15:30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送发量消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 队列声明</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.队列里面的消息是否持久化（磁盘） 默认情况下消息存储在内存中</span></span><br><span class="line"><span class="comment">         * 3.该队列是否只供一个消费者消费，是否进行消息共享，true: 多个消费者消费 flase: 只能一个消费者消费</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除，最后一个消费者端开连接以后 该队列是否自动删除，true 自动删除 false 不自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 从控制台当中接收信息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 发送一个消费</span></span><br><span class="line"><span class="comment">             * 1.发送到哪个交换机</span></span><br><span class="line"><span class="comment">             * 2.路由的 key 值是哪个 本次队列的名称</span></span><br><span class="line"><span class="comment">             * 3.其他参数信息</span></span><br><span class="line"><span class="comment">             * 4.发送消息的本体</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息完成：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-5-结果展示"><a href="#3-2-5-结果展示" class="headerlink" title="3.2.5 结果展示"></a>3.2.5 结果展示</h4><p>生产者控制台</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301152133408.png" alt="image-20230115213341185"></p>
<p>消费者</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301152134867.png" alt="image-20230115213424143"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301152134447.png" alt="image-20230115213454899"></p>
<h3 id="3-3消息应答"><a href="#3-3消息应答" class="headerlink" title="3.3消息应答"></a>3.3消息应答</h3><h4 id="3-3-1概念"><a href="#3-3-1概念" class="headerlink" title="3.3.1概念"></a>3.3.1概念</h4><p>​		消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成 了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消 息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续 发送给该消费这的消息，因为它无法接收到。</p>
<p>​		为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是:<strong>消费者在接 收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong> </p>
<h4 id="3-3-2自动应答"><a href="#3-3-2自动应答" class="headerlink" title="3.3.2自动应答"></a>3.3.2自动应答</h4><p>​		消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢 失了,当然另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>， 当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终 使得内存耗尽，最终这些消费者线程被操作系统杀死，<strong>所以这种模式仅适用在消费者可以高效并 以某种速率能够处理这些消息的情况下使用。</strong></p>
<h4 id="3-3-3消息应答的方法"><a href="#3-3-3消息应答的方法" class="headerlink" title="3.3.3消息应答的方法"></a>3.3.3消息应答的方法</h4><ul>
<li>A.Channel.basicAck(用于肯定确认)</li>
</ul>
<p>​			RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了 </p>
<ul>
<li><p>B.Channel.basicNack(用于否定确认) </p>
</li>
<li><p>C.Channel.basicReject(用于否定确认)</p>
</li>
</ul>
<p>​			与 Channel.basicNack 相比少一个参数 </p>
<p>​			不处理该消息了直接拒绝，可以将其丢弃了</p>
<h4 id="3-3-4Multiple-的解释"><a href="#3-3-4Multiple-的解释" class="headerlink" title="3.3.4Multiple 的解释"></a>3.3.4Multiple 的解释</h4><p><strong>手动应答的好处是可以批量应答并且减少网络拥堵</strong> </p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302011244918.png" alt="image-20230201124424828"></p>
<p>multiple 的 true 和 false 代表不同意思</p>
<ul>
<li><p><strong>true 代表批量应答 channel 上未应答的消息</strong><br>比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答</p>
</li>
<li><p>false 同上面相比</p>
<p>只会应答 tag&#x3D;8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</p>
</li>
</ul>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302011246745.png" alt="image-20230201124615067"></p>
<h4 id="3-3-5消息自动重新入队"><a href="#3-3-5消息自动重新入队" class="headerlink" title="3.3.5消息自动重新入队"></a>3.3.5消息自动重新入队</h4><p>​		如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息 未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302011249441.png" alt="image-20230201124936989"></p>
<h4 id="3-3-6消息手动应答代码"><a href="#3-3-6消息手动应答代码" class="headerlink" title="3.3.6消息手动应答代码"></a>3.3.6消息手动应答代码</h4><p>​		默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改 为手动应答，消费者在上面代码的基础上增加下面画红色部分代码。</p>
<p>WorkConsumer03.java</p>
<p>消费生产者 Task2.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消息在手动应答时是不丢失、放回队列中重新消费</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/1/15 21:22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 在控制台输入信息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者 01</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消息在手动应答时是不丢失、放回队列中重新消费</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/1 19:54</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkConsumer03</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1 等待接收消息处理时间较短&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 沉睡一秒</span></span><br><span class="line">            SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">// 手动应答</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1. 消息的标记</span></span><br><span class="line"><span class="comment">             * 2. 是否批量应答 false:不批量应答信道中的消息 true: 批量</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, (consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>消费者 02</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消息在手动应答时是不丢失、放回队列中重新消费</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/1 19:54</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkConsumer04</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C2 等待接收消息处理时间较长&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 沉睡一秒</span></span><br><span class="line">            SleepUtils.sleep(<span class="number">30</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">// 手动应答</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1. 消息的标记</span></span><br><span class="line"><span class="comment">             * 2. 是否批量应答 false:不批量应答信道中的消息 true: 批量</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, (consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>睡眠工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepUtils</span> &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 睡眠工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Params</span>: [second]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> void</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 20:06 2023/2/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> second)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   Thread.sleep(<span class="number">1000</span> * second);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException _ignored) &#123;</span><br><span class="line">   Thread.currentThread().interrupt();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-7手动应答效果演示"><a href="#3-3-7手动应答效果演示" class="headerlink" title="3.3.7手动应答效果演示"></a>3.3.7手动应答效果演示</h4><p>正常情况下消息发送方发送两个消息 C1 和 C2 分别接收到消息并进行处理</p>
<p><img src="E:\java\Learn\消息队列\墨枫消息队列.assets\202302012217011.png" alt="image-20230201221717743"></p>
<p>在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是 由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了， 此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302012218291.png" alt="image-20230201221845892"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302012219238.png" alt="image-20230201221859910"></p>
<h3 id="3-4RabbitMQ-持久化"><a href="#3-4RabbitMQ-持久化" class="headerlink" title="3.4RabbitMQ 持久化"></a>3.4RabbitMQ 持久化</h3><h4 id="3-4-1概念"><a href="#3-4-1概念" class="headerlink" title="3.4.1概念"></a>3.4.1概念</h4><p>​		刚刚我们已经看到了如何处理任务不丢失的情况，但是如何保障当 RabbitMQ 服务停掉以后消息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化。</strong></p>
<h4 id="3-4-2队列如何实现持久化"><a href="#3-4-2队列如何实现持久化" class="headerlink" title="3.4.2队列如何实现持久化"></a>3.4.2队列如何实现持久化</h4><p>​		之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果 要队列实现持久化 需要在声明队列的时候把 durable 参数设置为持久化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 让消息队列持久化</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">channel.queueDeclare(ACK_QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>​		但是需要注意的就是如果之前声明的队列不是持久化的，需要把<strong>原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误</strong></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302021052636.png"></p>
<p>以下为控制台中持久化与非持久化队列的 UI 显示区</p>
<p>Features 显示 ”D“ 表示已经进行持久化了，Durable 首字母</p>
<p>显示 “AD Excl” 表示临时的</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302021054586.png" alt="image-20230202105412616"></p>
<p><strong>这个时候即使重启 rabbitmq 队列也依然存在</strong></p>
<h4 id="3-4-3消息实现持久化"><a href="#3-4-3消息实现持久化" class="headerlink" title="3.4.3消息实现持久化"></a>3.4.3消息实现持久化</h4><p>​		要想让消息实现持久化需要在消息生产者修改代码，MessageProperties.PERSISTENT_TEXT_PLAIN 添 加这个属性。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302021104433.png" alt="image-20230202110410839"></p>
<p>​		将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是 这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果需要 更强有力的持久化策略，参考后边课件发布确认章节。</p>
<h4 id="3-4-4不公开分发"><a href="#3-4-4不公开分发" class="headerlink" title="3.4.4不公开分发"></a>3.4.4不公开分发</h4><p>​		在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是 很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间 处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p>
<p>为了避免这种情况，我们可以在消费者中设置参数 channel.basicQos(1);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 设置不公平分发</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure>

<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302021114259.png" alt="image-20230202111414999"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302021116053.png" alt="image-20230202111647356">		</p>
<p>​		意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个 任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加 新的 worker 或者改变其他存储任务的策略。</p>
<h4 id="3-4-5预取值"><a href="#3-4-5预取值" class="headerlink" title="3.4.5预取值"></a>3.4.5预取值</h4><p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费<br>者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此</strong><br><strong>缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。</strong>这个时候就可以通过使用 basic.qos 方法设<br>置“预取计数”值来完成的。<strong>该值定义通道上允许的未确认消息的最大数量。</strong>一旦数量达到配置的数量，<br>RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有<br>未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何<br>消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知<br>这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高<br>向消费者传递消息的速度<strong>。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理</strong><br><strong>的消息的数量也会增加，从而增加了消费者的 RAM 消耗</strong>(随机存取存储器)应该小心使用具有无限预处理<br>的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的<br>内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范<br>围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为 1 是最保守的。当然这<br>将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境<br>中。对于大多数应用来说，稍微高一点的值将是最佳的。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302021144460.png" alt="image-20230202114359020"></p>
<h2 id="4-发布确认"><a href="#4-发布确认" class="headerlink" title="4.发布确认"></a>4.发布确认</h2><h3 id="4-1发布确认原理"><a href="#4-1发布确认原理" class="headerlink" title="4.1发布确认原理"></a>4.1发布确认原理</h3><p>​		生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，**所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)**，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队 列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p>
<p>​		confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消 息，生产者应用程序同样可以在回调方法中处理该 nack 消息</p>
<h3 id="4-2发布确认策略"><a href="#4-2发布确认策略" class="headerlink" title="4.2发布确认策略"></a>4.2发布确认策略</h3><h4 id="4-2-1开启发布确认的方法"><a href="#4-2-1开启发布确认的方法" class="headerlink" title="4.2.1开启发布确认的方法"></a>4.2.1开启发布确认的方法</h4><p>​		发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布 确认，都需要在 channel 上调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel(); </span><br><span class="line"><span class="comment">// 开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2单个确认发布"><a href="#4-2-2单个确认发布" class="headerlink" title="4.2.2单个确认发布"></a>4.2.2单个确认发布</h4><p>​		这是一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，也就是发布一个消息之后只有它 被确认发布，后续的消息才能继续发布, waitForConfirmsOrDie(long) 这个方法只有在消息被确认 的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p>
<p>​		这种确认方式有一个最大的缺点就是:<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会 阻塞所有后续消息的发布，<strong>这种方式最多提供每秒不超过数百条发布消息的吞吐量</strong>。当然对于某 些应用程序来说这可能已经足够了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">SinglePublishMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 队列的声明</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 批量发消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            <span class="comment">// 单个消息就马上进行发布确认</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送成功！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个单独确认消息，耗时&quot;</span> + (endTime - beginTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3批量发布确认"><a href="#4-2-3批量发布确认" class="headerlink" title="4.2.3批量发布确认"></a>4.2.3批量发布确认</h4><p>​		上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是:<strong>当发生故障导致发布出现问题时，不知道是哪个消息出现 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。</strong>当然这种 方案仍然是同步的，也一样阻塞消息的发布。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">BatchPublishMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 队列的声明</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 批量确认大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 批量发消息 批量发布确认</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            <span class="comment">// 判断达到 100 条消息的时候，批量确认一次</span></span><br><span class="line">            <span class="keyword">if</span>((i + <span class="number">1</span>) % batchSize == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 发布确认</span></span><br><span class="line">                channel.waitForConfirms();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个批量确认消息，耗时&quot;</span> + (endTime - beginTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4如何处理异步未确认的消息"><a href="#4-2-4如何处理异步未确认的消息" class="headerlink" title="4.2.4如何处理异步未确认的消息"></a>4.2.4如何处理异步未确认的消息</h4><p>​		最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传 递。</p>
<h4 id="4-2-5-ConcurrentSkipListMap"><a href="#4-2-5-ConcurrentSkipListMap" class="headerlink" title="4.2.5 ConcurrentSkipListMap"></a>4.2.5 ConcurrentSkipListMap</h4><p>ConcurrentSkipListMap 是线程安全的有序的哈希表，适用于高并发的场景。<br>ConcurrentSkipListMap 和T reeMap，它们虽然都是有序的哈希表。</p>
<ul>
<li>第一，它们的线程安全机制不同，TreeMap 是非线程安全的，而 ConcurrentSkipListMap 是线程安全的。</li>
<li>第二，ConcurrentSkipListMap 是通过跳表实现的，而TreeMap是通过红黑树实现的。</li>
</ul>
<p>在4线程1.6万数据的条件下，ConcurrentHashMap 存取速度是ConcurrentSkipListMap 的4倍左右。</p>
<p>但ConcurrentSkipListMap有几个ConcurrentHashMap 不能比拟的优点：</p>
<ol>
<li>ConcurrentSkipListMap 的key是有序的。</li>
<li>ConcurrentSkipListMap 支持更高的并发。<br>ConcurrentSkipListMap 的存取时间是log（N），和线程数几乎无关。也就是说在数据量一定的情况下，并发的线程越多，ConcurrentSkipListMap越能体现出他的优势。</li>
</ol>
<p>在非多线程的情况下，应当尽量使用 TreeMap。此外对于并发性相对较低的并行程序可以使用Collections.synchronizedSortedMap 将 TreeMap 进行包装，也可以提供较好的效率。对于高并发程序，应当使用 ConcurrentSkipListMap，能够提供更高的并发度。<br>所以在多线程程序中，如果需要对Map的键值进行排序时，请尽量使用 ConcurrentSkipListMap，可能得到更好的并发度。<br>注意，调用 ConcurrentSkipListMap 的 size 时，由于多个线程可以同时对映射表进行操作，所以映射表需要遍历整个链表才能返回元素个数，这个操作是个 O(log(n)) 的操作。</p>
<h4 id="4-2-6异步确认发布"><a href="#4-2-6异步确认发布" class="headerlink" title="4.2.6异步确认发布"></a>4.2.6异步确认发布</h4><p>​		异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302031021754.png" alt="image-20230203102145627"></p>
<p>异步确认实现具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">AsyncPublishMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 队列的声明</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程安全的有序的哈希表</span></span><br><span class="line"><span class="comment">         * 1. 轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment">         * 2. 轻松地批量删除条目 只要给到序号</span></span><br><span class="line"><span class="comment">         * 3. 支持高并发 （多线程）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 消息确认成功 回调函数</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">                <span class="comment">// 2、删除已经确认的消息 剩下的就是未确认的消息</span></span><br><span class="line">                ConcurrentNavigableMap&lt;Long, String&gt; confirms = outstandingConfirms.headMap(deliveryTag);</span><br><span class="line">                confirms.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                outstandingConfirms.remove(deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;确认的消息&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 消息确认失败 回调函数 参数1：消息的标记 参数2：是否为批量确认</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 3、打印未确认的消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> outstandingConfirms.get(deliveryTag);</span><br><span class="line">            System.out.println(<span class="string">&quot;未确认的消息时：&quot;</span> + message + <span class="string">&quot;未确认的消息 tag: &quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 准备消息的监听器 监听消息的发送状态 异步通知</span></span><br><span class="line">        channel.addConfirmListener(ackCallback, nackCallback);</span><br><span class="line">        <span class="comment">// 批量发消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;消息&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            <span class="comment">// 1、此处记录下所有发送的消息 消息的总和</span></span><br><span class="line">            outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个异步发布确认消息，耗时&quot;</span> + (endTime - beginTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-7单个、批量、异步批量确认发布速度对比"><a href="#4-2-7单个、批量、异步批量确认发布速度对比" class="headerlink" title="4.2.7单个、批量、异步批量确认发布速度对比"></a>4.2.7单个、批量、异步批量确认发布速度对比</h4><ul>
<li><strong>单独发布消息</strong><br>同步等待确认，简单，但吞吐量非常有限。 </li>
<li><strong>批量发布消息</strong><br>批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条 消息出现了问题。 </li>
<li><strong>异步处理</strong><br>最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 单个确认 发布1000个单独确认消息，耗时58713ms</span></span><br><span class="line">        <span class="comment">//SinglePublishMessage();</span></span><br><span class="line">        <span class="comment">// 2. 批量确认 发布1000个批量确认消息，耗时303ms</span></span><br><span class="line">        <span class="comment">//BatchPublishMessage();</span></span><br><span class="line">        <span class="comment">// 3. 异步批量确认 发布1000个异步发布确认消息，耗时123ms</span></span><br><span class="line">        AsyncPublishMessage();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-交换机"><a href="#5-交换机" class="headerlink" title="5.交换机"></a>5.交换机</h2><p>​		在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消 费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式 称为 ”发布&#x2F;订阅”.</p>
<p>​		为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘， 另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费 者者</p>
<h3 id="5-1Exchange"><a href="#5-1Exchange" class="headerlink" title="5.1Exchange"></a>5.1Exchange</h3><h4 id="5-1-1Exhcange-概念"><a href="#5-1-1Exhcange-概念" class="headerlink" title="5.1.1Exhcange 概念"></a>5.1.1Exhcange 概念</h4><p>​		RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列。</strong>实际上，通常生产 者甚至都不知道这些消息传递传递到了哪些队列中。</p>
<p>​		相反，**生产者只能将消息发送到交换机(exchange)**，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消 息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p>
<h4 id="5-1-2Exchange-的类型"><a href="#5-1-2Exchange-的类型" class="headerlink" title="5.1.2Exchange 的类型"></a>5.1.2Exchange 的类型</h4><p>一共有四种类型：</p>
<ul>
<li>扇出（fanout)</li>
<li>直接（direct)</li>
<li>主题（topic)</li>
<li>标题（headers)</li>
</ul>
<h4 id="5-1-3无名-Exchange"><a href="#5-1-3无名-Exchange" class="headerlink" title="5.1.3无名 Exchange"></a>5.1.3无名 Exchange</h4><p>​		在本教程的前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>​		第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实 是由 routingKey(bindingkey) 绑定 key 指定的，如果它存在的话</p>
<h3 id="5-2临时队列"><a href="#5-2临时队列" class="headerlink" title="5.2临时队列"></a>5.2临时队列</h3><p>​		之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们 来说至关重要-我们需要指定我们的消费者去消费哪个队列的消息。</p>
<p>​		每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个<strong>具有随机名称的队列</strong>，或者能让服务器为我们选择一个随机队列名称那就更好了。其次<strong>一旦我们断开了消费者的连接，队列将被自动删除。</strong></p>
<p>创建临时队列的方式如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure>

<p>如下图所示：</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061443690.png" alt="image-20230206144301384"></p>
<h3 id="5-3绑定（bindings）"><a href="#5-3绑定（bindings）" class="headerlink" title="5.3绑定（bindings）"></a>5.3绑定（bindings）</h3><p>​		什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队 列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061443553.png" alt="image-20230206144353313"></p>
<h3 id="5-4Fanout"><a href="#5-4Fanout" class="headerlink" title="5.4Fanout"></a>5.4Fanout</h3><h4 id="5-4-1Fanout-介绍"><a href="#5-4-1Fanout-介绍" class="headerlink" title="5.4.1Fanout 介绍"></a>5.4.1Fanout 介绍</h4><p>​		Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息<strong>广播</strong>到它知道的 所有队列中。系统中默认有些 exchange 类型</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061446628.png" alt="image-20230206144651541"></p>
<h4 id="5-4-2-Fanout-实战"><a href="#5-4-2-Fanout-实战" class="headerlink" title="5.4.2 Fanout 实战"></a>5.4.2 Fanout 实战</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061447080.png" alt="image-20230206144736810"></p>
<p>Logs 和临时队列的绑定关系如下图</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061449491.png" alt="image-20230206144927335"></p>
<p>ReceiveLogs01 将接收到的消息打印在控制台</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消息接收</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/5 9:58</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLog01</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明一个临时队列（非连接状态会删除）</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个临时队列、队列的名称是随机的</span></span><br><span class="line"><span class="comment">         * 当消费者断开与队列的连接的时候，队列会自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">// 绑定交换机与队列</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息，把接收消息打印在屏幕上。。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLog01控制台打印接收到的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 消费者取消消息时回调接口</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReceiveLogs02 将接收到的消息打印在控制台</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消息接收</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/5 9:58</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLog02</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明一个临时队列（非连接状态会删除）</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个临时队列、队列的名称是随机的</span></span><br><span class="line"><span class="comment">         * 当消费者断开与队列的连接的时候，队列会自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">// 绑定交换机与队列</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息，把接收消息打印在屏幕上。。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLog02 控制台打印接收到的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">//File file = new File(&quot;D:\\桌面\\RabbitMQ\\fanoutPrint.txt&quot;);</span></span><br><span class="line">            <span class="comment">//FileUtils.writeStringToFile(file, new String(message.getBody(), &quot;UTF-8&quot;), &quot;UTF-8&quot;);</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;数据写入文件成功！&quot;);</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 消费者取消消息时回调接口</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EmitLog 发送消息给两个消费者接收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 发消息 交换机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 12:09</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-Direct-exchange"><a href="#5-5-Direct-exchange" class="headerlink" title="5.5 Direct exchange"></a>5.5 Direct exchange</h3><h4 id="5-5-1回顾"><a href="#5-5-1回顾" class="headerlink" title="5.5.1回顾"></a>5.5.1回顾</h4><p>​		在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本 节我们将向其中添加一些特别的功能-比方说我们只让某个消费者订阅发布的部分消息。例如我们只把 严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。</p>
<p>​		我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： <strong>队列只对它绑定的交换机的消息感兴趣。</strong>绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);<strong>绑定之后的 意义由其交换类型决定。</strong></p>
<h4 id="5-5-2-Direct-exhcange-介绍"><a href="#5-5-2-Direct-exhcange-介绍" class="headerlink" title="5.5.2 Direct exhcange 介绍"></a>5.5.2 Direct exhcange 介绍</h4><p>​		上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希 望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061502033.png" alt="image-20230206150241071"></p>
<p>​		在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列 Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green.</p>
<p>​		在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p>
<h4 id="5-5-3-多重绑定"><a href="#5-5-3-多重绑定" class="headerlink" title="5.5.3 多重绑定"></a>5.5.3 多重绑定</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061503490.png" alt="image-20230206150325345"></p>
<p>​		当然如果 exchange 的绑定类型是 direct，<strong>但是它绑定的多个队列的 key 如果都相同</strong>，在这种情 况下虽然绑定类型是 direct <strong>但是它表现的就和 fanout 有点类似了</strong>，就跟广播差不多，如上图所示。</p>
<h4 id="5-5-4-Direct-Exchange-实战"><a href="#5-5-4-Direct-Exchange-实战" class="headerlink" title="5.5.4 Direct Exchange 实战"></a>5.5.4 Direct Exchange 实战</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061504204.png" alt="image-20230206150431067"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061506532.png" alt="image-20230206150649262"></p>
<p>ReceiveLogsDirect01.java 接收消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:等待接收消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 12:21</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">// 声明一个队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;console&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;console&quot;</span>, EXCHANGE_NAME, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;console&quot;</span>, EXCHANGE_NAME, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLogsDirect01 控制台打印接收到的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 消费者取消消息时回调接口</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;console&quot;</span>, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReceiveLogsDirect02.java 接收消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 等待接收消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 12:21</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">// 声明一个队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;disk&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;disk&quot;</span>, EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLogsDirect02 控制台打印接收到的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 消费者取消消息时回调接口</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;disk&quot;</span>, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DirectLogs 生产者发消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 发消息 交换机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 12:09</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectLogs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-6-Topics"><a href="#5-6-Topics" class="headerlink" title="5.6 Topics"></a>5.6 Topics</h3><h4 id="5-6-1-fanout、direct类型的问题"><a href="#5-6-1-fanout、direct类型的问题" class="headerlink" title="5.6.1 fanout、direct类型的问题"></a>5.6.1 fanout、direct类型的问题</h4><p>​		在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是 使用了 direct 交换机，从而有能实现有选择性地接收日志。</p>
<p>​		尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候 direct 就办不到了。这个时候 就只能使用 topic 类型</p>
<h4 id="5-6-2-Topic-的要求"><a href="#5-6-2-Topic-的要求" class="headerlink" title="5.6.2 Topic 的要求"></a>5.6.2 Topic 的要求</h4><p>​		发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它<strong>必须是一个单词列表，以点号分隔开。</strong>这些单词可以是任意单词，比如说：”stock.usd.nyse”, “nyse.vmw”,  “quick.orange.rabbit”.这种类型的。当然这个单词列表最多不能超过 255 个字节。</p>
<p>在这个规则列表中，其中有两个替换符是大家需要注意的 </p>
<ul>
<li>***(星号)可以代替一个单词** </li>
<li><strong>#(井号)可以替代零个或多个单词</strong></li>
</ul>
<h4 id="5-6-3-Topic-匹配案例"><a href="#5-6-3-Topic-匹配案例" class="headerlink" title="5.6.3 Topic 匹配案例"></a>5.6.3 Topic 匹配案例</h4><p>下图绑定关系如下<br>Q1–&gt;绑定的是<br>         中间带 orange 带 3 个单词的字符串(<em>.orange.</em>)<br>Q2–&gt;绑定的是<br>        最后一个单词是 rabbit 的 3 个单词(<em>.</em>.rabbit)<br>        第一个单词是 lazy 的多个单词(lazy.#)</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061513539.png" alt="image-20230206151331534"></p>
<p>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的</p>
<table>
<thead>
<tr>
<th>routingKey</th>
<th>数据内容</th>
</tr>
</thead>
<tbody><tr>
<td>quick.orange.rabbit</td>
<td>被队列 Q1Q2 接收到</td>
</tr>
<tr>
<td>lazy.orange.elephant</td>
<td>被队列 Q1Q2 接收到</td>
</tr>
<tr>
<td>quick.orange.fox</td>
<td>被队列 Q1 接收到</td>
</tr>
<tr>
<td>lazy.brown.fox</td>
<td>被队列 Q2 接收到</td>
</tr>
<tr>
<td>lazy.pink.rabbit</td>
<td>虽然满足两个绑定但只被队列 Q2 接收一次</td>
</tr>
<tr>
<td>quick.brown.fox</td>
<td>不匹配任何绑定不会被任何队列接收到会被丢弃</td>
</tr>
<tr>
<td>quick.orange.male.rabbit</td>
<td>是四个单词不匹配任何绑定会被丢弃</td>
</tr>
<tr>
<td>lazy.orange.male.rabbit</td>
<td>是四个单词但匹配 Q2</td>
</tr>
</tbody></table>
<p>当队列绑定关系是下列这种情况时需要引起注意</p>
<ul>
<li><strong>当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像 fanout 了</strong> </li>
<li><strong>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了</strong></li>
</ul>
<h4 id="5-6-4-Topic-实战"><a href="#5-6-4-Topic-实战" class="headerlink" title="5.6.4 Topic 实战"></a>5.6.4 Topic 实战</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061520103.png" alt="image-20230206152004674"></p>
<p>生产者 EmitLogTopic</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 生产者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 13:32</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLogTopic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Q1--&gt;绑定的是</span></span><br><span class="line"><span class="comment">         *  中间带 orange 带 3 个单词的字符串(*.orange.*)</span></span><br><span class="line"><span class="comment">         * Q2--&gt;绑定的是</span></span><br><span class="line"><span class="comment">         * 最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)</span></span><br><span class="line"><span class="comment">         * 第一个单词是 lazy 的多个单词(lazy.#)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.rabbit&quot;</span>,<span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.orange.elephant&quot;</span>,<span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.fox&quot;</span>,<span class="string">&quot;被队列 Q1 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.brown.fox&quot;</span>,<span class="string">&quot;被队列 Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.pink.rabbit&quot;</span>,<span class="string">&quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.brown.fox&quot;</span>,<span class="string">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.male.rabbit&quot;</span>,<span class="string">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.orange.male.rabbit&quot;</span>,<span class="string">&quot;是四个单词但匹配 Q2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者 ReceiveLogsTopic01</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 声明主题交换机及相关队列</span></span><br><span class="line"><span class="comment"> * 消费者 C1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 13:18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;Q1&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息......&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;接收队列：&quot;</span> + queueName + <span class="string">&quot;    绑定键：&quot;</span> + message.getEnvelope().getRoutingKey());</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者 ReceiveLogsTopic02</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 声明主题交换机及相关队列</span></span><br><span class="line"><span class="comment"> * 消费者 C2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 13:18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;Q2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息......&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;接收队列：&quot;</span> + queueName + <span class="string">&quot;    绑定键：&quot;</span> + message.getEnvelope().getRoutingKey());</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-6-5-实战结果"><a href="#5-6-5-实战结果" class="headerlink" title="5.6.5 实战结果"></a>5.6.5 实战结果</h4><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061523899.png" alt="image-20230206152253327" style="zoom: 80%;" />

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061523044.png" alt="image-20230206152331685" style="zoom:80%;" />

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061524085.png" alt="image-20230206152357134" style="zoom:80%;" />

<h2 id="6-死信队列"><a href="#6-死信队列" class="headerlink" title="6.死信队列"></a>6.死信队列</h2><h3 id="6-1-死信的概念"><a href="#6-1-死信的概念" class="headerlink" title="6.1 死信的概念"></a>6.1 死信的概念</h3><p>​		先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候<strong>由于特定的原因导致 queue 中的某些消息无法被消费</strong>，这样的消息如果没有 后续的处理，就变成了死信，有死信自然就有了死信队列。</p>
<p>​		应用场景:为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息 消费发生异常时，将消息投入死信队列中.还有比如说: 用户在商城下单成功并点击去支付后在指定时 间未支付时自动失效</p>
<h3 id="6-2-死信的来源"><a href="#6-2-死信的来源" class="headerlink" title="6.2 死信的来源"></a>6.2 死信的来源</h3><ul>
<li>消息 TTL 过期</li>
<li>队列达到最大长度(队列满了，无法再添加数据到 mq 中)</li>
<li>消息被拒绝(basic.reject 或 basic.nack)并且 requeue&#x3D;false</li>
</ul>
<h3 id="6-3-死信实战"><a href="#6-3-死信实战" class="headerlink" title="6.3 死信实战"></a>6.3 死信实战</h3><h4 id="6-3-1-代码架构图"><a href="#6-3-1-代码架构图" class="headerlink" title="6.3.1 代码架构图"></a>6.3.1 代码架构图</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062010451.png" alt="image-20230206201046563"></p>
<h4 id="6-3-2-消息-TTL-过期"><a href="#6-3-2-消息-TTL-过期" class="headerlink" title="6.3.2 消息 TTL 过期"></a>6.3.2 消息 TTL 过期</h4><p>生产者代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 死信队列之生产者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 16:59</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadQueueProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 死信消息 设置 TTL 时间 time to live 单位是 ms 1000ms = 10s</span></span><br><span class="line">        AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties()</span><br><span class="line">                        .builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, properties, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者 C1 代码(<strong>启动之后关闭该消费者 模拟其接收不到消息</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 19:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest01</span> &#123;</span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//死信队列绑定死信交换机与 routingkey</span></span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">normalQueue</span> <span class="operator">=</span> <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(normalQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(normalQueue, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者未发消息</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062017485.png" alt="image-20230206201726068"></p>
<p><strong>关闭该消费者 模拟其接收不到消息，</strong>生产者发送了 10 条消息 此时正常消息队列有 10 条未消费消息</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062019755.png" alt="image-20230206201902124"></p>
<p>时间过去 10 秒正常队列里面的消息由于没有被消费 消息进入死信队列</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062020450.png" alt="image-20230206202022049"></p>
<p>消费者 C2 代码(<strong>以上步骤完成后 启动 C2 消费者 它消费死信队列里面的消息</strong>) </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消费者 2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 19:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收死信队列消息.....&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer02 接收死信队列的消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(deadQueue, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062028996.png" alt="image-20230206202810630"></p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062029507.png" alt="image-20230206202853014" style="zoom:80%;" />

<h4 id="6-3-3-队列达到最大长度"><a href="#6-3-3-队列达到最大长度" class="headerlink" title="6.3.3 队列达到最大长度"></a>6.3.3 队列达到最大长度</h4><ol>
<li>消息生产者代码去掉 TTL 属性<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 死信队列之生产者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 16:59</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadQueueProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 死信消息 设置 TTL 时间 time to live 单位是 ms 1000ms = 10s</span></span><br><span class="line">        <span class="comment">//AMQP.BasicProperties properties =</span></span><br><span class="line">        <span class="comment">//        new AMQP.BasicProperties()</span></span><br><span class="line">        <span class="comment">//                .builder().expiration(&quot;10000&quot;).build();</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062040910.png" alt="image-20230206204034841"></p>
<ol start="2">
<li>C1 消费者修改以下代码(<strong>启动之后关闭该消费者 模拟其接收不到消息</strong>)</li>
</ol>
<p>​		主要是修改一下代码<br>​		<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062043693.png" alt="image-20230206204318136" style="zoom: 80%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消费者 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 19:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest01</span> &#123;</span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//死信队列绑定死信交换机与 routingkey</span></span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置正常队列的长度的限制</span></span><br><span class="line">        params.put(<span class="string">&quot;x-max-length&quot;</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">normalQueue</span> <span class="operator">=</span> <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(normalQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(normalQueue, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意此时需要把原先队列删除 因为参数改变了</strong></p>
<ol start="3">
<li>C2 消费者不变，直接启动即可<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062046744.png" alt="image-20230206204541411"></li>
</ol>
<p>​		<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062046084.png" alt="image-20230206204628773"></p>
<h4 id="6-3-4-消息被拒"><a href="#6-3-4-消息被拒" class="headerlink" title="6.3.4 消息被拒"></a>6.3.4 消息被拒</h4><p>1.消息生产者代码同上生产者一致 </p>
<p>2.C1 消费者代码(<strong>启动之后关闭该消费者 模拟其接收不到消息</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消费者 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 19:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest01</span> &#123;</span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//死信队列绑定死信交换机与 routingkey</span></span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置正常队列的长度的限制</span></span><br><span class="line">        <span class="comment">//params.put(&quot;x-max-length&quot;, 6);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">normalQueue</span> <span class="operator">=</span> <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(normalQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;info5&quot;</span>.equals(message))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message + <span class="string">&quot;此消息是被 C1 拒绝的&quot;</span>);</span><br><span class="line">                channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span>+message);</span><br><span class="line">                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 开启手动应答</span></span><br><span class="line">        channel.basicConsume(normalQueue, <span class="literal">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动消费者 C1 ，启动生产者发送消息；有一条消息未被消费</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062108663.png" alt="image-20230206210828079"></p>
<p>启动 C2 消费死信队列</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062109067.png" alt="image-20230206210949858"></p>
<h2 id="7-延迟队列"><a href="#7-延迟队列" class="headerlink" title="7.延迟队列"></a>7.延迟队列</h2><h3 id="7-1-延迟队列的概念"><a href="#7-1-延迟队列的概念" class="headerlink" title="7.1 延迟队列的概念"></a>7.1 延迟队列的概念</h3><p>​		延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。</p>
<h3 id="7-2-延迟队列使用场景"><a href="#7-2-延迟队列使用场景" class="headerlink" title="7.2 延迟队列使用场景"></a>7.2 延迟队列使用场景</h3><ol>
<li>订单在十分钟之内未支付则自动取消</li>
<li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。 </li>
<li>用户注册成功后，如果三天内没有登陆则进行短信提醒。 </li>
<li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。 </li>
<li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li>
</ol>
<p>​		这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎 使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果 数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支 付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十 分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万 级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单 的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081157842.png" alt="image-20230208115734612"></p>
<h3 id="7-3-RabbitMQ-中的-TTL"><a href="#7-3-RabbitMQ-中的-TTL" class="headerlink" title="7.3 RabbitMQ 中的 TTL"></a>7.3 RabbitMQ 中的 TTL</h3><p>​		TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有 消息的最大存活时间，</p>
<p>​		单位是毫秒。换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这 条消息如果在 TTL 设置的时间内没有被消费，则会成为”死信”。如果同时配置了队列的 TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p>
<h3 id="7-4-整合-springboot"><a href="#7-4-整合-springboot" class="headerlink" title="7.4 整合 springboot"></a>7.4 整合 springboot</h3><h4 id="7-4-1-创建项目"><a href="#7-4-1-创建项目" class="headerlink" title="7.4.1 创建项目"></a>7.4.1 创建项目</h4><ol>
<li>创建 spring initializr<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081200689.png" alt="image-20230208120020531"></li>
</ol>
<h4 id="7-4-2添加依赖"><a href="#7-4-2添加依赖" class="headerlink" title="7.4.2添加依赖"></a>7.4.2添加依赖</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!--RabbitMQ 依赖--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;<span class="number">1.2</span><span class="number">.47</span>&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!--swagger--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!--RabbitMQ 测试依赖--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-3-修改配置文件"><a href="#7-4-3-修改配置文件" class="headerlink" title="7.4.3 修改配置文件"></a>7.4.3 修改配置文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: admin</span><br><span class="line">    password: <span class="number">123</span></span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">8088</span></span><br></pre></td></tr></table></figure>

<h4 id="7-4-4-添加-Swagger-配置类"><a href="#7-4-4-添加-Swagger-配置类" class="headerlink" title="7.4.4 添加 Swagger 配置类"></a>7.4.4 添加 Swagger 配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mofeng.rabbitmq.springbootrabbitmq.config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="keyword">public</span> Docket <span class="title function_">webApiConfig</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line"> .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line"> .apiInfo(webApiInfo())</span><br><span class="line"> .select()</span><br><span class="line"> .build();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">private</span> ApiInfo <span class="title function_">webApiInfo</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line"> .title(<span class="string">&quot;rabbitmq 接口文档&quot;</span>)</span><br><span class="line"> .description(<span class="string">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)</span><br><span class="line"> .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line"> .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;enjoy6288&quot;</span>, <span class="string">&quot;inkmaple.xyz&quot;</span>, </span><br><span class="line"><span class="string">&quot;2435301806@qq.com&quot;</span>))</span><br><span class="line"> .build();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-5-队列-TTL"><a href="#7-5-队列-TTL" class="headerlink" title="7.5 队列 TTL"></a>7.5 队列 TTL</h3><h4 id="7-5-1-代码结构图"><a href="#7-5-1-代码结构图" class="headerlink" title="7.5.1 代码结构图"></a>7.5.1 代码结构图</h4><p>​		创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交 换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081233133.png" alt="image-20230208123334952"></p>
<h4 id="7-5-2-配置文件类代码"><a href="#7-5-2-配置文件类代码" class="headerlink" title="7.5.2 配置文件类代码"></a>7.5.2 配置文件类代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TTL 队列 配置文件类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 12:34</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlQueueConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">X_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_A</span> <span class="operator">=</span> <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_B</span> <span class="operator">=</span> <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;QD&quot;</span>;</span><br><span class="line">    <span class="comment">// 声明 xExchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">xExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(X_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明 xExchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">yExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明队列 A ttl 为 10s 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//声明队列的 TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明队列 A 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueaBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明队列 B ttl 为 40s 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//声明队列的 TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">40000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明队列 B 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queuebBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queue1B,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue1B).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明死信队列 QD</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueD</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DEAD_LETTER_QUEUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明死信队列 QD 绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">deadLetterBindingQAD</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span></span><br><span class="line"><span class="params">                                        <span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="7-5-3-消息生产者代码"><a href="#7-5-3-消息生产者代码" class="headerlink" title="7.5.3 消息生产者代码"></a>7.5.3 消息生产者代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 发送延迟消息</span></span><br><span class="line"><span class="comment"> * http://localhost:8080/ttl/sendMsg/嘻嘻嘻</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 13:05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMsgController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始发消息</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;, 发送一条信息给两个 TTL 队列：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot;消息来自 TTL 为 10s 的队列：&quot;</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;消息来自 TTL 为 40s 的队列：&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-5-4-消息消费者代码"><a href="#7-5-4-消息消费者代码" class="headerlink" title="7.5.4 消息消费者代码"></a>7.5.4 消息消费者代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 队列 TTL 的消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 13:14</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterQueueConsumer</span> &#123;</span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到死信队列信息&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="7-5-5-启动类失败"><a href="#7-5-5-启动类失败" class="headerlink" title="7.5.5 启动类失败"></a>7.5.5 启动类失败</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081343513.png" alt="image-20230208134356194"></p>
<p><strong>解决方案：在启动类添加注解 @EnableWebMvc</strong></p>
<h4 id="7-5-6-发送消息报错"><a href="#7-5-6-发送消息报错" class="headerlink" title="7.5.6 发送消息报错"></a>7.5.6 发送消息报错</h4><p>发送<a href="http://localhost:8088/ttl/sendMsg/xxx">http://localhost:8088/ttl/sendMsg/xxx</a></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081347300.png" alt="image-20230208134739893"></p>
<p>检查 controller 类的 Mapping 是否正确</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span></span><br></pre></td></tr></table></figure>

<h4 id="7-5-7-Channel-导包错误"><a href="#7-5-7-Channel-导包错误" class="headerlink" title="7.5.7 Channel 导包错误"></a>7.5.7 Channel 导包错误</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081402510.png" alt="image-20230208140219774"></p>
<p>错误的包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.channels.Channel;</span><br></pre></td></tr></table></figure>

<p>导入正确的包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br></pre></td></tr></table></figure>

<h4 id="7-5-8-结果展示"><a href="#7-5-8-结果展示" class="headerlink" title="7.5.8 结果展示"></a>7.5.8 结果展示</h4><p>10s 和 40s 后会在控制台输出结果</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081406242.png" alt="image-20230208140621305"></p>
<p>​		第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。</p>
<p>​		不过，如果这样使用的话，岂不是<strong>每增加一个新的时间需求，就要新增一个队列</strong>，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然 后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p>
<h3 id="7-6-延时队列优化"><a href="#7-6-延时队列优化" class="headerlink" title="7.6 延时队列优化"></a>7.6 延时队列优化</h3><h4 id="7-6-1-代码架构图"><a href="#7-6-1-代码架构图" class="headerlink" title="7.6.1 代码架构图"></a>7.6.1 代码架构图</h4><p>​		在这里新增了一个队列 QC,绑定关系如下,该队列不设置 TTL 时间</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081636571.png" alt="image-20230208163609478"></p>
<h4 id="7-6-2-配置文件类添加代码"><a href="#7-6-2-配置文件类添加代码" class="headerlink" title="7.6.2 配置文件类添加代码"></a>7.6.2 配置文件类添加代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgTtlQueueConfig</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_C</span> <span class="operator">=</span> <span class="string">&quot;QC&quot;</span>;</span><br><span class="line"> <span class="comment">//声明队列 C 死信交换机</span></span><br><span class="line"> <span class="meta">@Bean(&quot;queueC&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span>&#123;</span><br><span class="line"> Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"> <span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line"> args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line"> <span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line"> args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line"> <span class="comment">//没有声明 TTL 属性</span></span><br><span class="line"> <span class="keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(args).build();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//声明队列 B 绑定 X 交换机</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="keyword">public</span> Binding <span class="title function_">queuecBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span></span><br><span class="line"><span class="params"> <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-6-3-消息生产者添加代码"><a href="#7-6-3-消息生产者添加代码" class="headerlink" title="7.6.3 消息生产者添加代码"></a>7.6.3 消息生产者添加代码</h4><p>在控制类中添加 sendMsg 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message,<span class="meta">@PathVariable</span> String ttlTime)</span> &#123;</span><br><span class="line"> rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, message, correlationData -&gt;&#123;</span><br><span class="line"> correlationData.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line"> <span class="keyword">return</span> correlationData;</span><br><span class="line"> &#125;);</span><br><span class="line"> log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒 TTL 信息给队列 C:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(),ttlTime, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发起请求 </p>
<ul>
<li><p><a href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendExpirationMsg/你好</a> 1&#x2F;20000 </p>
</li>
<li><p><a href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendExpirationMsg/你好</a> 2&#x2F;2000</p>
</li>
</ul>
<p>控制台输出结果</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081646330.png" alt="image-20230208164611943"></p>
<p>​		看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消 息可能并不会按时“死亡“，因为 <strong>RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。</strong></p>
<p>​		<strong>队列中，实行先进先出的原则</strong></p>
<h3 id="7-7-RabbitMQ-插件实现延迟队列"><a href="#7-7-RabbitMQ-插件实现延迟队列" class="headerlink" title="7.7 RabbitMQ 插件实现延迟队列"></a>7.7 RabbitMQ 插件实现延迟队列</h3><p>​		上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的 TTL 时间 及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。</p>
<h4 id="7-7-1-安装延时队列插件"><a href="#7-7-1-安装延时队列插件" class="headerlink" title="7.7.1 安装延时队列插件"></a>7.7.1 安装延时队列插件</h4><p>官网下载 <a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></p>
<p>下载 rabbitmq_delayed_message_exchange 插件，然后解压放置到 RabbitMQ 的插件目录。</p>
<p>参考下载和安装文章：<a href="https://blog.csdn.net/u010404909/article/details/125329160">https://blog.csdn.net/u010404909/article/details/125329160</a></p>
<ol>
<li>下载</li>
</ol>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081704718.png" alt="image-20230208170412118"></p>
<ol start="2">
<li>下载之后上传到 plugins 目录下</li>
</ol>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081708179.png" alt="image-20230208170850734"></p>
<ol start="3">
<li>进入 rabbitmq 的插件目录</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd /usr/lib/rabbitmq/lib/rabbitmq_server-<span class="number">3.8</span><span class="number">.8</span>/plugins</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>安裝</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>重启 RabbitMQ</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>重启之后在 RabbitMQ 控制后台如下显示即可</li>
</ol>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081711108.png" alt="image-20230208171155972"></p>
<h4 id="7-7-2-代码架构图"><a href="#7-7-2-代码架构图" class="headerlink" title="7.7.2 代码架构图"></a>7.7.2 代码架构图</h4><p>​		在这里新增了一个队列 delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下:</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302082121961.png" alt="image-20230208212145760"></p>
<h4 id="7-7-3-配置文件类-DelayedQueueConfig"><a href="#7-7-3-配置文件类-DelayedQueueConfig" class="headerlink" title="7.7.3 配置文件类 DelayedQueueConfig"></a>7.7.3 配置文件类 DelayedQueueConfig</h4><p>​		在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制 消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才 投递到目标队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayedQueueConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DELAYED_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义交换机 我们在这里定义的是一个延迟交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomExchange <span class="title function_">delayedExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//自定义交换机的类型</span></span><br><span class="line">        args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>,</span><br><span class="line">                args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDelayedQueue</span><span class="params">(<span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange</span></span><br><span class="line"><span class="params">                                               delayedExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">                BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-7-4-消息生产者代码"><a href="#7-7-4-消息生产者代码" class="headerlink" title="7.7.4 消息生产者代码"></a>7.7.4 消息生产者代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line"><span class="comment">// 基于插件的 开始发消息 消息 以及 延迟的时间</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> Integer delayTime)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;, 发送一条时长 &#123;&#125; 毫秒 信息给延迟队列delayed.queue ：&#123;&#125;&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), delayTime, message);</span><br><span class="line">        rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME, DelayedQueueConfig.DELAYED_ROUTING_KEY, message, msg -&gt;&#123;</span><br><span class="line">            <span class="comment">// 发送消息的时候 延长时长 单位是 ms</span></span><br><span class="line">            msg.getMessageProperties().setDelay(delayTime);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-7-5-消息消费者代码"><a href="#7-7-5-消息消费者代码" class="headerlink" title="7.7.5 消息消费者代码"></a>7.7.5 消息消费者代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 基于的插件延迟消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 21:03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueueConsumer</span> &#123;</span><br><span class="line">    <span class="comment">// 监听消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DelayedQueueConfig.DELAYED_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDelayQueue</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;， 收到延迟队列的消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-7-6-结果展示"><a href="#7-7-6-结果展示" class="headerlink" title="7.7.6 结果展示"></a>7.7.6 结果展示</h4><p>发送请求：</p>
<ul>
<li><a href="http://localhost:8080/ttl/sendDelayMsg/come">http://localhost:8080/ttl/sendDelayMsg/come</a> on baby1&#x2F;20000</li>
<li><a href="http://localhost:8080/ttl/sendDelayMsg/come">http://localhost:8080/ttl/sendDelayMsg/come</a> on baby2&#x2F;2000</li>
</ul>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302082126200.png" alt="image-20230208212615797"></p>
<p>第二个消息被消费掉，复合预期</p>
<h3 id="7-8-总结"><a href="#7-8-总结" class="headerlink" title="7.8 总结"></a>7.8 总结</h3><p>​		延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正 确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。</p>
<p>​		当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景</p>
<h2 id="8-发布确认高级"><a href="#8-发布确认高级" class="headerlink" title="8.发布确认高级"></a>8.发布确认高级</h2><p>​		在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？ 特别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">应 用 [xxx] 在 [08-<span class="number">1516</span>:<span class="number">36</span>:<span class="number">04</span>] 发 生 [ 错误日志异常 ] ， alertId=[xxx] 。 由</span><br><span class="line">[org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:<span class="number">620</span>] 触发。 </span><br><span class="line">应用 xxx 可能原因如下</span><br><span class="line">服务名为： </span><br><span class="line">异常为： org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:<span class="number">620</span>, </span><br><span class="line">产 生 原 因 如 下 :<span class="number">1.</span>org.springframework.amqp.rabbit.listener.QueuesNotAvailableException: </span><br><span class="line">Cannot prepare queue <span class="keyword">for</span> listener. Either the queue doesn<span class="string">&#x27;t exist or the broker will not </span></span><br><span class="line"><span class="string">allow us to use it.||Consumer received fatal=false exception on startup:</span></span><br></pre></td></tr></table></figure>

<h3 id="8-1-发布确认-springboot-版本"><a href="#8-1-发布确认-springboot-版本" class="headerlink" title="8.1 发布确认 springboot 版本"></a>8.1 发布确认 springboot 版本</h3><h4 id="8-1-1-确认机制方案"><a href="#8-1-1-确认机制方案" class="headerlink" title="8.1.1 确认机制方案"></a>8.1.1 确认机制方案</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302082241533.png" alt="image-20230208224129404"></p>
<h4 id="8-1-2-代码架构图"><a href="#8-1-2-代码架构图" class="headerlink" title="8.1.2 代码架构图"></a>8.1.2 代码架构图</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302082242563.png" alt="image-20230208224247445"></p>
<h4 id="8-1-3-配置文件"><a href="#8-1-3-配置文件" class="headerlink" title="8.1.3 配置文件"></a>8.1.3 配置文件</h4><p>在 application.yml 配置文件中添加</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br></pre></td></tr></table></figure>

<p>publisher-confirm-type 有三种值：</p>
<ul>
<li>NONE ：禁用发布确认模式，是默认值</li>
<li>CORRELATED ：发布消息成功到交换器后会触发回调方法</li>
<li>SIMPLE</li>
</ul>
<p>​		经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法， </p>
<p>​		其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法 等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，<strong>要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker</strong></p>
<h4 id="8-1-4-添加配置类"><a href="#8-1-4-添加配置类" class="headerlink" title="8.1.4 添加配置类"></a>8.1.4 添加配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 配置类 发布确认（高级）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 22:13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// routingKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;key1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBindingExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue,</span></span><br><span class="line"><span class="params">                                        <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1-5-消息生产者"><a href="#8-1-5-消息生产者" class="headerlink" title="8.1.5 消息生产者"></a>8.1.5 消息生产者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 开始发消息 测试确认</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 22:30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;sendMessage/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">                ConfirmConfig.CONFIRM_ROUTING_KEY, message + <span class="string">&quot;key1&quot;</span>, correlationData1);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息内容：&#123;&#125;&quot;</span>, message + <span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">                ConfirmConfig.CONFIRM_ROUTING_KEY + <span class="string">&quot;2&quot;</span>, message + <span class="string">&quot;key12&quot;</span>, correlationData2);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息内容：&#123;&#125;&quot;</span>, message + <span class="string">&quot;key2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1-6-回调接口"><a href="#8-1-6-回调接口" class="headerlink" title="8.1.6 回调接口"></a>8.1.6 回调接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 回调接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 22:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 注入</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机确认回调方法</span></span><br><span class="line"><span class="comment">     * 1.发消息 交换机接收到了 回调</span></span><br><span class="line"><span class="comment">     *  1.1 correlationData 保存回调消息的 ID 及相关信息</span></span><br><span class="line"><span class="comment">     *  1.2 交换机收到消息 ack = true</span></span><br><span class="line"><span class="comment">     * 2.发消息 交换机接收失败了 回调</span></span><br><span class="line"><span class="comment">     *  2.1 correlationData 保存回调消息的 ID 及相关信息</span></span><br><span class="line"><span class="comment">     *  2.2 交换机收到消息 ack = false</span></span><br><span class="line"><span class="comment">     *  2.3 cause 引起失败的原因</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机已经收到 Id 为：&#123;&#125; 的消息&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机还未收到 Id 为：&#123;&#125; 的消息，原因为：&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1-7-消息消费者"><a href="#8-1-7-消息消费者" class="headerlink" title="8.1.7 消息消费者"></a>8.1.7 消息消费者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 接收消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 22:34</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.CONFIRM_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfirmMessage</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接受到的队列 confirm.queue 消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-1-8-结果分析"><a href="#8-1-8-结果分析" class="headerlink" title="8.1.8 结果分析"></a>8.1.8 结果分析</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302091338917.png" alt="image-20230209133818410"></p>
<p>上图结果显示，发送了两条消息，第一条消息是 routingKey 为 “key1”,第二条消息是 routingKey 为 “key2”,两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为 第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条 消息被直接丢弃了。</p>
<h3 id="8-2-回退消息"><a href="#8-2-回退消息" class="headerlink" title="8.2 回退消息"></a>8.2 回退消息</h3><h4 id="8-2-1-Mandatory-参数"><a href="#8-2-1-Mandatory-参数" class="headerlink" title="8.2.1 Mandatory 参数"></a>8.2.1 Mandatory 参数</h4><p>​		<strong>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如 果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。</strong>那么如何 让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参 数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p>
<h4 id="8-2-2-application-yml-添加"><a href="#8-2-2-application-yml-添加" class="headerlink" title="8.2.2 application.yml 添加"></a>8.2.2 application.yml 添加</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="8-2-3-回调接口"><a href="#8-2-3-回调接口" class="headerlink" title="8.2.3 回调接口"></a>8.2.3 回调接口</h4><p>设置回调接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rabbitTemplate.setReturnsCallback(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<p>重写 returnedMessage 方法，具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 回调接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 22:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback, RabbitTemplate.ReturnsCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 注入</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机确认回调方法</span></span><br><span class="line"><span class="comment">     * 1.发消息 交换机接收到了 回调</span></span><br><span class="line"><span class="comment">     *  1.1 correlationData 保存回调消息的 ID 及相关信息</span></span><br><span class="line"><span class="comment">     *  1.2 交换机收到消息 ack = true</span></span><br><span class="line"><span class="comment">     * 2.发消息 交换机接收失败了 回调</span></span><br><span class="line"><span class="comment">     *  2.1 correlationData 保存回调消息的 ID 及相关信息</span></span><br><span class="line"><span class="comment">     *  2.2 交换机收到消息 ack = false</span></span><br><span class="line"><span class="comment">     *  2.3 cause 引起失败的原因</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机已经收到 Id 为：&#123;&#125; 的消息&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机还未收到 Id 为：&#123;&#125; 的消息，原因为：&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有消息到达不了目的地的时候， 才进行回退</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;消息 &#123;&#125;， 被交换机 &#123;&#125; 退回， 退回原因：&#123;&#125;， 路由 key ：&#123;&#125;&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>(returned.getMessage().getBody()),</span><br><span class="line">                returned.getExchange(), returned.getReplyText(), returned.getRoutingKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-4-结果"><a href="#8-2-4-结果" class="headerlink" title="8.2.4 结果"></a>8.2.4 结果</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302091421109.png" alt="image-20230209142155747"></p>
<h3 id="8-3-备份交换机"><a href="#8-3-备份交换机" class="headerlink" title="8.3 备份交换机"></a>8.3 备份交换机</h3><p>​		有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息 无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然 后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者 所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增 加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的 复杂性，该怎么做呢？前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些 处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。什么是备份交换机呢？备份 交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时， 就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由 备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑 定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都 进入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</p>
<h4 id="8-3-1-代码架构图"><a href="#8-3-1-代码架构图" class="headerlink" title="8.3.1 代码架构图"></a>8.3.1 代码架构图</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302091453657.png" alt="image-20230209145343572"></p>
<h4 id="8-3-2-修改配置类-ConfirmConfig"><a href="#8-3-2-修改配置类-ConfirmConfig" class="headerlink" title="8.3.2 修改配置类 ConfirmConfig"></a>8.3.2 修改配置类 ConfirmConfig</h4><ul>
<li>主要是声明和绑定备份交换机、备份队列和报警队列</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 配置类 发布确认（高级）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 22:13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// routingKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;key1&quot;</span>;</span><br><span class="line">    <span class="comment">// 备份交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;backup_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 备份队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;backup_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 报警队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WARNING_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;warning_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)</span><br><span class="line">                .durable(<span class="literal">true</span>).withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBindingExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue,</span></span><br><span class="line"><span class="params">                                        <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备份交换机创建</span></span><br><span class="line">    <span class="meta">@Bean(&quot;backupExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">BackupExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(BACKUP_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 备份队列创建</span></span><br><span class="line">    <span class="meta">@Bean(&quot;backupQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">backupQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 报警队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;warningQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">warningQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 备份交换机绑定备份队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">backupQueueBindingBackupExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;backupQueue&quot;)</span> Queue backupQueue,</span></span><br><span class="line"><span class="params">                                        <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(backupQueue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备份交换机绑定报警队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">warningQueueBindingBackupExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue warningQueue,</span></span><br><span class="line"><span class="params">                                                    <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(warningQueue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-3-3-报警消费者-WarningConsumer"><a href="#8-3-3-报警消费者-WarningConsumer" class="headerlink" title="8.3.3 报警消费者 WarningConsumer"></a>8.3.3 报警消费者 WarningConsumer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 报警消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/9 14:44</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarningConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收报警消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.WARNING_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveWarningMsg</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;报警发现不可路由消息： &#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-3-4-测试注意事项"><a href="#8-3-4-测试注意事项" class="headerlink" title="8.3.4 测试注意事项"></a>8.3.4 测试注意事项</h4><p>重新启动项目的时候需要把原来的 confirm.exchange 删除因为我们修改了其绑定属性，不然报以下错:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">inequivalent arg <span class="string">&#x27;alternate-exchange&#x27;</span><span class="keyword">for</span> exchange <span class="string">&#x27;confirm.exchange&#x27;</span>in vhost <span class="string">&#x27;/</span></span><br><span class="line"><span class="string">inequivalent arg &#x27;</span>alternate-exchange<span class="string">&#x27;for exchange &#x27;</span>confirm.exchange<span class="string">&#x27;in vhost &#x27;</span>/<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="8-3-5-结果分析"><a href="#8-3-5-结果分析" class="headerlink" title="8.3.5 结果分析"></a>8.3.5 结果分析</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302091457828.png" alt="image-20230209145728615"></p>
<p>​		mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先 级高，经过上面结果显示答案是<strong>备份交换机优先级高。</strong></p>
<h2 id="9-RabbitMQ-其他知识点"><a href="#9-RabbitMQ-其他知识点" class="headerlink" title="9. RabbitMQ 其他知识点"></a>9. RabbitMQ 其他知识点</h2><h3 id="9-1-幂等性"><a href="#9-1-幂等性" class="headerlink" title="9.1 幂等性"></a>9.1 幂等性</h3><h4 id="9-1-1-概念"><a href="#9-1-1-概念" class="headerlink" title="9.1.1 概念"></a>9.1.1 概念</h4><p>​		用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误 立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等</p>
<h4 id="9-1-2-消息重复消费"><a href="#9-1-2-消息重复消费" class="headerlink" title="9.1.2 消息重复消费"></a>9.1.2 消息重复消费</h4><p>​		消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但 实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p>
<h4 id="9-1-3-解决思路"><a href="#9-1-3-解决思路" class="headerlink" title="9.1.3 解决思路"></a>9.1.3 解决思路</h4><p>​		MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消 息时用该 id 先判断该消息是否已消费过。</p>
<h4 id="9-1-4-消费端的幂等性保障"><a href="#9-1-4-消费端的幂等性保障" class="headerlink" title="9.1.4 消费端的幂等性保障"></a>9.1.4 消费端的幂等性保障</h4><p>​		在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。业界主流的幂等性有两种操作:a. 唯一 ID+指纹码机制,利用数据库主键去重, b.利用 redis 的原子性去实现</p>
<h4 id="9-1-5-唯一-ID-指纹码机制"><a href="#9-1-5-唯一-ID-指纹码机制" class="headerlink" title="9.1.5 唯一 ID + 指纹码机制"></a>9.1.5 唯一 ID + 指纹码机制</h4><p>​		指纹码:我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存 在数据库中,优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数 据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</p>
<h4 id="9-1-6-Redis-原子性"><a href="#9-1-6-Redis-原子性" class="headerlink" title="9.1.6 Redis 原子性"></a>9.1.6 Redis 原子性</h4><p>​		利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费</p>
<h3 id="9-2-优先队列"><a href="#9-2-优先队列" class="headerlink" title="9.2 优先队列"></a>9.2 优先队列</h3><h4 id="9-2-1-使用场景"><a href="#9-2-1-使用场景" class="headerlink" title="9.2.1 使用场景"></a>9.2.1 使用场景</h4><p>​		在我们系统中有一个<strong>订单催付</strong>的场景，我们的客户在天猫下的订单,淘宝会及时将订单推送给我们，如 果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创 造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存 放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景， 所以订单量大了后采用 RabbitMQ 进行改造和优化,如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。</p>
<h4 id="9-2-2-如何添加优先队列"><a href="#9-2-2-如何添加优先队列" class="headerlink" title="9.2.2 如何添加优先队列"></a>9.2.2 如何添加优先队列</h4><ul>
<li><p>方法一：在控制台<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302091545995.png" alt="image-20230209154459351"></p>
</li>
<li><p>队列中代码添加优先级</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 官方允许是 0-255 之间 此处允许优先级的范围设置为  0-10 设置太大会浪费 CPU 和内存</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, arguments);</span><br></pre></td></tr></table></figure>

<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302091601764.png" alt="image-20230209160115369"></p>
</li>
<li><p>消息中代码添加优先级</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项：<br>要让队列实现优先级需要做的事情有如下事情:<strong>队列需要设置为优先级队列，消息需要设置消息的优先 级，消费者需要等待消息已经发送到队列中才去消费，因为这样才有机会对消息进行排序</strong></p>
</li>
</ul>
<h4 id="9-2-3-优先队列实战"><a href="#9-2-3-优先队列实战" class="headerlink" title="9.2.3 优先队列实战"></a>9.2.3 优先队列实战</h4><ol>
<li><p>消息生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * <span class="meta">@Description</span>: 生产者：发送消息</span><br><span class="line"> * <span class="meta">@Author</span>: mofeng</span><br><span class="line"> * <span class="meta">@DateTime</span>: <span class="number">2023</span>/<span class="number">1</span>/<span class="number">15</span> <span class="number">12</span>:<span class="number">07</span></span><br><span class="line"> **/</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RABBITMQ_HOST</span> <span class="operator">=</span> <span class="string">&quot;43.139.46.240&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 工厂 IP 连接 RabbitMQ 的队列</span></span><br><span class="line">        connectionFactory.setHost(RABBITMQ_HOST);</span><br><span class="line">        <span class="comment">// 用户名</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 密码</span></span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">// 获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.队列里面的消息是否持久化（磁盘） 默认情况下消息存储在内存中</span></span><br><span class="line"><span class="comment">         * 3.该队列是否只供一个消费者消费，是否进行消息共享，true: 多个消费者消费 flase: 只能一个消费者消费</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除，最后一个消费者端开连接以后 该队列是否自动删除，true 自动删除 false 不自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 官方允许是 0-255 之间 此处允许优先级的范围设置为  0-10 设置太大会浪费 CPU 和内存</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, arguments);</span><br><span class="line">        <span class="comment">// 发消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME, properties, message.getBytes());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消费</span></span><br><span class="line"><span class="comment">         * 1.发送到哪个交换机</span></span><br><span class="line"><span class="comment">         * 2.路由的 key 值是哪个 本次队列的名称</span></span><br><span class="line"><span class="comment">         * 3.其他参数信息</span></span><br><span class="line"><span class="comment">         * 4.发送消息的本体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//channel.basicPublish(&quot;&quot;,QUEUE_NAME, null, message.getBytes());</span></span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消费者 接受消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/1/15 14:19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RABBITMQ_HOST</span> <span class="operator">=</span> <span class="string">&quot;43.139.46.240&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 工厂 IP 连接 RabbitMQ 的队列</span></span><br><span class="line">        connectionFactory.setHost(RABBITMQ_HOST);</span><br><span class="line">        <span class="comment">// 用户名</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 密码</span></span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">// 获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消消息时的回调</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断！！&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费者消费</span></span><br><span class="line"><span class="comment">         * 1.消费哪个队列</span></span><br><span class="line"><span class="comment">         * 2.消费成功后是否需要自动应答 true 代表自动应答 false 代表手动应答</span></span><br><span class="line"><span class="comment">         * 3.消费者未成功消费的回调</span></span><br><span class="line"><span class="comment">         * 4.消费者取录消费的回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302091600334.png" alt="image-20230209160006737"></p>
<h3 id="9-3-惰性队列"><a href="#9-3-惰性队列" class="headerlink" title="9.3 惰性队列"></a>9.3 惰性队列</h3><h4 id="9-3-1-使用场景"><a href="#9-3-1-使用场景" class="headerlink" title="9.3.1 使用场景"></a>9.3.1 使用场景</h4><p>​		RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致 使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p>
<p>​		默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中， 这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留 一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候</p>
<h4 id="9-3-2-两种模式"><a href="#9-3-2-两种模式" class="headerlink" title="9.3.2 两种模式"></a>9.3.2 两种模式</h4><p>​		队列具备两种模式：<strong>default 和 lazy。</strong><br>​		默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。 如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p>
<p>在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示 例中演示了一个惰性队列的声明细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br></pre></td></tr></table></figure>

<h4 id="9-3-3-内存开销对比"><a href="#9-3-3-内存开销对比" class="headerlink" title="9.3.3 内存开销对比"></a>9.3.3 内存开销对比</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302091611857.png" alt="image-20230209161131829"></p>
<p>​		在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅 占用 1.5MB</p>
]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>读《霍乱时期的爱情》</title>
    <url>/2023/04/12/%E8%AF%BB%E3%80%8A%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85%E3%80%8B/</url>
    <content><![CDATA[<h1 id="读马尔克斯的《霍乱时期的爱情》"><a href="#读马尔克斯的《霍乱时期的爱情》" class="headerlink" title="读马尔克斯的《霍乱时期的爱情》"></a>读马尔克斯的《霍乱时期的爱情》</h1><p>这场跨越半个世纪的悲欢离合，少年时的悸动，暮年时的相互依靠。中间历经千辛万苦，最后一起旅行，享受了一段短暂的美好时光。</p>
<p>惊叹于马尔克斯叙述语言的魅力，那无尽的赞美和无情的诅咒，一个个小故事来丰富情节。</p>
<p>弗洛伦蒂诺·阿里萨可以说是一个一穷二白的年轻人，而洛伦索·达萨想让他女儿将来能嫁给名门贵族，所以洛伦索·达萨需要拆散他们，企图向他女儿的舅舅寻求帮助时，不曾想他年轻的时候为了娶到现在的妻子，也曾是弗洛伦蒂诺·阿里萨现在的处境。马尔克斯用极具讽刺的手法，描述了洛伦索·达萨内心的贪婪和自私。</p>
<p>在叙述养鸽女和弗洛伦蒂诺·阿里萨的故事中，正当我看得入迷，以为故事情节达到高潮之时，养鸽女直接被丈夫残忍杀害的时候，故事情节戛然而止，最后只剩下坟墓前那盛开的玫瑰花，弗洛伦蒂诺·阿里萨来看他的母亲时会一起清理一下，以减少他内心的愧疚，可最后墓园里的所有玫瑰花都被政府清除掉了，并把墓园改成了公墓。</p>
<p>作者马尔克斯描写最后的结局中，以弗洛伦蒂诺·阿里萨回答船长的话“一生一世”作为结尾，给人无限的遐想，船既没有停泊，也没有继续前进，也暗示着弗洛伦蒂诺·阿里萨和费尔明娜·达萨的关系，留一段空白给读者细细品味。</p>
]]></content>
      <categories>
        <category>墨枫的读书感想</category>
      </categories>
      <tags>
        <tag>读书感想</tag>
      </tags>
  </entry>
  <entry>
    <title>一、聚合搜索平台简介</title>
    <url>/2023/05/03/%E4%B8%80%E3%80%81%E8%81%9A%E5%90%88%E6%90%9C%E7%B4%A2%E5%B9%B3%E5%8F%B0%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="聚合搜索平台简介"><a href="#聚合搜索平台简介" class="headerlink" title="聚合搜索平台简介"></a>聚合搜索平台简介</h1><h2 id="技术栈介绍"><a href="#技术栈介绍" class="headerlink" title="技术栈介绍"></a>技术栈介绍</h2><p>全栈</p>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul>
<li>Vue</li>
<li>Ant Design Vue</li>
<li>Lodash</li>
</ul>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul>
<li>Spring Boot </li>
<li>MySQL</li>
<li>Elasticsearch (Elastic Stack) 搜索引擎</li>
<li>数据抓取</li>
<li>数据同步<ul>
<li>4种</li>
<li>logstash</li>
<li>Canal</li>
</ul>
</li>
<li>Guava Retrying</li>
<li>怎么保证 API 的稳定性</li>
</ul>
<h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><ol>
<li>先得到各种不同分类的数据</li>
<li>提供一个搜索页面（单一搜索、聚合搜索），支持搜索</li>
</ol>
<p>可以去做一些优化，比如关键词高亮、防抖节流</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230321215555548.png" alt="image-20230321215555548"></p>
<h2 id="项目计划"><a href="#项目计划" class="headerlink" title="项目计划"></a>项目计划</h2><h3 id="第一期"><a href="#第一期" class="headerlink" title="第一期"></a>第一期</h3><ul>
<li>前端后端项目初始化</li>
<li>前端搜索页面开发完成</li>
<li>后端基本搜索接口开发完成</li>
</ul>
<h3 id="第二期"><a href="#第二期" class="headerlink" title="第二期"></a>第二期</h3><ul>
<li>数据抓取</li>
<li>聚合搜索接口的开发<ul>
<li>适配器</li>
<li>门面模式</li>
</ul>
</li>
<li>Elasticsearch 搭建及热门</li>
</ul>
<h3 id="第三期"><a href="#第三期" class="headerlink" title="第三期"></a>第三期</h3><ul>
<li><p>Elasticsearch 的使用（建表、读写数据、调 API 、和 Java 整合）</p>
</li>
<li><p>数据同步（四种同步方式）</p>
</li>
</ul>
<h3 id="第四期"><a href="#第四期" class="headerlink" title="第四期"></a>第四期</h3><ul>
<li>接口稳定性保障</li>
<li>项目优化（关键词高亮、搜索建议、防抖节流）</li>
</ul>
<h2 id="时间安排"><a href="#时间安排" class="headerlink" title="时间安排"></a>时间安排</h2><ol>
<li>前端初始化 10 min </li>
<li>后端项目初始化 10 min</li>
<li>前端搜索页面开发 20 min</li>
<li>整合 Axios 10 min</li>
<li>后端搜索接口开发 10 min</li>
</ol>
<h2 id="前端初始化"><a href="#前端初始化" class="headerlink" title="前端初始化"></a>前端初始化</h2><ol>
<li>参考 Ant Design 组件库的官方文档来搭建初始化项目<br>（<a href="https://2x.antdv.com/docs/vue/getting-started-cn%EF%BC%89%EF%BC%8C%E5%B9%B6%E6%95%B4%E5%90%88%E7%BB%84%E4%BB%B6%E5%BA%93">https://2x.antdv.com/docs/vue/getting-started-cn），并整合组件库</a></li>
<li>删减不需要的页面和路由</li>
</ol>
<h2 id="后端初始化"><a href="#后端初始化" class="headerlink" title="后端初始化"></a>后端初始化</h2><ol>
<li>使用星球 springboot-init 万用项目模板即可</li>
<li>直接使用 Swagger 文档在线测试接口</li>
</ol>
<h2 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h2><h3 id="记录搜索状态"><a href="#记录搜索状态" class="headerlink" title="记录搜索状态"></a>记录搜索状态</h3><p>目标：用 url 记录页面搜索状态，当用户刷新页面时，能够从 url 还原之前的搜索状态需要双向同步：url &lt;&#x3D;&gt; 页面状态</p>
<p>核心小技巧：把同步状态该为单向，即只允许 url 来改变页面状态，不允许反向</p>
<p>分步骤来实现，思路更清晰：</p>
<ol>
<li>让用户在操作的时候，改变 url 地址（点击搜索框，搜索内容填充到 url 上，切换 tab 时，也要填充）</li>
<li>当 url 改变的时候，去改变页面状态（监听 url 的改变）</li>
</ol>
<h2 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h2><p>前端整合 Axios，并自定义 Axios 实例，完成请求：<a href="https://www.axios-http.cn/docs/intro">https://www.axios-http.cn/docs/intro</a></p>
]]></content>
      <categories>
        <category>聚合搜索平台</category>
      </categories>
      <tags>
        <tag>星球项目</tag>
      </tags>
  </entry>
  <entry>
    <title>二、聚合搜索平台数据抓取</title>
    <url>/2023/05/03/%E4%BA%8C%E3%80%81%E8%81%9A%E5%90%88%E6%90%9C%E7%B4%A2%E5%B9%B3%E5%8F%B0%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/</url>
    <content><![CDATA[<h1 id="聚合搜索平台数据抓取"><a href="#聚合搜索平台数据抓取" class="headerlink" title="聚合搜索平台数据抓取"></a>聚合搜索平台数据抓取</h1><p>本章内容</p>
<ol>
<li>获取多种不同类型的数据源<ol>
<li>文章（内部）</li>
<li>用户（内部）</li>
<li>图片（外部，不是我们自己的项目、自己的用户生产的数据）</li>
</ol>
</li>
<li>前后端单独的搜索接口联调，跑通整个页面</li>
<li>分析现有项目的问题 &#x3D;&gt; 优化，聚合接口的开发</li>
</ol>
<h2 id="获取不同类型的数据源"><a href="#获取不同类型的数据源" class="headerlink" title="获取不同类型的数据源"></a>获取不同类型的数据源</h2><h3 id="数据抓取流程"><a href="#数据抓取流程" class="headerlink" title="数据抓取流程"></a>数据抓取流程</h3><ol>
<li>分析数据源（怎么获取？）</li>
<li>拿到数据后，怎么处理？</li>
<li>写入数据等存储</li>
</ol>
<h3 id="数据抓取的几种方式"><a href="#数据抓取的几种方式" class="headerlink" title="数据抓取的几种方式"></a>数据抓取的几种方式</h3><ol>
<li>直接请求数据结构（最方便） HttpClient、OkHttp、RestTemplate、Hutool(<a href="https://hutool.cn/">https://hutool.cn/</a>)</li>
<li>等网页渲染出明文内容后，从前端页面的内容抓取</li>
<li>有一些网站可能是动态请求的，它不会一次性加载所有的数据，而是要你点击某一个按钮、输入某个验证码才会显示出数据。 &#x3D;&gt; 无头浏览器： selenium、node.js puppeteer</li>
</ol>
<p><strong>注意：爬虫技术不能滥用，不能给别人的系统造成压力、不要侵犯他人权益！</strong></p>
<h3 id="1、获取文章"><a href="#1、获取文章" class="headerlink" title="1、获取文章"></a>1、获取文章</h3><p>要是内部没有文章，可以从互联网上获取基础数据 &#x3D;&gt; 爬虫</p>
<p>抓取：<a href="https://www.code-nav.cn/learn/passage">https://www.code-nav.cn/learn/passage</a></p>
<p>获取文章后要入库（定时获取或者只获取一次），<strong>离线抓取</strong></p>
<h3 id="2、用户获取"><a href="#2、用户获取" class="headerlink" title="2、用户获取"></a>2、用户获取</h3><p>每个网站的用户基本都是自己的，一般无需从站外获取</p>
<h3 id="3、图片获取"><a href="#3、图片获取" class="headerlink" title="3、图片获取"></a>3、图片获取</h3><p>实时抓取：我们自己的网站不存储这些数据，用户要搜索的时候，直接从别人的接口（网站）去搜索</p>
<p>jsoup 库：获取到 HTML 文档，然后从中解析出需要的字段</p>
<h2 id="现有业务场景分析"><a href="#现有业务场景分析" class="headerlink" title="现有业务场景分析"></a>现有业务场景分析</h2><p>目前是在页面加载时，调用三个接口分别获取文章、图片、用户数据</p>
<p>几种不同的业务场景：</p>
<ol>
<li>其他可以用户点某个 tab 的时候，只调用这个 tab 接口（如：<a href="https://www.code-nav.cn/search/all?current=2&amp;pageSize=8&amp;searchText=&amp;sortField=_score&amp;sortOrder=descend%EF%BC%89">https://www.code-nav.cn/search/all?current=2&amp;pageSize=8&amp;searchText=&amp;sortField=_score&amp;sortOrder=descend）</a></li>
<li>如果针对聚合内容的网页，其实可以一个请求搞定（如：<a href="https://tophub.today/%EF%BC%89">https://tophub.today/）</a></li>
<li>有可能还有查询其他的信息，比如其他数据的总数，同时给用户反馈</li>
</ol>
<p><strong>根据实际情况自行选择</strong></p>
<p>存在的问题：</p>
<ol>
<li>请求数量比较多，可能会受到浏览器的限制</li>
<li>请求不同接口的参数可能不一样，增加前端沟通成本</li>
<li>前端写调用多个接口的代码，重复代码</li>
</ol>
<h2 id="聚合接口"><a href="#聚合接口" class="headerlink" title="聚合接口"></a>聚合接口</h2><ol>
<li><p>请求数量比较多，可能会受到浏览器的限制 &#x3D;&gt; 用一个接口请求完所有的数据（后端可以并发，几乎没有并发数量限制）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    user = userService.<span class="type">query</span></span><br><span class="line">    <span class="variable">post</span> <span class="operator">=</span> postService.<span class="type">query</span></span><br><span class="line">    <span class="variable">picture</span> <span class="operator">=</span> pictureService.query</span><br><span class="line">    <span class="keyword">return</span> user + post + picture</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>请求不同接口的参数可能不一样，增加前端沟通成本 &#x3D;&gt; 用一个接口把请求参数统一，前端每次传固定的参数，后端去对参数进行转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    前端统一传 searchText</span><br><span class="line">    后端把 searchText 转换为 userName =&gt; queryUser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>统一返回结果：比如 Page 页面封装</p>
</li>
<li><p>前端写调用多个接口的代码，重复代码 &#x3D;&gt; 用一个接口，通过不同的参数去区分查询的数据源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    前端传 type 调用后端同一个接口，后端根据 type 调用不同的 service 查询</span><br><span class="line">    比如：type = userService.query</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>并发不一定更快！短板效应。要以实际为准</strong></p>
]]></content>
      <categories>
        <category>聚合搜索平台</category>
      </categories>
      <tags>
        <tag>星球项目</tag>
      </tags>
  </entry>
  <entry>
    <title>Elastic Stack</title>
    <url>/2023/05/03/Elastic-Stack/</url>
    <content><![CDATA[<h1 id="Elastic-Stack"><a href="#Elastic-Stack" class="headerlink" title="Elastic Stack"></a>Elastic Stack</h1><p>官网地址：<a href="https://www.elastic.co/cn/">https://www.elastic.co/cn/</a></p>
<p>包含了数据的整合 &#x3D;&gt; 提取 &#x3D;&gt; 存储 &#x3D;&gt; 使用，一整套</p>
<p>各个组件介绍：</p>
<ul>
<li>beats 套件：从各种不同类型的文件 &#x2F; 应用中采集数据。比如：a, b, c, d, e, aa, bb, cc</li>
<li>Logstash:从多个采集器或数据源来抽取 &#x2F; 转换数据，向 ES 输送。比如：a, bb, cc</li>
<li>elasticsearch:存储、查询数据</li>
<li>kibana:可视化 ES 数据</li>
</ul>
<h2 id="安装-ES"><a href="#安装-ES" class="headerlink" title="安装 ES"></a>安装 ES</h2><p>elasticsearch:<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/setup.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/setup.html</a></p>
<p>安装：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/zip-windows.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/zip-windows.html</a></p>
<p><strong>注意：一套技术，版本必须要一致，此处使用 7.17 版本</strong></p>
<h2 id="安装-Kibana"><a href="#安装-Kibana" class="headerlink" title="安装 Kibana"></a>安装 Kibana</h2><p>Kibana:<a href="https://www.elastic.co/guide/en/kibana/7.17/introduction.html">https://www.elastic.co/guide/en/kibana/7.17/introduction.html</a></p>
<p>安装：<a href="https://www.elastic.co/guide/en/kibana/7.17/install.html">https://www.elastic.co/guide/en/kibana/7.17/install.html</a></p>
<h2 id="ElasticSearch-概念"><a href="#ElasticSearch-概念" class="headerlink" title="ElasticSearch 概念"></a>ElasticSearch 概念</h2><p>可以理解为 MySQL 一样的数据库去学习和理解</p>
<p>入门学习：</p>
<ul>
<li>Index 索引 &#x3D;&gt; MySQL 里的表（table）</li>
<li>建表、增删改查（查询需要花费的时间较多）</li>
<li>用客户端去调用 ElasticSearch(3种)</li>
<li>语法：SQL、代码的方法（4中种语法）</li>
</ul>
<p>ES 相比于 MySQL 能够自动帮我们做分词，能够非常高效、灵活地查询内容</p>
<h3 id="索引（倒排索引）"><a href="#索引（倒排索引）" class="headerlink" title="索引（倒排索引）"></a>索引（倒排索引）</h3><p>正向索引：理解为书籍的目录，可以快速找到对应的内容（怎么根据页码找到文章）</p>
<p>倒排索引：怎么根据内容找到文章</p>
<p>文章 A：你好，我是 rapper</p>
<p>文章 B：墨枫你好，我是 coder</p>
<p>切词：</p>
<p>你好，我是，rapper</p>
<p>墨枫，你好，我是，coder</p>
<p>构建倒排索引表：</p>
<table>
<thead>
<tr>
<th>词</th>
<th>内容 id</th>
</tr>
</thead>
<tbody><tr>
<td>你好</td>
<td>文章 A， B</td>
</tr>
<tr>
<td>我是</td>
<td>文章 A， B</td>
</tr>
<tr>
<td>rapper</td>
<td>文章 A</td>
</tr>
<tr>
<td>墨枫</td>
<td>文章 B</td>
</tr>
<tr>
<td>coder</td>
<td>文章 B</td>
</tr>
</tbody></table>
<p>用户搜：“墨枫 rapper”</p>
<p>ES 先切词：墨枫， rapper</p>
<p>然后去倒排索引对应的文章</p>
<h2 id="ES的几种调用方式"><a href="#ES的几种调用方式" class="headerlink" title="ES的几种调用方式"></a>ES的几种调用方式</h2><h3 id="1）restful-api-调用（HTTP-请求）"><a href="#1）restful-api-调用（HTTP-请求）" class="headerlink" title="1）restful api 调用（HTTP 请求）"></a>1）restful api 调用（HTTP 请求）</h3><p>GET请求：<a href="http://localhost:9200/">http://localhost:9200/</a></p>
<p>curl 可以模拟发送请求：curl -X GET “localhost:9200&#x2F;?pretty”</p>
<p>ES 的启动端口</p>
<ol>
<li>9200：给外部用户（给客户端调用）的端口</li>
<li>9300：给 ES 集群内部通信的（外部调用不了）</li>
</ol>
<h3 id="2-kibana-devtools"><a href="#2-kibana-devtools" class="headerlink" title="2)kibana devtools"></a>2)kibana devtools</h3><p>自由地对 ES 进行操作（本质上也是 restful api)</p>
<p>devtools 不建议生产环境使用</p>
<h3 id="3）客户端调用"><a href="#3）客户端调用" class="headerlink" title="3）客户端调用"></a>3）客户端调用</h3><p>java 客户端、go 客户端等</p>
<p>参考文档：<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/7.17/_getting_started.html">https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/7.17/_getting_started.html</a></p>
<h2 id="ES-语法"><a href="#ES-语法" class="headerlink" title="ES 语法"></a>ES 语法</h2><h3 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h3><p>json 格式，好理解；额 Http 请求最兼容，应用最广</p>
<h4 id="建表、插入数据"><a href="#建表、插入数据" class="headerlink" title="建表、插入数据"></a>建表、插入数据</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST post/_doc/pqGEzYcB9-HYm7AKfgyO</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;墨枫33333&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;墨枫的描述33333&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>DSL 语法：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/query-dsl.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/query-dsl.html</a></p>
<p>（随忘随查）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET post/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;@timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>根据 id 查询：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET post/_doc/pqGEzYcB9-HYm7AKfgyO</span><br></pre></td></tr></table></figure>



<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST post/_doc/pqGEzYcB9-HYm7AKfgyO</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;墨枫&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;墨枫的描述&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除普通索引</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE index_name</span><br></pre></td></tr></table></figure>

<p>删除数据流式索引</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE _data_stream/post</span><br></pre></td></tr></table></figure>



<h3 id="EQL"><a href="#EQL" class="headerlink" title="EQL"></a>EQL</h3><p>专门查询 ECS 文档（标准指标文档）的数据的语法，更加规范，但只适用于特定场景（比如事件流）</p>
<p>文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/eql.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/eql.html</a></p>
<p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST my_event/_doc</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;墨枫33333&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;@timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2099-05-06T16:21:15.000Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;original&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.0.2.42 - - [06/May/2099:16:21:15 +0000] \&quot;GET /images/bg.jpg HTTP/1.0\&quot; 200 24736&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">GET /my_event/_eql/search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    any where 1 == 1</span></span><br><span class="line"><span class="string">  &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/sql-getting-started.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/sql-getting-started.html</a></p>
<p>学习成本低，但是可能需要插件支持、<strong>性能较差</strong></p>
<p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /_sql?format=txt</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SELECT * FROM post where title like &#x27;墨枫%&#x27;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="Painless-Scripting-language"><a href="#Painless-Scripting-language" class="headerlink" title="Painless Scripting language"></a>Painless Scripting language</h3><p>编程式取值，更灵活，但是学习成本高</p>
<h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/explicit-mapping.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/explicit-mapping.html</a></p>
<p>可以理解为数据库的表结构，有哪些字段、字段类型。</p>
<p>ES 支持动态 mapping，表结构可以动态改变，而不像 MySQL 一样必须手动建表，没有的字段就不能插入。</p>
<p>显示创建 mapping：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET user/_mapping</span><br><span class="line">PUT user</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span>    <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span>  </span><br><span class="line">      <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span>  <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span>   <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span>  <span class="punctuation">&#125;</span>     </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="ElasticStack-概念"><a href="#ElasticStack-概念" class="headerlink" title="ElasticStack 概念"></a>ElasticStack 概念</h2><p>ES 索引（Index） &#x3D;&gt; 表</p>
<p>ES field  (字段) &#x3D;&gt; 列</p>
<p>倒排索引</p>
<p>调用语法（DSL、EQL、SQL等）</p>
<p>Mapping 表结构</p>
<ul>
<li>自动生成 mapping</li>
<li>手动指定 mapping</li>
</ul>
<h3 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h3><p>内置分词器：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/analysis-analyzers.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/analysis-analyzers.html</a></p>
<p>空格分词器：whitespace，结果 The、quick、brown、fox等</p>
<p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;whitespace&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span>     <span class="string">&quot;The quick is brown fox.&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>标准分词规则，结果：is、this、deja、vu</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;tokenizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;standard&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span>  <span class="punctuation">[</span> <span class="string">&quot;lowercase&quot;</span><span class="punctuation">,</span> <span class="string">&quot;asciifolding&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span>      <span class="string">&quot;Is this déja vu?&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>关键词分词器：就是不分词，整句话当作专业术语</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span>     <span class="string">&quot;The quick is brown fox.&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="IK-分词器（ES-插件）"><a href="#IK-分词器（ES-插件）" class="headerlink" title="IK 分词器（ES 插件）"></a>IK 分词器（ES 插件）</h3><p>中文友好：<a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p>
<p>下载地址（注意版本一致）：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v7.17.7">https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v7.17.7</a></p>
<p>思考：如何让 IK 按照自己的想法分词？</p>
<p>解决方案：自定义词典</p>
<p>ik_smart 和 ik_max_word 的区别：</p>
<p>举例：“小黑子”</p>
<p>ik_smart 是只能分词，尽量选择最像一个词的拆分方式，比如“小”、“黑子”</p>
<p>ik_max_word 尽可能地分词，可以包括组合词，比如“小黑”、“黑子“</p>
<h3 id="打分机制"><a href="#打分机制" class="headerlink" title="打分机制"></a>打分机制</h3><p>比如有 3 条内容：</p>
<ol>
<li>墨枫是狗</li>
<li>墨枫是小黑子</li>
<li>我是小黑子</li>
</ol>
<p>用户搜索：</p>
<ol>
<li>墨枫，第一条分数最高，因为第一条匹配了关键词，而且更短（匹配比例更大）</li>
<li>墨枫小黑子 &#x3D;&gt; 墨枫、小、黑子，排序结果：2 &gt; 3 &gt; 1</li>
</ol>
<p>参考文章：<a href="https://liyupi.blog.csdn.net/article/details/119176943">https://liyupi.blog.csdn.net/article/details/119176943</a></p>
<p>官方参考文章：<a href="https://www.elastic.co/guide/en/elasticsearch/guide/master/controlling-relevance.html">https://www.elastic.co/guide/en/elasticsearch/guide/master/controlling-relevance.html</a></p>
<h2 id="ES-调用方式"><a href="#ES-调用方式" class="headerlink" title="ES 调用方式"></a>ES 调用方式</h2><p>有 3 种：</p>
<ol>
<li>HTTP Restful 调用</li>
<li>kibana 操作（dev tools)</li>
<li>客户端操作（Java）</li>
</ol>
<h3 id="Java-操作-ES"><a href="#Java-操作-ES" class="headerlink" title="Java 操作 ES"></a>Java 操作 ES</h3><p>3 种方式：</p>
<p>1）ES 官方的 Java API</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/7.17/introduction.html">https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/7.17/introduction.html</a></p>
<p>快速开始：<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/7.17/connecting.html">https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/7.17/connecting.html</a></p>
<p>2）ES 以前的官方 Java API， HighLevelRestClient（已经废弃，不建议使用）</p>
<p>3）Spring Data Elasticsearch（推荐）</p>
<p>spring-data 系列：spring 提供的操作数据的框架</p>
<p>spring-data-redis:操作 Redis 的一套方法</p>
<p>spring-data-mongodb:操作 mongodb 的一套方法</p>
<p>spring-data-elasticsearch:操作 elasticsearch 的一套方法</p>
<p>官方文档：<a href="https://docs.spring.io/spring-data/elasticsearch/docs/4.4.10/reference/html/">https://docs.spring.io/spring-data/elasticsearch/docs/4.4.10/reference/html/</a></p>
<p>自定义方法：用户可以指定接口的方法名称，框架帮你自动生成查询</p>
<h2 id="用-ES-实现搜索接口"><a href="#用-ES-实现搜索接口" class="headerlink" title="用 ES 实现搜索接口"></a>用 ES 实现搜索接口</h2><h3 id="1、建表（建立索引）"><a href="#1、建表（建立索引）" class="headerlink" title="1、建表（建立索引）"></a>1、建表（建立索引）</h3><p>数据库表结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 帖子表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> post</span><br><span class="line">(</span><br><span class="line">    id         <span class="type">bigint</span> auto_increment comment <span class="string">&#x27;id&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">    title      <span class="type">varchar</span>(<span class="number">512</span>)                       <span class="keyword">null</span> comment <span class="string">&#x27;标题&#x27;</span>,</span><br><span class="line">    content    text                               <span class="keyword">null</span> comment <span class="string">&#x27;内容&#x27;</span>,</span><br><span class="line">    tags       <span class="type">varchar</span>(<span class="number">1024</span>)                      <span class="keyword">null</span> comment <span class="string">&#x27;标签列表（json 数组）&#x27;</span>,</span><br><span class="line">    thumbNum   <span class="type">int</span>      <span class="keyword">default</span> <span class="number">0</span>                 <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;点赞数&#x27;</span>,</span><br><span class="line">    favourNum  <span class="type">int</span>      <span class="keyword">default</span> <span class="number">0</span>                 <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;收藏数&#x27;</span>,</span><br><span class="line">    userId     <span class="type">bigint</span>                             <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建用户 id&#x27;</span>,</span><br><span class="line">    createTime datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    updateTime datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    isDelete   tinyint  <span class="keyword">default</span> <span class="number">0</span>                 <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;是否删除&#x27;</span>,</span><br><span class="line">    index idx_userId (userId)</span><br><span class="line">) comment <span class="string">&#x27;帖子&#x27;</span> <span class="keyword">collate</span> <span class="operator">=</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>



<p>ES Mapping:</p>
<p>id（可以不放到字段设置里）</p>
<p>ES 中，尽量存放需要用户筛选（搜索）的数据</p>
<ul>
<li>aliases:别名（为了后续方便数据迁移）</li>
</ul>
<p>​		字段类型时 text，这个字段是可被分词的、可模糊查询的；而如果是 keyword，只能完全匹配、精确查询。</p>
<ul>
<li><p>analyzer （存储时生效的分词器）:用 ik_max_word ，拆的更碎、索引更多，更有可能被搜索出来</p>
</li>
<li><p>search_analyzer (查询时生效的分词器)：用 ik_smart ,更偏向于用户想搜的分词</p>
</li>
</ul>
<p>如果想让 text 类型的分词字段也支持精确查询，可以创建 keyword 类型的子字段：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ignore_above&quot;</span><span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>建表结构：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT post_v1</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aliases&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;post&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignore_above&quot;</span><span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignore_above&quot;</span><span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;userId&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;updateTime&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isDelete&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="2、增删改查"><a href="#2、增删改查" class="headerlink" title="2、增删改查"></a>2、增删改查</h3><p>第一种方式：ElasticsearchRepository&lt;PostEsDTO, Long&gt;, 默认提供了简单的增删改查，多用于可预期的、相对诶那么复杂的查询、自定义查询，返回结果相对简单直接。</p>
<p>接口代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CrudRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;T, ID&gt; &#123;</span><br><span class="line"></span><br><span class="line">	&lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">save</span><span class="params">(S entity)</span>;</span><br><span class="line"></span><br><span class="line">	&lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; Iterable&lt;S&gt; <span class="title function_">saveAll</span><span class="params">(Iterable&lt;S&gt; entities)</span>;</span><br><span class="line"></span><br><span class="line">	Optional&lt;T&gt; <span class="title function_">findById</span><span class="params">(ID id)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">existsById</span><span class="params">(ID id)</span>;</span><br><span class="line"></span><br><span class="line">	Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	Iterable&lt;T&gt; <span class="title function_">findAllById</span><span class="params">(Iterable&lt;ID&gt; ids)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(ID id)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">deleteAllById</span><span class="params">(Iterable&lt;? extends ID&gt; ids)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">(Iterable&lt;? extends T&gt; entities)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ES 中，_开头的字段表示系统默认字段，比如 _id,如果系统不指定，会自动生成。但是不会在 _source 字段中补充id 的值，所以建议手动指定。</p>
<p>支持根据方法名自动生成方法，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;PostEsDTO&gt; <span class="title function_">findByTitle</span><span class="params">(String title)</span>;</span><br></pre></td></tr></table></figure>



<p>第二种方式：Spring 默认给我们提供的操作 ES 的客户端对象 ElasticsearchRestTemplate ，也提供了增删改查，它的增删改查更灵活，适用于更复杂的操作，返回结果更完整，但需要自己解析。</p>
<p><strong>对于复杂的查询，建议使用第二种方式</strong></p>
<p>三个步骤：</p>
<ol>
<li>取参数</li>
<li>把参数组合为 ES 支持的搜索条件</li>
<li>从返回值中取结果</li>
</ol>
<h3 id="3、查询-DSL"><a href="#3、查询-DSL" class="headerlink" title="3、查询 DSL"></a>3、查询 DSL</h3><p>参考文档：</p>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/query-filter-context.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/query-filter-context.html</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/query-dsl-bool-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/query-dsl-bool-query.html</a></li>
</ul>
<p>示例代码：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET post/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span>   <span class="string">&quot;墨枫&quot;</span>        <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span>   <span class="string">&quot;博客&quot;</span>        <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> </span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span>  <span class="punctuation">&#123;</span> <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;published&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;publish_date&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-05-02&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>wilcard 模糊查询</p>
<p>regexp 正则表达式</p>
<p>查询结果中，score 代码匹配分数</p>
<p>建议先测试 DSL，再翻译成 Java</p>
<p>动静分离设计：先模糊筛选竟然数据，查出数据后，再根据查到的内容 id 去数据库查找到 <strong>动态数据</strong></p>
<h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>一般情况下，如果做查询搜索功能，使用 ES 来模糊查询，但是数据是存放在数据库 MySQL 里的，所以说需要把 MySQL 的数据和 ES 的数据进行同步，保证数据的一致性（以 MySQL为主）</p>
<p>MySQL &#x3D;&gt; ES （单向）</p>
<p>首次安装完 ES ，把 MySQL数据全量同步到 ES 里，写一个单词脚本</p>
<p>4 种方式，全量同步（首次） + 增量同步（新数据）：</p>
<ol>
<li>定时任务，比如 1 分钟 1 次，找到 MySQL 过去几分钟内（至少定时周期的 2 倍）发生改变的数据，然后更新到 ES<br>优点：简单易懂、占用资源少、不用引入第三方中间件<br>缺点：有时间差<br>应用场景：数据短时间内不同步影响不大、或者数据几乎不发生修改</li>
<li>双写：写数据的时候，必须也去写 ES；更新删除数据库同理。（事务：建议先保证 MySQL 写成功，如果 ES 写失败了，可以通过定时任务 + 日志 + 告警进行检测和修复（补偿）</li>
<li>用 Logstash 数据同步管道（一般要配合 kafka 消息队列 + beats 采集器）</li>
<li>Canal 监听 MySQL Binlog, 实时同步</li>
</ol>
<h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><p><strong>传输</strong>和<strong>处理</strong>数据的管道</p>
<p><a href="https://www.elastic.co/guide/en/logstash/7.17/getting-started-with-logstash.html">https://www.elastic.co/guide/en/logstash/7.17/getting-started-with-logstash.html</a></p>
<p>好处：用起来方便，插件多</p>
<p>缺点：成本更大、一般要配合其他组件使用（比如 kafka)</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230503223832634.png" alt="image-20230503223832634"></p>
<p>事件 DEMO：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> logstash-7.17.9</span><br><span class="line">.\bin\logstash.bat -e <span class="string">&quot;input &#123; stdin &#123;&#125; &#125; output &#123; stdout&#123;&#125; &#125;&quot;</span> </span><br></pre></td></tr></table></figure>



<p>快速开始文档：<a href="https://www.elastic.co/guide/en/logstash/7.17/running-logstash-windows.html">https://www.elastic.co/guide/en/logstash/7.17/running-logstash-windows.html</a></p>
<p>监听 udp 并输出：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">    udp&#123;</span><br><span class="line">        <span class="attribute">port</span> =&gt; <span class="number">514</span></span><br><span class="line">        type =&gt; <span class="string">&quot;syslog&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output&#123;</span><br><span class="line">    stdout&#123;</span><br><span class="line">        <span class="attribute">codec</span> =&gt; rubydebug</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>要把 MySQL 同步给 Elasticsearch</p>
<p>问题1：找不到 mysql 包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error:unable to load mysql-connector-java-<span class="number">5.1</span><span class="number">.36</span>-bin.jar from :jdbc_driver_library,file not <span class="title function_">readable</span></span><br><span class="line"><span class="params">(please check user and group permissions <span class="keyword">for</span> the path)</span></span><br><span class="line">Exception:LogStash:PluginLoadingError</span><br></pre></td></tr></table></figure>

<p>解决：修改 Logstash 任务配置中的 jdbc_driver_library 为驱动包的绝对路径（驱动包可以从 maven 仓库中拷贝）</p>
<p>增量配置：是不是可以只查最新更新的数据？可以记录上次更新的时间，只查出来 &gt; 该更新时间的数据</p>
<p>小知识：预编译 SQL 的优点</p>
<ol>
<li>灵活</li>
<li>模板好懂</li>
<li>快（有缓存）</li>
<li>部分仿注入</li>
</ol>
<p>sql_last_value 是上次查到额数据的最后一行的指定的字段，如果要全量更新，只要删除掉</p>
<p>D:\javaTools\ElasticStack\logstash-7.17.9\data\plugins\inputs\jdbc\logstash_jdbc_last_run 文件即可（这个文件存储额上次同步到的数据）</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">input</span> &#123;</span><br><span class="line">  <span class="section">jdbc</span> &#123;</span><br><span class="line">    <span class="attribute">jdbc_driver_library</span> =&gt; <span class="string">&quot;D:\javaTools\ElasticStack\logstash-7.17.9\config\mysql-connector-java-8.0.29.jar&quot;</span></span><br><span class="line">    jdbc_driver_class =&gt; <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="line">    jdbc_connection_string =&gt; <span class="string">&quot;jdbc:mysql://localhost:3306/my_db&quot;</span></span><br><span class="line">    jdbc_user =&gt; <span class="string">&quot;root&quot;</span></span><br><span class="line">	jdbc_password =&gt; <span class="string">&quot;root&quot;</span></span><br><span class="line">    statement =&gt; <span class="string">&quot;SELECT * from post where updateTime &gt; :sql_last_value&quot;</span></span><br><span class="line">	use_column_value =&gt; <span class="literal">true</span></span><br><span class="line">    tracking_column_type =&gt; <span class="string">&quot;timestamp&quot;</span></span><br><span class="line">    tracking_column =&gt; <span class="string">&quot;updatetime&quot;</span></span><br><span class="line">	parameters =&gt; &#123; &quot;favorite_artist&quot; =&gt; &quot;Beethoven&quot; &#125;</span><br><span class="line">    <span class="attribute">schedule</span> =&gt; <span class="string">&quot;*/5 * * * *&quot;</span></span><br><span class="line">	jdbc_default_timezone =&gt; <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  <span class="section">stdout</span> &#123; <span class="attribute">codec</span> =&gt; rubydebug &#125;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">		<span class="attribute">hosts</span> =&gt; <span class="string">&quot;http://localhost:9200&quot;</span></span><br><span class="line">		index =&gt; <span class="string">&quot;post_v1&quot;</span></span><br><span class="line">		document_id =&gt; <span class="string">&quot;%&#123;id&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意查询语句中要按 updateTime 排序，保证最后一条是最大的：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">input</span> &#123;</span><br><span class="line">  <span class="section">jdbc</span> &#123;</span><br><span class="line">    <span class="attribute">jdbc_driver_library</span> =&gt; <span class="string">&quot;D:\javaTools\ElasticStack\logstash-7.17.9\config\mysql-connector-java-8.0.29.jar&quot;</span></span><br><span class="line">    jdbc_driver_class =&gt; <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="line">    jdbc_connection_string =&gt; <span class="string">&quot;jdbc:mysql://localhost:3306/my_db&quot;</span></span><br><span class="line">    jdbc_user =&gt; <span class="string">&quot;root&quot;</span></span><br><span class="line">	jdbc_password =&gt; <span class="string">&quot;root&quot;</span></span><br><span class="line">    statement =&gt; <span class="string">&quot;SELECT * from post where updateTime &gt; :sql_last_value and updateTime &lt; now() order by updateTime desc&quot;</span></span><br><span class="line">	use_column_value =&gt; <span class="literal">true</span></span><br><span class="line">    tracking_column_type =&gt; <span class="string">&quot;timestamp&quot;</span></span><br><span class="line">    tracking_column =&gt; <span class="string">&quot;updatetime&quot;</span></span><br><span class="line">	parameters =&gt; &#123; &quot;favorite_artist&quot; =&gt; &quot;Beethoven&quot; &#125;</span><br><span class="line">    <span class="attribute">schedule</span> =&gt; <span class="string">&quot;*/5 * * * *&quot;</span></span><br><span class="line">	jdbc_default_timezone =&gt; <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  <span class="section">stdout</span> &#123; <span class="attribute">codec</span> =&gt; rubydebug &#125;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">		<span class="attribute">hosts</span> =&gt; <span class="string">&quot;http://localhost:9200&quot;</span></span><br><span class="line">		index =&gt; <span class="string">&quot;post_v1&quot;</span></span><br><span class="line">		document_id =&gt; <span class="string">&quot;%&#123;id&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>两个问题：</p>
<ol>
<li>字段全变成小写了</li>
<li>多了一些我们不想同步的字段</li>
</ol>
<p>解决：</p>
<p>编写过滤</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">input</span> &#123;</span><br><span class="line">  <span class="section">jdbc</span> &#123;</span><br><span class="line">    <span class="attribute">jdbc_driver_library</span> =&gt; <span class="string">&quot;D:\javaTools\ElasticStack\logstash-7.17.9\config\mysql-connector-java-8.0.29.jar&quot;</span></span><br><span class="line">    jdbc_driver_class =&gt; <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="line">    jdbc_connection_string =&gt; <span class="string">&quot;jdbc:mysql://localhost:3306/my_db&quot;</span></span><br><span class="line">    jdbc_user =&gt; <span class="string">&quot;root&quot;</span></span><br><span class="line">	jdbc_password =&gt; <span class="string">&quot;root&quot;</span></span><br><span class="line">    statement =&gt; <span class="string">&quot;SELECT * from post where updateTime &gt; :sql_last_value and updateTime &lt; now() order by updateTime desc&quot;</span></span><br><span class="line">	use_column_value =&gt; <span class="literal">true</span></span><br><span class="line">    tracking_column_type =&gt; <span class="string">&quot;timestamp&quot;</span></span><br><span class="line">    tracking_column =&gt; <span class="string">&quot;updatetime&quot;</span></span><br><span class="line">	parameters =&gt; &#123; &quot;favorite_artist&quot; =&gt; &quot;Beethoven&quot; &#125;</span><br><span class="line">    <span class="attribute">schedule</span> =&gt; <span class="string">&quot;*/5 * * * *&quot;</span></span><br><span class="line">	jdbc_default_timezone =&gt; <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">    <span class="section">mutate</span> &#123;</span><br><span class="line">        <span class="attribute">rename</span> =&gt; &#123;</span><br><span class="line">			&quot;updatetime&quot; =&gt; &quot;updateTime&quot;</span><br><span class="line">			&quot;userid&quot; =&gt; &quot;userId&quot;</span><br><span class="line">			&quot;createtime&quot; =&gt; &quot;createTime&quot;</span><br><span class="line">			&quot;isdelete&quot; =&gt; &quot;isDelete&quot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="attribute">remove_field</span> =&gt; [<span class="string">&quot;thumbnum&quot;</span>, <span class="string">&quot;favournum&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  <span class="section">stdout</span> &#123; <span class="attribute">codec</span> =&gt; rubydebug &#125;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">		<span class="attribute">hosts</span> =&gt; <span class="string">&quot;http://localhost:9200&quot;</span></span><br><span class="line">		index =&gt; <span class="string">&quot;post_v1&quot;</span></span><br><span class="line">		document_id =&gt; <span class="string">&quot;%&#123;id&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="订阅数据库流水的同步方式-Canal"><a href="#订阅数据库流水的同步方式-Canal" class="headerlink" title="订阅数据库流水的同步方式 Canal"></a>订阅数据库流水的同步方式 Canal</h3><p><a href="https://github.com/alibaba/canal/">https://github.com/alibaba/canal/</a></p>
<p>优点：实时同步，实时性非常强</p>
<p>原理：数据库每次修改时，会修改 binlog 文件，只要监听该文件的修改，就能第一时间饿到消息并处理</p>
<p>canal：帮你监听 binlog，并解析 binlog 为可以理解的内容</p>
<p>它伪装成了 MySQL 的从节点，获取主节点给的 binlog ,如图：</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230503230056433.png" alt="image-20230503230056433"></p>
<p>快速开始：<a href="https://github.com/alibaba/canal/wiki/QuickStart">https://github.com/alibaba/canal/wiki/QuickStart</a></p>
<p>对于自建 MySQL , 需要先开启 Binlog 写入功能，配置 binlog-format 为 ROW 模式，my.cnf 中配置如下</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">mysql-bin # 开启 binlog</span></span><br><span class="line"><span class="attr">binlog-format</span>=<span class="string">ROW # 选择 ROW 模式</span></span><br><span class="line"><span class="attr">server_id</span>=<span class="string">1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复</span></span><br></pre></td></tr></table></figure>



<p>如果 java 找不到，修改 startup.bat 脚本为你自己的 java home：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> JAVA_HOME=C:\Users\59278\.jdks\corretto-1.8.0_302</span><br><span class="line"><span class="built_in">echo</span> %JAVA_HOME%</span><br><span class="line"><span class="built_in">set</span> PATH=%JAVA_HOME%\bin;%PATH%</span><br><span class="line"><span class="built_in">echo</span> %PATH%</span><br></pre></td></tr></table></figure>



<p>问题：mysql 无法链接，Caused by: java.io.IOException: caching_sha2_password Auth failed</p>
<p>解决方案：<a href="https://github.com/alibaba/canal/issues/3902">https://github.com/alibaba/canal/issues/3902</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ALTER USER &#x27;canal&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;canal&#x27;;</span><br><span class="line"></span><br><span class="line">ALTER USER &#x27;canal&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;canal&#x27; PASSWORD EXPIRE NEVER;</span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>



<h2 id="配置-kibama-可视化看板"><a href="#配置-kibama-可视化看板" class="headerlink" title="配置 kibama 可视化看板"></a>配置 kibama 可视化看板</h2><ol>
<li>创建索引</li>
<li>导入数据</li>
<li>创建索引模式</li>
<li>选择图表、托拉拽</li>
<li>保存</li>
</ol>
<h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p>官方文档：<a href="https://jmeter.apache.org/">https://jmeter.apache.org/</a></p>
<p>找到 jar 包：D:\javaTools\apache-jmeter-5.5\bin\ApacheJMeter.jar 启动</p>
<p>配置线程组 &#x3D;&gt; 请求头 &#x3D;&gt; 默认请求 &#x3D;&gt; 单个请求头 &#x3D;&gt; 响应断言 &#x3D;&gt; 聚合报告 &#x2F; 结果树</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230503230921181.png" alt="image-20230503230921181"></p>
<p>99% 分位：99% 的用户都在这个响应时间内</p>
<p>吞吐量：每秒处理的请求数 qps</p>
<h3 id="更多的学习"><a href="#更多的学习" class="headerlink" title="更多的学习"></a>更多的学习</h3><p>插件：<a href="https://jmeter-plugins.org/install/Install/">https://jmeter-plugins.org/install/Install/</a></p>
<p>下载后文件为 plugins-manager.jar 格式，将其放入 jmeter 安装目录下的 lib&#x2F;ext 目录，然后 jmeter,即可。</p>
<p>参考文章：<a href="https://blog.csdn.net/weixin_45189665/article/details/125278218">https://blog.csdn.net/weixin_45189665/article/details/125278218</a></p>
<h2 id="搜索建议"><a href="#搜索建议" class="headerlink" title="搜索建议"></a>搜索建议</h2><p>参考官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/search-suggesters.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/search-suggesters.html</a></p>
<p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET post/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;墨枫是狗&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&lt;h1&gt;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;post_tags&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&lt;h1&gt;&quot;</span><span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;suggest&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;my-suggestion&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;墨枫是狗&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;term&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;content&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="搜索高亮"><a href="#搜索高亮" class="headerlink" title="搜索高亮"></a>搜索高亮</h2><p>参考官方：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/highlighting.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/highlighting.html</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET post/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;鱼皮是狗&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&lt;h1&gt;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;post_tags&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&lt;h1&gt;&quot;</span><span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="前端防抖节流"><a href="#前端防抖节流" class="headerlink" title="前端防抖节流"></a>前端防抖节流</h2><p>问题：用户频繁搜索、频繁点击欧索按钮怎么办？</p>
<p>解决：使用 lodash 工具库实现防抖和节流</p>
<p>节流：每段时间最多执行 x 次（比如服务器限流）<a href="https://www.lodashjs.com/docs/lodash.throttle">https://www.lodashjs.com/docs/lodash.throttle</a></p>
<p>防抖：等待一段时间内没有其他操作了，才执行操作（比如输入搜索）</p>
<p><a href="https://www.lodashjs.com/docs/lodash.debounce">https://www.lodashjs.com/docs/lodash.debounce</a></p>
<h2 id="接口稳定性优化"><a href="#接口稳定性优化" class="headerlink" title="接口稳定性优化"></a>接口稳定性优化</h2><p>问题：调用第三方接口不稳定怎么办？（比如 bing 接口）</p>
<p>使用 guava-retrying 库实现自动重试：<a href="https://github.com/rholder/guava-retrying">https://github.com/rholder/guava-retrying</a></p>
<p>参考学习文章：<a href="https://cloud.tencent.com/developer/article/1752086">https://cloud.tencent.com/developer/article/1752086</a></p>
]]></content>
      <categories>
        <category>聚合搜索平台</category>
      </categories>
      <tags>
        <tag>星球项目</tag>
      </tags>
  </entry>
  <entry>
    <title>聚合搜索优化</title>
    <url>/2023/05/03/%E8%81%9A%E5%90%88%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="聚合搜索优化"><a href="#聚合搜索优化" class="headerlink" title="聚合搜索优化"></a>聚合搜索优化</h1><p>问题：怎样能让前端一次搜出所有数据、又能分别获取某一类数据（比如分页场景）</p>
<p>解决方案：</p>
<p>新增 type 字段：前端传 type 调用后后端同一个接口，后端根据 type 不同调用不同的 service 查询</p>
<p>比如前端传递 type &#x3D; post ，后端执行 postService.query</p>
<p>逻辑：</p>
<ol>
<li>如果 type 为空，那么搜索出所有数据</li>
<li>如果 通哟额 不为空<ol>
<li>如果 type 合法，查出对应数据</li>
<li>否则报错</li>
</ol>
</li>
</ol>
<p>存在的问题： type 增多后，要把查询逻辑堆积在 controller 代码里吗？</p>
<p>思考：如何让搜索系统 <strong>更有效地</strong>接入更多的数据源？</p>
<h2 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h2><p>介绍：帮助我们用户（客户端）更轻松地实现功能，不需要关注门面背后的细节</p>
<p>聚合搜索业务基本都是门面模式，即前端不同关心后端从哪里来、怎么去取不同来源、怎么去聚合不同来源的数据，更方便地获取到内容。</p>
<p>当调用系统（接口）的客户端觉得麻烦时，需要考虑是否可以抽象一个门面。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>1）定制统一的数据源接入规范（标准）：</p>
<ul>
<li>什么数据源允许接入？</li>
<li>数据源接入的时候需要满足什么条件</li>
<li>需要接入方的注意事项</li>
</ul>
<p>聚合搜索系统要求：任何接入系统的数据，都必须能够根据关键词搜索、并且支持分页搜索</p>
<p>通过声明接口的方式来定义规范。</p>
<p>2）如果数据源已经支持了搜素，但是原有的方法参数和我们规范的不一致，如何解决？</p>
<p>使用适配器模式：通过转换，让两个系统能够完成对接。</p>
<h2 id="注册器模式"><a href="#注册器模式" class="headerlink" title="注册器模式"></a>注册器模式</h2><p>提前通过一个 map 或者其他类型存储好后面需要调用的对象。</p>
<p>效果：替换了 if … else …, 代码量大幅度减少，可维护可扩展。</p>
<h2 id="搜索优化"><a href="#搜索优化" class="headerlink" title="搜索优化"></a>搜索优化</h2><p>现有问题：搜索不灵活</p>
<p>比如搜 ”墨枫rapper“ 无法搜索到 ”墨枫是rapper“ 因为 MySQL 数据库的 like 是包含查询。</p>
]]></content>
      <categories>
        <category>聚合搜索平台</category>
      </categories>
      <tags>
        <tag>星球项目</tag>
      </tags>
  </entry>
</search>
