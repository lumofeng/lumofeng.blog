<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>墨枫个人博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-12-08T08:03:03.990Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>程序员墨枫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>组队功能设计</title>
    <link href="http://example.com/2022/12/08/%E7%BB%84%E9%98%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2022/12/08/%E7%BB%84%E9%98%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-12-08T08:06:28.952Z</published>
    <updated>2022-12-08T08:03:03.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组队功能"><a href="#组队功能" class="headerlink" title="组队功能"></a>组队功能</h1><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>需要跟自己一起参加竞赛、做项目、学习，可以发起队伍或者加入别人的队伍</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ol><li><p>用户可以<strong>创建</strong>队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0<br>队长、剩余的人数</p><p>聊天</p><p>公开或私密或加密</p><p>用户最多创建 5 个队伍</p></li><li><p>展示队伍列表，根据名称搜索队伍 P0，信息流中不展示已过期的队伍</p></li><li><p>修改队伍信息  P0~P1</p></li><li><p>用户可以加入队伍（其他人、未满人、未过期），允许加入多个队伍，但是有上限 P0 </p></li><li><p>是否需要队长同意？筛选审批？</p></li><li><p>用户可以退出队伍（如果队长退出，权限转移给第二早加入的用户 – 先来先到）P1</p></li><li><p>队长可以解散队伍 P0</p></li><li><p>分享队伍 &#x3D;&gt; 邀请其他用户加入队伍 P1 </p><p>业务流程：<br>（1）生成分享连接（分享二维码）<br>（2）用户访问链接，可以点击加入</p></li></ol><p></p><h3 id="系统（接口）设计"><a href="#系统（接口）设计" class="headerlink" title="系统（接口）设计"></a>系统（接口）设计</h3><h4 id="1-创建队伍"><a href="#1-创建队伍" class="headerlink" title="1.创建队伍"></a>1.创建队伍</h4><p>用户可以<strong>创建</strong>队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0<br>队长、剩余的人数</p><p>聊天</p><p>公开或私密或加密</p><p>用户最多创建 5 个队伍</p><ol><li>请求参数是否为空</li><li>是否登录，为登录不允许创建</li><li>校验信息<br>a. 队伍人数 &gt; 1 且 &lt;&#x3D; 20<br>b. 队伍标题小于 20<br>c. 描述 &lt;&#x3D; 512<br>d. status 是否公开（int）不传默认为0（公开）<br>e. 如果 status 是加密状态，一定要有密码，且密码 &lt;&#x3D; 32<br>f. 超时时间 &gt; 当前时间<br>g.校验用户最多创建 5 个队伍</li><li>插入队伍信息到队伍表</li><li>插入用户 &#x3D;&gt; 队伍关系到关系表</li></ol><h4 id="2-查询队伍列表"><a href="#2-查询队伍列表" class="headerlink" title="2.查询队伍列表"></a>2.查询队伍列表</h4><p>展示队伍列表，根据名称搜索队伍 P0，信息流中不展示已过期的队伍</p><ol><li>从请求参数中取出队伍名称等查询条件，如果存在则作为查询条件</li><li>不展示已过期的队伍（根据过期时间筛选）</li><li>可以通过某个<strong>关键字</strong>同时对名称和描述查询</li><li><strong>只有管理员才能查看加密还有非公开的队伍</strong></li><li>关联查询已加入队伍的用户信息</li><li><strong>关联查询已加入队伍的用户信息（可能耗费性能，建议用 SQL 实现）</strong></li></ol><p>实现方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询队伍和创建人信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> team t <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> t.userId <span class="operator">=</span> u.id</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询队伍和已加入队伍成员的信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> team t</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> user_team ut <span class="keyword">on</span> t.id <span class="operator">=</span> ut.teamId</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> ut.userId <span class="operator">=</span> u.id</span><br></pre></td></tr></table></figure><h4 id="3-修改队伍信息"><a href="#3-修改队伍信息" class="headerlink" title="3.修改队伍信息"></a>3.修改队伍信息</h4><ol><li>判断请求参数是否为空</li><li>查询队伍是否存在</li><li>只有管理员或者队伍的创建者可以修改</li><li>如果传入的新值和老值一致，则不需要 update （降低数据库使用次数）</li><li><strong>如果队伍状态为加密，修改时必须带密码</strong></li><li>更新队伍信息</li></ol><h4 id="4-用户可以加入队伍"><a href="#4-用户可以加入队伍" class="headerlink" title="4.用户可以加入队伍"></a>4.用户可以加入队伍</h4><p>其他人、队伍未满、未过期、允许加入过个队伍，但是有上线 P0</p><ol><li>用户最多加入 5 个队伍</li><li>队伍必须存在，只能加入未满员、未过期的队伍</li><li>不能加入自己的队伍，不能重复加入已加入的队伍（幂等性）</li><li>禁止加入私有的队伍</li><li>如果加入的队伍是加密的，需要匹配密码</li><li>修改队伍信息，补充人数</li><li>新增队伍-用户关联信息</li></ol><p><strong>注意，加上事务注解 @Trancational</strong></p><h4 id="5-用户退出队伍"><a href="#5-用户退出队伍" class="headerlink" title="5.用户退出队伍"></a>5.用户退出队伍</h4><p>请求参数：队伍 id</p><ol><li>校验请求参数</li><li>校验队伍是否存在</li><li>校验我是否已加入队伍</li><li>如果队伍<ol><li>只剩下一人，解散队伍</li><li>如果是队长退出，权限转移给第二个人（根据 JoinTime)</li><li>非队长，自己退出队伍，队伍人数 -1</li></ol></li></ol><h4 id="6-队长解散队伍"><a href="#6-队长解散队伍" class="headerlink" title="6.队长解散队伍"></a>6.队长解散队伍</h4><p>请求参数：队伍 id</p><ol><li>校验请求参数</li><li>校验队伍是否存在</li><li>校验是否为队长</li><li>移除所有加入队伍的关联信息</li><li>删除队伍</li></ol><p><strong>注意：一定要加上事务注解！</strong></p><h4 id="7-获取当前用户已加入的队伍"><a href="#7-获取当前用户已加入的队伍" class="headerlink" title="7.获取当前用户已加入的队伍"></a>7.获取当前用户已加入的队伍</h4><h4 id="8-获取当前用户创建的队伍"><a href="#8-获取当前用户创建的队伍" class="headerlink" title="8.获取当前用户创建的队伍"></a>8.获取当前用户创建的队伍</h4><p>复用 listTeam 方法，只新增查询条件，不做修改（开闭原则）</p><h3 id="使用事务注解"><a href="#使用事务注解" class="headerlink" title="使用事务注解"></a>使用事务注解</h3><p>@Trancational(rollbackFor &#x3D; Exception.class)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组队功能&quot;&gt;&lt;a href=&quot;#组队功能&quot; class=&quot;headerlink&quot; title=&quot;组队功能&quot;&gt;&lt;/a&gt;组队功能&lt;/h1&gt;&lt;h3 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库表设计</title>
    <link href="http://example.com/2022/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2022/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-12-08T08:06:28.949Z</published>
    <updated>2022-12-08T08:01:55.563Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><h4 id="队伍表-team"><a href="#队伍表-team" class="headerlink" title="队伍表 team"></a>队伍表 team</h4><p>字段：</p><ul><li>id 主键 bigint （最简单、连续，放 URL 上比较简短，但缺点是爬虫）</li><li>name 队伍名称</li><li>decription 描述</li><li>maxNum 最大人数</li><li>expireTime 过期时间</li><li>userId 创建人</li><li>status 0 - 公开， 1- 私密， 2 - 加密</li><li>password 队伍密码</li><li>createTime 创建时间</li><li>updateTime 更新时间</li><li>isDelete 是否删除</li></ul><h4 id="用户-队伍表-user-team"><a href="#用户-队伍表-user-team" class="headerlink" title="用户-队伍表 user_team"></a>用户-队伍表 user_team</h4><p>关系：</p><ol><li>用户加入了哪些队伍？</li><li>队伍有哪些用户？</li></ol><p>两种实现方式：</p><ol><li>建立用户-队伍关系表 teamId userId （便于修改，查询性能高一点，不用全表遍历）</li><li>用户表补充已加入的队伍字段，队伍表补充已加入的用户字段（便于查询，不用写多对多连表查询代码，可以直接根据队伍查用户、根据用户查队伍）</li></ol><p>字段：</p><ul><li>id 主键</li><li>userId 用户 id</li><li>teamId 队伍 id</li><li>joinTime 加入时间</li><li>createTime 创建时间</li><li>updateTime 更新时间</li><li>isDelete 是否删除</li></ul><h3 id="为什么需要请求参数包装类？"><a href="#为什么需要请求参数包装类？" class="headerlink" title="为什么需要请求参数包装类？"></a>为什么需要请求参数包装类？</h3><ol><li>请求参数名称 &#x2F; 类型和实体类不一样</li><li>有一些参数用不到，如果要自动生成接口文档，会增加理解成本（参数太多，冗余）</li><li>对个实体类映射到同一个对象</li></ol><h3 id="为什么需要包装类？"><a href="#为什么需要包装类？" class="headerlink" title="为什么需要包装类？"></a>为什么需要包装类？</h3><ol><li>存在有些字段需要隐藏，不能返回给前端，如用户密码</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据库表设计&quot;&gt;&lt;a href=&quot;#数据库表设计&quot; class=&quot;headerlink&quot; title=&quot;数据库表设计&quot;&gt;&lt;/a&gt;数据库表设计&lt;/h3&gt;&lt;h4 id=&quot;队伍表-team&quot;&gt;&lt;a href=&quot;#队伍表-team&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="数据库" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>定时任务实现-Redisson实现分布式锁</title>
    <link href="http://example.com/2022/12/08/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0-Redisson%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://example.com/2022/12/08/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0-Redisson%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2022-12-08T08:06:28.947Z</published>
    <updated>2022-12-08T08:00:14.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定时任务实现-Redisson实现分布式锁"><a href="#定时任务实现-Redisson实现分布式锁" class="headerlink" title="定时任务实现-Redisson实现分布式锁"></a>定时任务实现-Redisson实现分布式锁</h1><p>主要内容（后端）：</p><ol><li>分布式定时任务执行控制</li><li>锁的概念</li><li>分布式锁概念和常见问题</li><li>分布式锁实践</li></ol><h2 id="定时任务实现"><a href="#定时任务实现" class="headerlink" title="定时任务实现"></a>定时任务实现</h2><ol><li>Spring Scheduler (spring boot 默认整合了，推荐使用这种方式)</li><li>Quartz （独立于 Spring 存在的定时任务框架）</li><li>XXL-Job 之类的分布式任务调度平台（界面 + SDK）</li></ol><p>采用第一种方式：</p><ol><li>主类开启 @EnableScheduling</li><li>给要定时执行的方法添加 @Scheduling , 指定 cron 表达式或者执行频率</li></ol><p><strong>cron 表达式 用现成的工具即可：</strong><br><a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a><br><a href="https://www.matools.com/crontab/">https://www.matools.com/crontab/</a></p><h2 id="控制定时任务的执行"><a href="#控制定时任务的执行" class="headerlink" title="控制定时任务的执行"></a>控制定时任务的执行</h2><p>要控制定时任务在同一时间只有 1 台服务器能执行</p><p>原因：</p><ol><li>浪费资源</li><li>脏数据，比如重复插入</li></ol><p>如何做？</p><p>方案种类：</p><ol><li>分离定时任务程序和主程序，只在 1 个服务器运行定时任务，成本太大</li><li>写死配置，每个服务器都执行定时任务，但是只有 ip 符合配置的服务器才真正执行业务逻辑，其他的直接返回。成本最低；但是我们的 ip 可能不是固定的</li><li>动态配置，配置是可以轻松的、很方便地更新（代码无需重启），但是只有 ip 符合配置的服务器才真正执行业务逻辑。<ul><li>数据库</li><li>Redis</li><li>配置中心（Nacos、 Apollo、 Spring Cloud Config）</li></ul></li></ol><p>问题：服务器多了， ip 不可控还是很麻烦，还需要人工修改</p><ol start="4"><li><p>分布式锁，只有抢到锁的服务器才能执行业务逻辑。<br>缺点：增加成本；<br>优点：不用手动配置，多少服务器都一样</p><p><strong>注意：只要是单机，就会存在单点故障</strong></p></li></ol><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>有限资源的情况下，控制同一时间（段）只有某些线程（用户 &#x2F;  服务器）能访问资源</p><p>Java 实现锁：sychronized 关键字、并发包的类</p><p>存在的问题：只对单个 JVM 有效</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="使用分布式锁的原因："><a href="#使用分布式锁的原因：" class="headerlink" title="使用分布式锁的原因："></a>使用分布式锁的原因：</h3><ol><li>有限资源的情况下，控制同一时间（段）只有某些线程（用户 &#x2F;  服务器）能访问资源</li><li>Java 实现锁：sychronized 关键字、并发包的类</li></ol><h3 id="分布式锁的关键"><a href="#分布式锁的关键" class="headerlink" title="分布式锁的关键"></a>分布式锁的关键</h3><h4 id="抢锁机制"><a href="#抢锁机制" class="headerlink" title="抢锁机制"></a>抢锁机制</h4><p>怎么保证同一时间只有 1 台服务器能抢到锁？</p><p><strong>核心思想：</strong>先来的人先把数据改成自己的标识（服务器 ip），后来的人发现标识已存在，就抢锁失败，继续等待</p><p>等待先来的人执行方法结束，把标识清空，其他人继续抢锁</p><p>MYSQL 数据库：select for update 行级锁（最简单），或者用乐观锁</p><p>Redis 实现：内存数据库，读写速度快。支持 setnx、 lua 脚本，比较方便我们实现分布式锁</p><p>setnx: set if not exists 如果不存在，则设置；只有设置成功才返回 true ，否则返回 false</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>1）用锁要释放</p><p>2）锁一定要加过期时间</p><p>3）如果方法执行时间过长，锁会提前过期</p><p>锁提前过期会导致的问题：</p><ol><li>连锁反应：释放掉别人的锁</li><li>仍然存在多个方法同时执行的情况</li></ol><p>解决方案：续期</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">end</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(!end)&#123;</span><br><span class="line">        <span class="comment">//续期</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">end = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>4)释放锁的时候，有可能先判断出自己的锁，但这时锁过期了，最后也可能释放别人的锁</p><p>解决方案：Redis + lua 脚本保证操作原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原子操作</span></span><br><span class="line"><span class="keyword">if</span>(get lock == A)&#123;</span><br><span class="line">    <span class="comment">// set lock B</span></span><br><span class="line">    del lock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5)Redis 如果是集群（不是只有一个 Redis），如果分布式锁的数据不同步怎么办？</p><p>解决方案：<a href="https://blog.csdn.net/feiying0canglang/article/details/113258494">https://blog.csdn.net/feiying0canglang/article/details/113258494</a></p><h3 id="Redisson-实现分布式锁"><a href="#Redisson-实现分布式锁" class="headerlink" title="Redisson 实现分布式锁"></a>Redisson 实现分布式锁</h3><p>Redisson 是一个 Java 操作 Redis 的客户端，<strong>提供了大量的分布式数据集来简化对 Redis 的操作和使用，可以让开发者像使用本地集合一样使用 Redis（继承了和 Java 相同的集合类）</strong></p><p>关键词：Java Redis 客户端，分布式数据结构，实现了很多 Java 里支持的集合</p><h4 id="两种引用方式"><a href="#两种引用方式" class="headerlink" title="两种引用方式"></a>两种引用方式</h4><ol><li>spring boot starter 引入（不推荐，因为版本迭代太快，容易冲突）：<br><a href="https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter">https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter</a></li><li>直接引入：<a href="https://github.com/redisson/redisson#quick-start">https://github.com/redisson/redisson#quick-start</a></li></ol><h4 id="使用Redisson"><a href="#使用Redisson" class="headerlink" title="使用Redisson"></a>使用Redisson</h4><p>示例代码，创建分布式列表、Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    list 数据存在本地 JVM   内存中</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list:&quot;</span> + list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//    数据存在 Redis 内存中</span></span><br><span class="line">RList&lt;Object&gt; rList = redissonClient.getList(<span class="string">&quot;test-list&quot;</span>);</span><br><span class="line">rList.add(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;RList:&quot;</span> + rList.get(<span class="number">0</span>));</span><br><span class="line"><span class="comment">//rList.remove(0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    map</span></span><br><span class="line">RMap&lt;Object, Object&gt; map = redissonClient.getMap(<span class="string">&quot;test-map&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;yupi&quot;</span>, <span class="number">10</span>);</span><br><span class="line">map.get(<span class="string">&quot;yupi&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="分布式锁保证定时任务不重复执行"><a href="#分布式锁保证定时任务不重复执行" class="headerlink" title="分布式锁保证定时任务不重复执行"></a>分布式锁保证定时任务不重复执行</h4><p>实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testWatchDog</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;yupao:precachejob:docache:lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//只有一个线程获取到锁</span></span><br><span class="line">        <span class="keyword">if</span>(lock.tryLock(<span class="number">0</span>, -<span class="number">1</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line"><span class="comment">// TODO 实际要执行的方法</span></span><br><span class="line">            dosomething();</span><br><span class="line">            System.out.println(<span class="string">&quot;getLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//    只能释放自己的锁</span></span><br><span class="line">        <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;unLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>waitTime 设置为 0，只抢一次，抢不到就放弃</li><li>主要释放锁要写在 finally 语句块中，保证最后一定释放锁</li></ol><h4 id="Redisson-看门狗机制"><a href="#Redisson-看门狗机制" class="headerlink" title="Redisson 看门狗机制"></a>Redisson 看门狗机制</h4><p>Redisson 中提供的续期机制</p><p>开一个监听线程，如果方法还没执行完，就帮你重置 Redis 锁的过期时间</p><p><strong>原理：</strong></p><ol><li>监听当前线程，默认过期时间是 30 秒，每 10 秒续期一次（续期到 30 秒）</li><li>如果线程挂掉（注意 debug 模式也会被它当成服务器宕机），则不会续期</li></ol><p>详情参考文档：<a href="https://blog.csdn.net/qq_26222859/article/details/79645203">https://blog.csdn.net/qq_26222859/article/details/79645203</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定时任务实现-Redisson实现分布式锁&quot;&gt;&lt;a href=&quot;#定时任务实现-Redisson实现分布式锁&quot; class=&quot;headerlink&quot; title=&quot;定时任务实现-Redisson实现分布式锁&quot;&gt;&lt;/a&gt;定时任务实现-Redisson实现分布式锁&lt;/</summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="定时任务" scheme="http://example.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/08/%E7%AC%AC%E4%B8%83%E9%9B%86-Redis%20%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://example.com/2022/12/08/%E7%AC%AC%E4%B8%83%E9%9B%86-Redis%20%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</id>
    <published>2022-12-08T08:06:28.942Z</published>
    <updated>2022-11-09T23:41:45.459Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="第七集-Redis-缓存实现-定时任务"><a href="#第七集-Redis-缓存实现-定时任务" class="headerlink" title="第七集-Redis 缓存实现-定时任务"></a>第七集-Redis 缓存实现-定时任务</h1><p>主要内容（后端）：<br>1.缓存和分布式缓存讲解<br>2.Redis介绍(5种数据结构等)<br>3.Java操作Redis的方法(4种方法+对比分析)<br>4.Java Redis Template序列化（包含源码追踪）<br>5.首页缓存开发与注意事项<br>6.缓存预热设计与实现<br>7.定时任务介绍和实现</p><h2 id="数据查询慢怎么办？"><a href="#数据查询慢怎么办？" class="headerlink" title="数据查询慢怎么办？"></a>数据查询慢怎么办？</h2><ul><li><p>用缓存：提前把数据取出来保存好（通过保存到读写更快的介质，比如内存）</p></li><li><p>用定时任务：预加载缓存，定时更新缓存</p></li></ul><p>思考：多个机器要执行同一个任务吗？</p><p>可以用用分布式锁解决：控制同一时间只有一台机器去执行定时任务，其他机器不用重复执行了</p><h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><p>分布式缓存：</p><ul><li>Redis（分布式缓存）</li><li>mencached(分布式)</li><li>Etcd （云原生架构的一个分布式存储，<strong>存储配置</strong>，扩容能力）</li></ul><p>单机缓存：</p><ul><li>ehcache</li><li>Java 内存集合，如 HashMap</li><li>Caffeine （Java 内存缓存性能之王，高性能）</li><li>Google Guava</li></ul><h2 id="Redis-缓存实现"><a href="#Redis-缓存实现" class="headerlink" title="Redis 缓存实现"></a>Redis 缓存实现</h2><p>NoSQL 数据库</p><p>key-value 存储系统（区别于 MYSQL 它存储的是键值对）</p><h3 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h3><p>基本数据结构：</p><ul><li>String 字符串类型：name:”mofeng”</li><li>List 列表：names:[“mofeng”,”dogmofeng”,”lu”]</li><li>Set 集合：names:[“mofeng”,”lu”] (值不能重复)</li><li>Hash 哈希：nameAge:{“mofeng”:1,”dogLu”:2}</li><li>Zset 集合：names[mofeng -9, doglu -12] (适合排行榜)</li></ul><p>高级：</p><ul><li>bloomfilter(布隆过滤器，主要从大量的数据中快速过滤值，比如邮件黑名单拦截)</li><li>geo(计算地理位置)</li><li>hyperloglog(pv&#x2F;uv)</li><li>pub&#x2F;sub(发布订阅，类以消息队列)</li><li>BitMap(1001010101010101010101010101)</li></ul><h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><p>为了防止写入 Redis 的数据乱码、浪费空间等，可以自定义序列化器，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.yupao.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTemplateConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-操作-Redis"><a href="#Java-操作-Redis" class="headerlink" title="Java 操作 Redis"></a>Java 操作 Redis</h3><p><strong>Spring Data Redis （推荐）</strong></p><p>地址：<a href="https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis">https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis</a></p><p>Spring Data：通用的数据访问框架，定义了一组 <strong>增删改查</strong>的接口</p><p>还可以操作：mysql、Redis、jpa</p><p>使用方式如下：</p><p>1）引入 Spring Data Redis 依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.6</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2）配置 Redis 地址</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># redis 配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>独立与 Spring 操作 Redis 的 Java 客户端</p><p>要配合 Jedis Pool 使用</p><h4 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h4><p><strong>高阶</strong>的操作 Redis 的 Java 客户端</p><p>异步、连接池</p><h4 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h4><p>分布式操作 Redis 的 Java 客户端，像使用本地集合一样操作 Redis （分布式 Redis 数据网络）</p><h4 id="几种库对比"><a href="#几种库对比" class="headerlink" title="几种库对比"></a>几种库对比</h4><ol><li>如果项目用的是 Spring，并且没有过多的定制化要求，可以用 Spring Data Redis，最方便</li><li>如果项目用的不是 Spring，并且追求简单，并且没有过高的性能要求，可以 Jedis + Jedis Pool</li><li>如果项目用的不是 Spring，并且追求高性能、高定制化，可以用 Lettuce ，支持异步、连接池</li><li>如果是分布式项目，需要用到一些分布式的特性（比如分布式锁、分布式集合），推荐使用 Redisson</li></ol><h3 id="设计缓存-key"><a href="#设计缓存-key" class="headerlink" title="设计缓存 key"></a>设计缓存 key</h3><p>关键点：不同用户看到的数据不同</p><p>建议格式：</p><p>systemId:moduleld:fuc:options (防止其他系统的冲突)</p><p>比如：yupao:user:recommend:userId</p><p><strong>注意：Redis 内存不能无限增加，一定要设置过期时间！！！</strong></p><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>问题：即使使用了缓存，第一个用户访问还是很慢</p><p>缓存预热的优点：</p><ol><li>解决第一个用户访问很慢，让用户始终快速访问</li><li>在一定程度上保护数据库</li></ol><p>缺点：</p><ol><li>增加开发成本（额外的开发、设计等）</li><li>预热的时机和时间错了，缓存的数据不对或者是未更新的数据</li><li>需要占用额外空间</li></ol><h3 id="怎么缓存预热"><a href="#怎么缓存预热" class="headerlink" title="怎么缓存预热"></a>怎么缓存预热</h3><ol><li>定时任务</li><li>手动触发</li></ol><h3 id="实现缓存预热"><a href="#实现缓存预热" class="headerlink" title="实现缓存预热"></a>实现缓存预热</h3><p>用定时任务，每天刷新所有用户的推荐列表</p><p>注意点：</p><ol><li>缓存预热的意义（新增少、总用户多）</li><li>缓存的空间不能太大，要预留给其他缓存空间</li><li>缓存数据的周期（此处为每天）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;第七集-Redis-缓存实现-定时任务&quot;&gt;&lt;a href=&quot;#第七集-Redis-缓存实现-定时任务&quot; class=&quot;headerlink&quot; title=&quot;第七集-Redis 缓存实现-定时任务&quot;&gt;&lt;/a&gt;第七集-Redis 缓存实现-定</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring 注解使用</title>
    <link href="http://example.com/2022/12/08/Spring%20%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/12/08/Spring%20%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/</id>
    <published>2022-12-08T08:06:28.939Z</published>
    <updated>2022-12-08T07:54:01.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-注解使用"><a href="#Spring-注解使用" class="headerlink" title="Spring 注解使用"></a>Spring 注解使用</h1><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p> 该注解有一个prefix属性，通过指定的前缀，绑定配置文件中的配置，该注解可以放在类上，也可以放在方法上 </p><p> <strong>当将该注解作用于方法上时，如果想要有效的绑定配置，那么该方法需要有@Bean注解且所属Class需要有@Configuration注解。</strong> </p><p>application.yml 配置文件的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用参考代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisAddress</span> <span class="operator">=</span> String.format(<span class="string">&quot;redis://%s:%s&quot;</span>, host, port);</span><br><span class="line">        config.useSingleServer().setAddress(redisAddress).setDatabase(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 2. 创建实例</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">        <span class="keyword">return</span> redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trancational-rollbackFor-x3D-Exception-class"><a href="#Trancational-rollbackFor-x3D-Exception-class" class="headerlink" title="@Trancational(rollbackFor &#x3D; Exception.class)"></a>@Trancational(rollbackFor &#x3D; Exception.class)</h2><p>声明式事务管理，添加位置为<strong>接口实现类、接口实现方法上</strong></p><p>默认配置下， Spring 只有抛出的异常为运行时， unchecked 异常时才会回滚该事务。即抛异常为 RunTimeException 的子类 （Error 也会导致事务回滚），抛出 checked 异常不会导致事务回滚。可通过 rollbackFor 来配置</p><h2 id="CrossOrigin"><a href="#CrossOrigin" class="headerlink" title="@CrossOrigin"></a>@CrossOrigin</h2><p>解决跨域问题，默认情况下允许在该注解中指定的所有源和 HTTP 方法</p><ul><li><strong>origins</strong>： 允许可访问的域列表</li><li><strong>maxAge</strong>:准备响应前的缓存持续的最大时间（以秒为单位）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &#123;&quot;http://127.0.0.1:5173/&quot;&#125;, allowCredentials = &quot;true&quot;)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-注解使用&quot;&gt;&lt;a href=&quot;#Spring-注解使用&quot; class=&quot;headerlink&quot; title=&quot;Spring 注解使用&quot;&gt;&lt;/a&gt;Spring 注解使用&lt;/h1&gt;&lt;h2 id=&quot;ConfigurationProperties&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="spring注解" scheme="http://example.com/tags/spring%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Session 共享实现</title>
    <link href="http://example.com/2022/12/08/Session%20%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/12/08/Session%20%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-12-08T08:06:28.937Z</published>
    <updated>2022-12-08T07:52:18.406Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Session-共享实现"><a href="#Session-共享实现" class="headerlink" title="Session 共享实现"></a>Session 共享实现</h3><h4 id="1-安装-Redis"><a href="#1-安装-Redis" class="headerlink" title="1. 安装 Redis"></a>1. 安装 Redis</h4><p>官网：<a href="https://redis.io/">https://redis.io/</a></p><p>windows 下载：</p><p>Redis 5.0.14 下载：</p><p>链接：<a href="https://pan.baidu.com/s/1XcsAIrdeesQAyQU2lE3cOg">https://pan.baidu.com/s/1XcsAIrdeesQAyQU2lE3cOg</a> </p><p>提取码：vkoi </p><p>redis 管理工具 quick redis：<a href="https://quick123.net/">https://quick123.net/</a></p><ol start="2"><li>引入 redis，能够操作 redis：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>在 application.yml 中配置 Redis</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring</span><br><span class="line"># redis 配置</span><br><span class="line">  redis:</span><br><span class="line">    port: 6379</span><br><span class="line">    host: localhost</span><br><span class="line">    database: 0</span><br></pre></td></tr></table></figure></li><li><p>引入 spring-session 和 redis 的整合，使得自动将 session 存储到 redis 中：</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.session/spring-session-data-redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><pre><code class="xml">  session:    timeout: 86400    store-type: redis</code></pre></li><li><p>修改 spring-session 存储配置 <code>spring.session.store-type</code></p><p>默认是 none，表示存储在单台服务器</p><p>store-type: redis，表示从 redis 读写 session</p></li></ol><p>JWT 的优缺点：<a href="https://zhuanlan.zhihu.com/p/108999941">https://zhuanlan.zhihu.com/p/108999941</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Session-共享实现&quot;&gt;&lt;a href=&quot;#Session-共享实现&quot; class=&quot;headerlink&quot; title=&quot;Session 共享实现&quot;&gt;&lt;/a&gt;Session 共享实现&lt;/h3&gt;&lt;h4 id=&quot;1-安装-Redis&quot;&gt;&lt;a href=&quot;#1-安</summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
    <category term="Session" scheme="http://example.com/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>Redisson 实现分布式锁</title>
    <link href="http://example.com/2022/12/08/Redisson%20%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E5%85%B7%E4%BD%93)/"/>
    <id>http://example.com/2022/12/08/Redisson%20%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E5%85%B7%E4%BD%93)/</id>
    <published>2022-12-08T08:06:28.935Z</published>
    <updated>2022-12-08T07:50:53.736Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redisson-实现分布式锁"><a href="#Redisson-实现分布式锁" class="headerlink" title="Redisson 实现分布式锁"></a>Redisson 实现分布式锁</h3><p>Redisson 是一个 Java 操作 Redis 的客户端，<strong>提供了大量的分布式数据集来简化对 Redis 的操作和使用，可以让开发者像使用本地集合一样使用 Redis（继承了和 Java 相同的集合类）</strong></p><p>关键词：Java Redis 客户端，分布式数据结构，实现了很多 Java 里支持的集合</p><h4 id="两种引用方式"><a href="#两种引用方式" class="headerlink" title="两种引用方式"></a>两种引用方式</h4><ol><li>spring boot starter 引入（不推荐，因为版本迭代太快，容易冲突）：<br><a href="https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter">https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter</a></li><li>直接引入：<a href="https://github.com/redisson/redisson#quick-start">https://github.com/redisson/redisson#quick-start</a></li></ol><p>(1)引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.17</span><span class="number">.5</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>(2)新建 RedissonConfig 配置类,配置地址、端口、创建实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Redisson 配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2022/11/10 23:58</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisAddress</span> <span class="operator">=</span> String.format(<span class="string">&quot;redis://%s:%s&quot;</span>, host, port);</span><br><span class="line">        config.useSingleServer().setAddress(redisAddress).setDatabase(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 2. 创建实例</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">        <span class="keyword">return</span> redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Redisson"><a href="#使用Redisson" class="headerlink" title="使用Redisson"></a>使用Redisson</h4><p>创建分布式列表、Map，新建测试类示例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//    list 数据存在本地 JVM   内存中</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;list:&quot;</span> + list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    数据存在 Redis 内存中</span></span><br><span class="line">    RList&lt;Object&gt; rList = redissonClient.getList(<span class="string">&quot;test-list&quot;</span>);</span><br><span class="line">    rList.add(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;RList:&quot;</span> + rList.get(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//rList.remove(0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    map</span></span><br><span class="line">    RMap&lt;Object, Object&gt; map = redissonClient.getMap(<span class="string">&quot;test-map&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;yupi&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    map.get(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;yupi&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分布式锁保证定时任务不重复执行"><a href="#分布式锁保证定时任务不重复执行" class="headerlink" title="分布式锁保证定时任务不重复执行"></a>分布式锁保证定时任务不重复执行</h4><p>实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testWatchDog</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;yupao:precachejob:docache:lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//只有一个线程获取到锁</span></span><br><span class="line">        <span class="keyword">if</span>(lock.tryLock(<span class="number">0</span>, -<span class="number">1</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line"><span class="comment">// TODO 实际要执行的方法</span></span><br><span class="line">            dosomething();</span><br><span class="line">            System.out.println(<span class="string">&quot;getLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//    只能释放自己的锁</span></span><br><span class="line">        <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;unLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>waitTime 设置为 0，只抢一次，抢不到就放弃</li><li>主要释放锁要写在 finally 语句块中，保证最后一定释放锁</li></ol><h4 id="Redisson-看门狗机制"><a href="#Redisson-看门狗机制" class="headerlink" title="Redisson 看门狗机制"></a>Redisson 看门狗机制</h4><p>Redisson 中提供的续期机制</p><p>开一个监听线程，如果方法还没执行完，就帮你重置 Redis 锁的过期时间</p><p><strong>原理：</strong></p><ol><li>监听当前线程，默认过期时间是 30 秒，每 10 秒续期一次（续期到 30 秒）</li><li>如果线程挂掉（注意 debug 模式也会被它当成服务器宕机），则不会续期</li></ol><p>详情参考文档：<a href="https://blog.csdn.net/qq_26222859/article/details/79645203">https://blog.csdn.net/qq_26222859/article/details/79645203</a></p><p>定时任务全部代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.yupi.yupao.model.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.yupi.yupao.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 预热缓存任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2022/11/10 6:03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreCacheJob</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; mainUserList = Arrays.asList(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每天执行预热推荐用户 cronTable 在线表达式生成 https://cron.qqe2.com/</span></span><br><span class="line">    <span class="comment">// 前面三个参数： 秒 分 时</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 37 1 * * *&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCacheRecommendUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取到 锁对象</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;yupao:precachejob:docache:lock&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//只有一个线程获取到锁</span></span><br><span class="line">            <span class="keyword">if</span>(lock.tryLock(<span class="number">0</span>, -<span class="number">1</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;getLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">                <span class="keyword">for</span> (Long userId : mainUserList) &#123;</span><br><span class="line">                    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">                    Page&lt;User&gt; userPage = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">20</span>), queryWrapper);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> String.format(<span class="string">&quot;yupao:user:recommend:%s&quot;</span>, userId);</span><br><span class="line">                    ValueOperations&lt;String, Object&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">                    <span class="comment">//写缓存</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//指定缓存 30 秒过期</span></span><br><span class="line">                        valueOperations.set(redisKey, userPage, <span class="number">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;redis set key error&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;doCacheRecommendUser error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//    只能释放自己的锁</span></span><br><span class="line">            <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;unLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Redisson-实现分布式锁&quot;&gt;&lt;a href=&quot;#Redisson-实现分布式锁&quot; class=&quot;headerlink&quot; title=&quot;Redisson 实现分布式锁&quot;&gt;&lt;/a&gt;Redisson 实现分布式锁&lt;/h3&gt;&lt;p&gt;Redisson 是一个 Java </summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis 缓存实现</title>
    <link href="http://example.com/2022/12/08/Redis%20%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E5%92%8C%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E4%BB%BB%E5%8A%A1/"/>
    <id>http://example.com/2022/12/08/Redis%20%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E5%92%8C%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E4%BB%BB%E5%8A%A1/</id>
    <published>2022-12-08T08:06:28.933Z</published>
    <updated>2022-12-08T07:46:53.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-缓存实现"><a href="#Redis-缓存实现" class="headerlink" title="Redis 缓存实现"></a>Redis 缓存实现</h2><p>NoSQL 数据库</p><p>key-value 存储系统（区别于 MYSQL 它存储的是键值对）</p><h3 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h3><p>基本数据结构：</p><ul><li>String 字符串类型：name:”mofeng”</li><li>List 列表：names:[“mofeng”,”dogmofeng”,”lu”]</li><li>Set 集合：names:[“mofeng”,”lu”] (值不能重复)</li><li>Hash 哈希：nameAge:{“mofeng”:1,”dogLu”:2}</li><li>Zset 集合：names[mofeng -9, doglu -12] (适合排行榜)</li></ul><p>高级：</p><ul><li>bloomfilter(布隆过滤器，主要从大量的数据中快速过滤值，比如邮件黑名单拦截)</li><li>geo(计算地理位置)</li><li>hyperloglog(pv&#x2F;uv)</li><li>pub&#x2F;sub(发布订阅，类以消息队列)</li><li>BitMap(1001010101010101010101010101)</li></ul><h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><p>为了防止写入 Redis 的数据乱码、浪费空间等，可以自定义序列化器，</p><p>新建 RedisTemplateConfig 类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTemplateConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller 层代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主页 推荐用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageNum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/recommend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;Page&lt;User&gt;&gt; <span class="title function_">recommendUsers</span><span class="params">(<span class="type">long</span> pageSize, <span class="type">long</span> pageNum, HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">loginUser</span> <span class="operator">=</span> userService.getLoginUser(request);</span><br><span class="line">    <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> String.format(<span class="string">&quot;yupao:user:recommend:%s&quot;</span>, loginUser.getId());</span><br><span class="line">    ValueOperations&lt;String, Object&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">    <span class="comment">// 判断是否有缓存，有则直接读缓存</span></span><br><span class="line">    Page&lt;User&gt; userPage = (Page&lt;User&gt;) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">    <span class="keyword">if</span>(userPage != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ResultUtils.success(userPage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无缓存，则查询数据库</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    userPage = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(pageNum, pageSize), queryWrapper);</span><br><span class="line">    <span class="comment">//写缓存</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//指定缓存 30 秒过期</span></span><br><span class="line">        valueOperations.set(redisKey, userPage, <span class="number">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;redis set key error&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ResultUtils.success(userPage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Spring-Data-Redis-操作-Redis"><a href="#使用-Spring-Data-Redis-操作-Redis" class="headerlink" title="使用 Spring Data Redis 操作 Redis"></a>使用 Spring Data Redis 操作 Redis</h3><p><strong>Spring Data Redis （推荐）</strong></p><p>地址：<a href="https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis">https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis</a></p><p>Spring Data：通用的数据访问框架，定义了一组 <strong>增删改查</strong>的接口</p><p>还可以操作：mysql、Redis、jpa</p><p>使用方式如下：</p><p>1）引入 Spring Data Redis 依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.6</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2）配置 Redis 地址</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># redis 配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="设计缓存-key"><a href="#设计缓存-key" class="headerlink" title="设计缓存 key"></a>设计缓存 key</h3><p>关键点：不同用户看到的数据不同</p><p>建议格式：</p><p>systemId:moduleld:fuc:options (防止其他系统的冲突)</p><p>比如：yupao:user:recommend:userId</p><p><strong>注意：Redis 内存不能无限增加，一定要设置过期时间！！！</strong></p><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>问题：即使使用了缓存，第一个用户访问还是很慢</p><p>缓存预热的优点：</p><ol><li>解决第一个用户访问很慢，让用户始终快速访问</li><li>在一定程度上保护数据库</li></ol><p>缺点：</p><ol><li>增加开发成本（额外的开发、设计等）</li><li>预热的时机和时间错了，缓存的数据不对或者是未更新的数据</li><li>需要占用额外空间</li></ol><h3 id="怎么缓存预热"><a href="#怎么缓存预热" class="headerlink" title="怎么缓存预热"></a>怎么缓存预热</h3><ol><li>定时任务</li><li>手动触发</li></ol><h3 id="实现缓存预热"><a href="#实现缓存预热" class="headerlink" title="实现缓存预热"></a>实现缓存预热</h3><p>用定时任务，每天刷新所有用户的推荐列表</p><p>注意点：</p><ol><li>缓存预热的意义（新增少、总用户多）</li><li>缓存的空间不能太大，要预留给其他缓存空间</li><li>缓存数据的周期（此处为每天）</li></ol><p><strong>在 main 主类添加注解 @EnableScheduling</strong></p><p>cronTable 在线表达式生成，地址：<a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面三个参数： 秒 分 时</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 38 6 * * *&quot;)</span></span><br></pre></td></tr></table></figure><p>新建 PreCacheJob 类实现缓存预热任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.yupi.yupao.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.yupi.yupao.model.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.yupi.yupao.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 预热缓存任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2022/11/10 6:03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreCacheJob</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; mainUserList = Arrays.asList(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每天执行预热推荐用户 cronTable 在线表达式生成 https://cron.qqe2.com/</span></span><br><span class="line">    <span class="comment">// 前面三个参数： 秒 分 时</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 38 6 * * *&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCacheRecommendUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Long userId : mainUserList) &#123;</span><br><span class="line">            QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">            Page&lt;User&gt; userPage = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">20</span>), queryWrapper);</span><br><span class="line">            <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> String.format(<span class="string">&quot;yupao:user:recommend:%s&quot;</span>, userId);</span><br><span class="line">            ValueOperations&lt;String, Object&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">            <span class="comment">//写缓存</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//指定缓存 30 秒过期</span></span><br><span class="line">                valueOperations.set(redisKey, userPage, <span class="number">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;redis set key error&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis-缓存实现&quot;&gt;&lt;a href=&quot;#Redis-缓存实现&quot; class=&quot;headerlink&quot; title=&quot;Redis 缓存实现&quot;&gt;&lt;/a&gt;Redis 缓存实现&lt;/h2&gt;&lt;p&gt;NoSQL 数据库&lt;/p&gt;
&lt;p&gt;key-value 存储系统（区别于 MY</summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis plus 实现分页</title>
    <link href="http://example.com/2022/12/08/Mybatis%20plus%20%E5%88%86%E9%A1%B5/"/>
    <id>http://example.com/2022/12/08/Mybatis%20plus%20%E5%88%86%E9%A1%B5/</id>
    <published>2022-12-08T08:06:28.930Z</published>
    <updated>2022-12-08T07:43:32.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-plus-分页"><a href="#Mybatis-plus-分页" class="headerlink" title="Mybatis plus 分页"></a>Mybatis plus 分页</h1><p>创建 MyBatisPlusConfig 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yupi.yupao.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题(该属性会在旧插件移除后一同移除)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/recommend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;Page&lt;User&gt;&gt; <span class="title function_">recommendUsers</span><span class="params">(<span class="type">long</span> pageSize, <span class="type">long</span> pageNum, HttpServletRequest request)</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    Page&lt;User&gt; userList = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(pageNum, pageSize), queryWrapper);</span><br><span class="line">    <span class="keyword">return</span> ResultUtils.success(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">onMounted(async () =&gt;&#123;</span><br><span class="line"><span class="comment">// Optionally the request above could also be done as</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">userListData</span> <span class="operator">=</span> await myAxios.get(<span class="string">&#x27;/user/recommend&#x27;</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      pageSize: <span class="number">8</span>,</span><br><span class="line">      pageNum: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">      .then(function (response) &#123;</span><br><span class="line">        console.log(<span class="string">&#x27;/user/recommend succeed&#x27;</span>, response);</span><br><span class="line">        Toast.success(<span class="string">&#x27;请求成功&#x27;</span>);</span><br><span class="line">        console.log(response.data.data)</span><br><span class="line">        <span class="keyword">return</span> response?.data?.records;</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="keyword">catch</span>(function (error) &#123;</span><br><span class="line">        console.error(<span class="string">&#x27;/user/recommend error&#x27;</span>, error);</span><br><span class="line">        Toast.fail(<span class="string">&#x27;请求失败&#x27;</span>);</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(userListData)&#123;</span><br><span class="line">    userListData.forEach(user =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(user.tags)&#123;</span><br><span class="line">        user.tags = JSON.parse(user.tags)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    userList.value = userListData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mybatis-plus-分页&quot;&gt;&lt;a href=&quot;#Mybatis-plus-分页&quot; class=&quot;headerlink&quot; title=&quot;Mybatis plus 分页&quot;&gt;&lt;/a&gt;Mybatis plus 分页&lt;/h1&gt;&lt;p&gt;创建 MyBatisPlusConf</summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Mybatis" scheme="http://example.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>整合 Swagger + Knife4j 接口文档</title>
    <link href="http://example.com/2022/12/08/Java%20%E5%90%8E%E7%AB%AF%E6%95%B4%E5%90%88%20Swagger%20+%20Knife4j%20%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2022/12/08/Java%20%E5%90%8E%E7%AB%AF%E6%95%B4%E5%90%88%20Swagger%20+%20Knife4j%20%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</id>
    <published>2022-12-08T08:06:28.926Z</published>
    <updated>2022-12-08T07:41:06.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-后端整合-Swagger-Knife4j-接口文档"><a href="#Java-后端整合-Swagger-Knife4j-接口文档" class="headerlink" title="Java 后端整合 Swagger + Knife4j 接口文档"></a>Java 后端整合 Swagger + Knife4j 接口文档</h1><p>官方文档： <a href="https://doc.xiaominfo.com/docs/quick-start">https://doc.xiaominfo.com/docs/quick-start</a> </p><p>1.引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入Knife4j的官方start包,Swagger2基于Springfox2<span class="number">.10</span><span class="number">.5</span>项目--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">    &lt;!--使用Swagger2--&gt;</span><br><span class="line">    &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.0</span><span class="number">.9</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.添加配置类，<strong>注意：basePackage 需要填写 controller 的路径</strong></p><p>千万注意：线上环境不要把接口暴露出去！！！可以通过在 SwaggerConfig 配置文件开头加上 <code>@Profile(&#123;&quot;dev&quot;, &quot;test&quot;&#125;)</code> 限定配置仅在部分环境开启</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2WebMvc</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Knife4jConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;dockerBean&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">dockerBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//指定使用Swagger2规范</span></span><br><span class="line">        Docket docket=<span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(<span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                <span class="comment">//描述字段支持Markdown语法</span></span><br><span class="line">                .description(<span class="string">&quot;# Knife4j RESTful APIs&quot;</span>)</span><br><span class="line">                .termsOfServiceUrl(<span class="string">&quot;https://doc.xiaominfo.com/&quot;</span>)</span><br><span class="line">                .contact(<span class="string">&quot;xiaoymin@foxmail.com&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build())</span><br><span class="line">                <span class="comment">//分组名称</span></span><br><span class="line">                .groupName(<span class="string">&quot;用户服务&quot;</span>)</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//这里指定Controller扫描包路径</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.yupi.yupao.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> docket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 如果开发者使用的是Knife4j 2.x版本，并且Spring Boot版本高于2.4,那么需要在Spring Boot的yml文件中做如下配置： </p><p>3.在 application.yml 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    mvc:</span><br><span class="line">        pathmatch:</span><br><span class="line">            # 配置策略</span><br><span class="line">            matching-strategy: ant-path-matcher</span><br></pre></td></tr></table></figure><p>4.controller类中备注接口相应的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &quot;首页模块&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiImplicitParam(name = &quot;name&quot;,value = &quot;姓名&quot;,required = true)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;向客人问好&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sayHi&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">sayHi</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;)</span>String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;Hi:&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.访问地址，<strong>注意端口、实际的地址</strong></p><p>端口对应，正常访问<a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></p><p>如果配置类当中有配置路径，则需要加上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8888</span></span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /api</span><br></pre></td></tr></table></figure><p>该地址访问：<a href="http://localhost:8888/api/doc.html">http://localhost:8888/api/doc.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-后端整合-Swagger-Knife4j-接口文档&quot;&gt;&lt;a href=&quot;#Java-后端整合-Swagger-Knife4j-接口文档&quot; class=&quot;headerlink&quot; title=&quot;Java 后端整合 Swagger + Knife4j 接口文档</summary>
      
    
    
    
    <category term="开源组件" scheme="http://example.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
    
    <category term="Knife4j" scheme="http://example.com/tags/Knife4j/"/>
    
    <category term="Swagger" scheme="http://example.com/tags/Swagger/"/>
    
  </entry>
  
  <entry>
    <title>伙伴匹配系统 bug</title>
    <link href="http://example.com/2022/12/08/bug%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/12/08/bug%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2022-12-08T08:06:28.924Z</published>
    <updated>2022-12-08T07:35:39.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bug-解决"><a href="#bug-解决" class="headerlink" title="bug 解决"></a>bug 解决</h1><h2 id="前后端分离跨域问题"><a href="#前后端分离跨域问题" class="headerlink" title="前后端分离跨域问题"></a>前后端分离跨域问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &#123;&quot;http://127.0.0.1:5173/&quot;&#125;, allowCredentials = &quot;true&quot;)</span></span><br></pre></td></tr></table></figure><p>或者添加配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfg</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//设置允许跨域的路径</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">//设置允许跨域请求的域名</span></span><br><span class="line">               .allowedOrigins(<span class="string">&quot;http://127.0.0.1:9527&quot;</span>,<span class="string">&quot;http://127.0.0.1:8000&quot;</span>)</span><br><span class="line">                <span class="comment">//是否允许证书 不再默认开启</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">//设置允许的方法</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">//跨域允许时间</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跨域请求不支持-cookie-操作"><a href="#跨域请求不支持-cookie-操作" class="headerlink" title="跨域请求不支持 cookie 操作"></a>跨域请求不支持 cookie 操作</h2><p>1.添加依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-session-core&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>添加配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.yupao.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.session.DefaultCookieSerializerCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.session.MapSessionRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.session.SessionRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.session.config.annotation.web.http.EnableSpringHttpSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.session.web.http.DefaultCookieSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSpringHttpSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SessionRepository <span class="title function_">sessionRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MapSessionRepository</span>(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DefaultCookieSerializerCustomizer <span class="title function_">cookieSerializerCustomizer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultCookieSerializerCustomizer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customize</span><span class="params">(DefaultCookieSerializer cookieSerializer)</span> &#123;</span><br><span class="line">                cookieSerializer.setSameSite(<span class="string">&quot;None&quot;</span>);</span><br><span class="line">                cookieSerializer.setUseSecureCookie(<span class="literal">true</span>); <span class="comment">// 此项必须，否则set-cookie会被chrome浏览器阻拦</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="加入加密队伍时，密码没正确验证"><a href="#加入加密队伍时，密码没正确验证" class="headerlink" title="加入加密队伍时，密码没正确验证"></a>加入加密队伍时，密码没正确验证</h2><p>修改 TeamServiceimpl 中 JoinTeam（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> team.getPassword();</span><br><span class="line"><span class="type">String</span> <span class="variable">requestPassword</span> <span class="operator">=</span> teamJoinRequest.getPassword();</span><br><span class="line"><span class="keyword">if</span>(TeamStatusEnum.SECRET.equals(teamStatusEnum))&#123;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(requestPassword) || !requestPassword.equals(team.getPassword()))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.PARAMS_ERROR, <span class="string">&quot;队伍密码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h2><p>&#x3D;&#x3D;SyntaxError: JSON.parse: unexpected character at line 1 colimn 2 of the JSON&#x3D;&#x3D;</p><p>JSON.parse 标准格式为单引号包裹双引号的格式 如 [“男”, “大一”]， 而 &#x3D;&#x3D;[‘南宁’, ‘本地’]&#x3D;&#x3D; 则会报错</p><p>参考地址：<a href="https://www.runoob.com/json/json-parse.html">https://www.runoob.com/json/json-parse.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;bug-解决&quot;&gt;&lt;a href=&quot;#bug-解决&quot; class=&quot;headerlink&quot; title=&quot;bug 解决&quot;&gt;&lt;/a&gt;bug 解决&lt;/h1&gt;&lt;h2 id=&quot;前后端分离跨域问题&quot;&gt;&lt;a href=&quot;#前后端分离跨域问题&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="bug" scheme="http://example.com/tags/bug/"/>
    
    <category term="跨域" scheme="http://example.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
    <category term="JSON" scheme="http://example.com/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>匹配算法-优化</title>
    <link href="http://example.com/2022/12/08/12-13%20%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95-%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2022/12/08/12-13%20%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95-%E4%BC%98%E5%8C%96/</id>
    <published>2022-12-08T08:06:28.922Z</published>
    <updated>2022-12-08T07:58:14.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="12-13-匹配算法-优化"><a href="#12-13-匹配算法-优化" class="headerlink" title="12-13 匹配算法-优化"></a>12-13 匹配算法-优化</h1><p>主要内容：</p><ol><li>开发完成个人队伍页面、队伍检索等功能（前端、后端）</li><li>开发用户匹配功能（编辑距离算法）</li><li>优化用户匹配功能后端，开发前端用户匹配模式</li><li>优化前端加载效果，使用骨架屏</li><li>优化前端队伍操作权限</li><li>实现前端导航标题动态切换</li><li>优化前端、完善部分功能</li></ol><h2 id="前端不同页面怎么传递数据？"><a href="#前端不同页面怎么传递数据？" class="headerlink" title="前端不同页面怎么传递数据？"></a>前端不同页面怎么传递数据？</h2><ol><li>url querystring (xxx?id&#x3D;1) 比较适用于页面跳转</li><li>url (&#x2F;team&#x2F;:id,xxx&#x2F;1)</li><li>hash (&#x2F;team#1)</li><li>localStorage</li><li>context(全局变量，同页面或整个项目要访问的公共变量)</li></ol><h2 id="随机匹配"><a href="#随机匹配" class="headerlink" title="随机匹配"></a>随机匹配</h2><p>需求背景：为了帮助大家更快地发现和自己兴趣相同的朋友</p><p>思考：匹配一个还是多个？</p><p>答：匹配多个，并且按照匹配的相似度从高到低排序</p><p>思考：怎么匹配？（根据什么来进行匹配？）</p><p>答：根据标签 tags</p><p>还可以根据 user_team 匹配加入相同队伍的用户</p><p>问题本质：找到有相似标签的用户</p><h3 id="1-怎么匹配？"><a href="#1-怎么匹配？" class="headerlink" title="1.怎么匹配？"></a>1.怎么匹配？</h3><ol><li>找到有共同标签最多的用户（Top N）</li><li>共同标签越多，分数越高，月排在前面</li><li>如没有匹配的用户，随机推荐（降级方案）</li></ol><h4 id="两种算法"><a href="#两种算法" class="headerlink" title="两种算法"></a>两种算法</h4><ul><li>编辑距离算法：<a href="https://blog.csdn.net/DBC_121/article/details/104198838">https://blog.csdn.net/DBC_121/article/details/104198838</a></li></ul><p><u>最小编辑距离：字符串 1 通过最少多少次增删改字符的操作可以变成字符串 2</u></p><ul><li>余弦相似度算法（如果需要带权重计算，比如学什么方向最重要，性别相对次要）</li></ul><h3 id="2-怎么对所有用户匹配，去取TOP？"><a href="#2-怎么对所有用户匹配，去取TOP？" class="headerlink" title="2.怎么对所有用户匹配，去取TOP？"></a>2.怎么对所有用户匹配，去取TOP？</h3><p>直接取出所有用户，依次和当前用户计算分数，去 TOP N （54 秒）</p><h4 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h4><ol><li>切忌不要在数据量答的时候循环输出日志（取消日志后 20 秒）</li><li>Map 存了所有的分数信息，占用内存<br>解决：维护一个固定长度的有序集合（sortedSet），只保留分数最高的几个用户（时间换空间）</li><li>细节：剔除自己  √</li><li>尽量只查需要的数据：<br>a. 过滤掉标签为空的用户  √<br>b. 根据部分标签取用户（前提是能区分出来哪个标签比较重要）<br>c. 只查需要的数据 （比如 id 和 tags） √ （7 秒）</li><li>提前查？（定时任务）<br>a. 提前给所有用户给缓存（不适用于经常更新的数据）<br>b. 提前运算出来结果，缓存（针对一些重点用户，提前缓存）</li></ol><h4 id="类比大数据推荐机制"><a href="#类比大数据推荐机制" class="headerlink" title="类比大数据推荐机制"></a>类比大数据推荐机制</h4><p>大数据推荐场景：比如说几个亿个商品，难道要查出所有商品？难道要对所有数据计算一遍相似度？</p><p>大数据推荐流程：</p><ul><li>检索 &#x3D;&gt; 召回 &#x3D;&gt; 粗排 &#x3D;&gt; 精排 &#x3D;&gt; 重排序等</li><li>检索：尽可能多地查符合要求的数据（比如按记录查）</li><li>召回：查询可能要用到的数据（不做运算）</li><li>粗排：粗略排序，简单运算（运算相对轻量）</li><li>精排：精细排序，确定固定排位</li></ul><h4 id="分表学习建议"><a href="#分表学习建议" class="headerlink" title="分表学习建议"></a>分表学习建议</h4><ol><li>mycat、 sharding sphere 框架</li><li>一致性 hash 算法</li></ol><h2 id="队伍操作权限控制"><a href="#队伍操作权限控制" class="headerlink" title="队伍操作权限控制"></a>队伍操作权限控制</h2><h3 id="权限整理"><a href="#权限整理" class="headerlink" title="权限整理"></a>权限整理</h3><p>加入队伍：仅非队伍创建人、且未加入队伍的人可见</p><p>更新队伍：仅创建人可见</p><p>解散队伍：仅创建人可见</p><p>退出队伍：创建人不可见，仅加入队伍的人可见</p><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>仅加入队伍和创建队伍的人看到队伍操作按钮（listTeam 接口要能获取我加入的队伍状态）</p><p>方案 1：前端查询我加入了哪些队伍列表，然后判断每个队伍 id 是否在列表中（前端要多发一次请求）</p><p>方案 2：在后端处理（推荐）</p><h2 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h2><ol><li><p>前端导航栏【标题】问题<br>解决：使用 router.beforeEach, 根据要跳转页面的 URL 路径匹配 config&#x2F;routes 配置 title 字段</p></li><li><p>强制登录，自动跳转到登录页 </p><p>解决：axios 全局配置响应拦截器、并且添加重定向</p></li><li><p>区别公开和加密队伍；加入有密码的队伍，要指定密码 </p></li><li><p>展示已加入队伍人数 </p></li><li><p>并发时，重复加入队伍的问题<br>解决：加锁、分布式锁</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;12-13-匹配算法-优化&quot;&gt;&lt;a href=&quot;#12-13-匹配算法-优化&quot; class=&quot;headerlink&quot; title=&quot;12-13 匹配算法-优化&quot;&gt;&lt;/a&gt;12-13 匹配算法-优化&lt;/h1&gt;&lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发完成个人队</summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>一次性定时任务</title>
    <link href="http://example.com/2022/12/08/6%E3%80%81%E4%B8%80%E6%AC%A1%E6%80%A7%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://example.com/2022/12/08/6%E3%80%81%E4%B8%80%E6%AC%A1%E6%80%A7%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</id>
    <published>2022-12-08T08:06:28.919Z</published>
    <updated>2022-12-08T07:56:17.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-一次性定时任务"><a href="#6-一次性定时任务" class="headerlink" title="6-一次性定时任务"></a>6-一次性定时任务</h1><p>主要内容：<br>1.主页前端开发（列表组件抽象）<br>2.批量插入数据功能开发+经验分享<br>3.定时任务注解<br>4.测试及优化批量导入功能（涉及性能优化+并发偏程知识）</p><h2 id="开发主页"><a href="#开发主页" class="headerlink" title="开发主页"></a>开发主页</h2><p>直接 list 列表组件实现</p><p>模拟 1000 万个用户， 再去查询</p><h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><h3 id="导入数据的方式"><a href="#导入数据的方式" class="headerlink" title="导入数据的方式"></a>导入数据的方式</h3><ol><li>用可视化界面:适合一次性导入、数据量可控</li><li>写程序：for 循环，但是尽量分批进行（可以用接口来控制）。<strong>保证可控、幂等，注意线上环境和测试环境是有区别的</strong></li><li>执行 SQL 语句：适用于小数据量</li></ol><h3 id="编写一次性任务"><a href="#编写一次性任务" class="headerlink" title="编写一次性任务"></a>编写一次性任务</h3><p>for 循环插入数据的特点：</p><ol><li>频繁建立和释放数据库连接（用批量查询解决）</li><li>for 循环是绝对线性的（可以并发提速）</li></ol><p><strong>注意：并发时不要用到非并发类的集合</strong></p><p>获取核心线程数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AVAILABLE_PROCESSORS</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors() - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>建立执行器（线程池）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(AVAILABLE_PROCESSORS, <span class="number">1000</span>, <span class="number">10000</span>, TimeUnit.MINUTES, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>));</span><br></pre></td></tr></table></figure><p>连接池的参数设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPU 密集型：分配的核心线程数 = CPU - <span class="number">1</span></span><br><span class="line">IO  密集型：分配的核心线程数可以大于 CPU 核数</span><br></pre></td></tr></table></figure><p>建立一个测试类实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.yupi.yupao.model.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertUsersTest</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU 密集型：分配的核心线程数 = CPU - 1</span></span><br><span class="line">    <span class="comment">// IO  密集型：分配的核心线程数可以大于 CPU 核数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">40</span>, <span class="number">1000</span>, <span class="number">10000</span>, TimeUnit.MINUTES, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量插入用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doInsertUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INSERT_NUM</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; INSERT_NUM; i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setUsername(<span class="string">&quot;假墨枫&quot;</span>);</span><br><span class="line">            user.setUserAccount(<span class="string">&quot;fuckmofeng&quot;</span>);</span><br><span class="line">            user.setAvatarUrl(<span class="string">&quot;https://636f-codenav-8grj8px727565176-1256524210.tcb.qcloud.la/img/logo.png&quot;</span>);</span><br><span class="line">            user.setGender(<span class="number">0</span>);</span><br><span class="line">            user.setUserPassword(<span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">            user.setPhone(<span class="string">&quot;18963421945&quot;</span>);</span><br><span class="line">            user.setTags(<span class="string">&quot;[&#x27;男&#x27;,&#x27;java&#x27;]&quot;</span>);</span><br><span class="line">            user.setEmail(<span class="string">&quot;123456@qq.com&quot;</span>);</span><br><span class="line">            user.setUserStatus(<span class="number">0</span>);</span><br><span class="line">            user.setUserRole(<span class="number">0</span>);</span><br><span class="line">            user.setPlanetCode(<span class="string">&quot;112111&quot;</span>);</span><br><span class="line">            userList.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 20 秒 10 万条</span></span><br><span class="line">        userService.saveBatch(userList, <span class="number">10000</span>);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.println(stopWatch.getTotalTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>并发插入数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPU 密集型：分配的核心线程数 = CPU - 1</span></span><br><span class="line"><span class="comment">// IO  密集型：分配的核心线程数可以大于 CPU 核数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">40</span>, <span class="number">1000</span>, <span class="number">10000</span>, TimeUnit.MINUTES, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发插入用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doConcurrencyInsertUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INSERT_NUM</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分十组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">//因为CompletableFuture实现了Future接口，我们先来回顾Future吧。</span></span><br><span class="line">    <span class="comment">//Future是Java5新加的一个接口，它提供了一种异步并行计算的功能。如果主线程需要执行一个很耗时的计算任务，我们就可以通过future把这个任务放到异步线程中执行。主线程继续处理其他任务，处理完成后，再通过Future获取计算结果。</span></span><br><span class="line">    List&lt;CompletableFuture&lt;Void&gt;&gt; futureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setUsername(<span class="string">&quot;假墨枫&quot;</span>);</span><br><span class="line">            user.setUserAccount(<span class="string">&quot;fuckmofeng&quot;</span>);</span><br><span class="line">            user.setAvatarUrl(<span class="string">&quot;https://636f-codenav-8grj8px727565176-1256524210.tcb.qcloud.la/img/logo.png&quot;</span>);</span><br><span class="line">            user.setGender(<span class="number">0</span>);</span><br><span class="line">            user.setUserPassword(<span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">            user.setPhone(<span class="string">&quot;18963421945&quot;</span>);</span><br><span class="line">            user.setTags(<span class="string">&quot;[&#x27;女&#x27;,&#x27;java&#x27;,&#x27;python&#x27;,&#x27;c++&#x27;]&quot;</span>);</span><br><span class="line">            user.setEmail(<span class="string">&quot;123456@qq.com&quot;</span>);</span><br><span class="line">            user.setUserStatus(<span class="number">0</span>);</span><br><span class="line">            user.setUserRole(<span class="number">0</span>);</span><br><span class="line">            user.setPlanetCode(<span class="string">&quot;112111&quot;</span>);</span><br><span class="line">            userList.add(user);</span><br><span class="line">            <span class="keyword">if</span>(j % batchSize == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新建异步任务,异步执行</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ThreadName:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            userService.saveBatch(userList, batchSize);</span><br><span class="line">        &#125;,executorService);</span><br><span class="line">        futureList.add(future);</span><br><span class="line">    &#125;</span><br><span class="line">    CompletableFuture.allOf(futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[]&#123;&#125;)).join();</span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    System.out.println(stopWatch.getTotalTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-一次性定时任务&quot;&gt;&lt;a href=&quot;#6-一次性定时任务&quot; class=&quot;headerlink&quot; title=&quot;6-一次性定时任务&quot;&gt;&lt;/a&gt;6-一次性定时任务&lt;/h1&gt;&lt;p&gt;主要内容：&lt;br&gt;1.主页前端开发（列表组件抽象）&lt;br&gt;2.批量插入数据功能开发+</summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="定时任务" scheme="http://example.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>项目部署上线（用户中心示例）</title>
    <link href="http://example.com/2022/12/04/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E7%A4%BA%E4%BE%8B/"/>
    <id>http://example.com/2022/12/04/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E7%A4%BA%E4%BE%8B/</id>
    <published>2022-12-04T05:11:58.271Z</published>
    <updated>2022-12-04T15:00:05.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目部署上线-用户中心示例"><a href="#项目部署上线-用户中心示例" class="headerlink" title="项目部署上线-用户中心示例"></a>项目部署上线-用户中心示例</h1><h2 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h2><p>参考文章：<a href="https://blog.csdn.net/weixin_41701290/article/details/120173283">https://blog.csdn.net/weixin_41701290/article/details/120173283</a></p><p>本地开发：localhost（127.0.0.1）</p><p>多环境：指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上。</p><p>为什么需要？</p><ol><li>每个环境互不影响</li><li>区分不同的阶段：开发 &#x2F; 测试 &#x2F; 生产</li><li>对项目进行优化：<ol><li>本地日志级别</li><li>精简依赖，节省项目体积</li><li>项目的环境 &#x2F; 参数可以调整，比如 JVM 参数</li></ol></li></ol><p>针对不同环境做不同的事情。</p><p>多环境分类：</p><ol><li>本地环境（自己的电脑）localhost</li><li>开发环境（远程开发）大家连同一台机器，为了大家开发方便</li><li>测试环境（测试）开发 &#x2F; 测试 &#x2F; 产品，单元测试 &#x2F; 性能测试 &#x2F; 功能测试 &#x2F; 系统集成测试，独立的数据库、独立的服务器</li><li>预发布环境（体验服）：和正式环境一致，正式数据库，更严谨，查出更多问题</li><li>正式环境（线上，公开对外访问的项目）：尽量不要改动，保证上线前的代码是 “完美” 运行</li><li>沙箱环境（实验环境）：为了做实验</li></ol><h3 id="前端多环境实战"><a href="#前端多环境实战" class="headerlink" title="前端多环境实战"></a>前端多环境实战</h3><ul><li><p>请求地址</p><ul><li><p>开发环境：localhost:8000</p></li><li><p>线上环境：user-backend.code-nav.cn</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">startFront</span>(<span class="params">env</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(env === <span class="string">&#x27;prod&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 不输出注释 </span></span><br><span class="line">        <span class="comment">// 项目优化</span></span><br><span class="line">        <span class="comment">// 修改请求地址</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 保持本地开发逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用了 umi 框架，build 时会自动传入 NODE_ENV &#x3D;&#x3D; production 参数，start NODE_ENV 参数为 development</p></li><li><p>启动方式</p><ul><li>开发环境：npm run start（本地启动，监听端口、自动更新）</li><li>线上环境：npm run build（项目构建打包），可以使用 serve 工具启动（npm i -g serve）</li></ul></li><li><p>项目的配置</p><p>不同的项目（框架）都有不同的配置文件，umi 的配置文件是 config，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。参考文档：<a href="https://umijs.org/zh-CN/docs/deployment">https://umijs.org/zh-CN/docs/deployment</a></p><ul><li>开发环境：config.dev.ts</li><li>生产环境：config.prod.ts</li><li>公共配置：config.ts 不带后缀</li></ul></li></ul><h3 id="后端多环境实战"><a href="#后端多环境实战" class="headerlink" title="后端多环境实战"></a>后端多环境实战</h3><p>SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件</p><p>可以在启动项目时传入环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar .\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod</span><br></pre></td></tr></table></figure><p>主要是改：</p><ul><li><p>依赖的环境地址</p><ul><li><p>数据库地址</p></li><li><p>缓存地址</p></li><li><p>消息队列地址</p></li><li><p>项目端口号</p></li></ul></li><li><p>服务器配置</p></li></ul><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>参考文章：<a href="https://www.bilibili.com/read/cv16179200">https://www.bilibili.com/read/cv16179200</a></p><p>需要 Linux 服务器（建议大家用 CentOS 8+ &#x2F; 7.6 以上）</p><h3 id="原始部署"><a href="#原始部署" class="headerlink" title="原始部署"></a>原始部署</h3><p>什么都自己装</p><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>需要 web 服务器：<strong>nginx</strong> 、apache、tomcat</p><p>安装 nginx 服务器：</p><ol><li><p>用系统自带的软件包管理器快速安装，比如 centos 的 yum</p></li><li><p>自己到官网安装（参考文章）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">curl -o nginx-1.21.6.tar.gz http://nginx.org/download/nginx-1.21.6.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf nginx-1.21.6.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> nginx-1.21.6</span><br><span class="line"></span><br><span class="line">   37  2022-04-17 23:30:09 yum install pcre pcre-devel -y</span><br><span class="line">   39  2022-04-17 23:30:59 yum install openssl openssl-devel -y</span><br><span class="line">   41  2022-04-17 23:31:57 ./configure --with-http_ssl_module --with-http_v2_module --with-stream</span><br><span class="line">   42  2022-04-17 23:32:13 make</span><br><span class="line">   43  2022-04-17 23:32:54 make install</span><br><span class="line">   48  2022-04-17 23:33:40 <span class="built_in">ls</span> /usr/local/nginx/sbin/nginx</span><br><span class="line">   vim /etc/profile</span><br><span class="line">  在最后一行添加：<span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/nginx/sbin</span><br><span class="line">  </span><br><span class="line">  nginx</span><br><span class="line">  </span><br><span class="line">  netstat -ntlp 查看启动情况</span><br></pre></td></tr></table></figure><p>注意 nginx 权限</p></li></ol><h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>java、maven</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum install -y java-1.8.0-openjdk*</span><br><span class="line"></span><br><span class="line">curl -o apache-maven-3.8.5-bin.tar.gz https://dlcdn.apache.org/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> xxx 下载代码</span><br><span class="line"></span><br><span class="line">打包构建，跳过测试</span><br><span class="line">mvn package -DskipTests</span><br><span class="line"></span><br><span class="line">java -jar ./user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod</span><br></pre></td></tr></table></figure><h3 id="宝塔-Linux-部署"><a href="#宝塔-Linux-部署" class="headerlink" title="宝塔 Linux 部署"></a>宝塔 Linux 部署</h3><p>Linux 运维面板</p><p>官方安装教程：<a href="https://www.bt.cn/new/download.html">https://www.bt.cn/new/download.html</a></p><p>方便管理服务器、方便安装软件</p><h3 id="前端托管"><a href="#前端托管" class="headerlink" title="前端托管"></a>前端托管</h3><p>前端腾讯云 web 应用托管（比容器化更傻瓜式，不需要自己写构建应用的命令，就能启动前端项目）</p><blockquote><p><a href="https://console.cloud.tencent.com/webify/new">https://console.cloud.tencent.com/webify/new</a></p></blockquote><ul><li>小缺点：需要将代码放到代码托管平台上</li><li>优势：不用写命令、代码更新时自动构建</li></ul><h3 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h3><p>docker 是容器，可以将项目的环境（比如 java、nginx）和项目的代码一起打包成镜像，所有同学都能下载镜像，更容易分发和移植。</p><p>再启动项目时，不需要敲一大堆命令，而是直接下载镜像、启动镜像就可以了。</p><p>docker 可以理解为软件安装包。</p><p>Docker 安装：<a href="https://www.docker.com/get-started/">https://www.docker.com/get-started/</a> 或者宝塔安装</p><p>Dockerfile 用于指定构建 Docker 镜像的方法</p><p>Dockerfile 一般情况下不需要完全从 0 自己写，建议去 github、gitee 等托管平台参考同类项目（比如 springboot）</p><p>Dockerfile 编写：</p><ul><li>FROM 依赖的基础镜像</li><li>WORKDIR 工作目录</li><li>COPY 从本机复制文件</li><li>RUN 执行命令</li><li>CMD &#x2F; ENTRYPOINT（附加额外参数）指定运行容器时默认执行的命令</li></ul><p>根据 Dockerfile 构建镜像：</p><p><strong>一定要进入到对应的目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前端</span></span><br><span class="line">docker build -t user-center-frontend:v0.0.1 .</span><br><span class="line"><span class="comment"># 后端</span></span><br><span class="line">docker build -t user-center-backend:v0.0.1 .</span><br></pre></td></tr></table></figure><p>Docker 构建优化：减少尺寸、减少构建时间（比如多阶段构建，可以丢弃之前阶段不需要的内容）</p><ul><li><strong>-d:</strong> 后台运行容器，并返回容器ID；</li><li><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></li></ul><p>docker run 启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前端</span></span><br><span class="line">docker run -p 80:80 -d user-center-frontend:v0.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后端</span></span><br><span class="line">docker run -p 8080:8080 user-center-backend:v0.0.1</span><br></pre></td></tr></table></figure><p>虚拟化</p><ol><li>端口映射：把本机的资源（实际访问地址）和容器内部的资源（应用启动端口）进行关联</li><li>目录映射：把本机的端口和容器应用的端口进行关联</li></ol><p>进入容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -i -t  fee2bbb7c9ee /bin/bash</span><br><span class="line"><span class="comment"># fee2bbb7c9ee 为容器 Id，docker ps 进行查询 id </span></span><br></pre></td></tr></table></figure><p>查看进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps </span><br></pre></td></tr></table></figure><p>查看日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f [container-id]</span><br><span class="line"><span class="comment"># 添加 -f 跟踪日志输出</span></span><br></pre></td></tr></table></figure><p>杀死容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> </span><br><span class="line"><span class="comment"># docker kill abf5c6ebe2fe</span></span><br><span class="line"><span class="comment"># 指定镜像 Id </span></span><br></pre></td></tr></table></figure><p>强制删除镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f </span><br><span class="line"><span class="comment"># docker rmi -f repository 名称</span></span><br><span class="line"><span class="comment"># -f 为强制删除</span></span><br></pre></td></tr></table></figure><h3 id="Docker-平台部署"><a href="#Docker-平台部署" class="headerlink" title="Docker 平台部署"></a>Docker 平台部署</h3><ol><li>云服务商的容器平台（腾讯云、阿里云）</li><li>面向某个领域的容器平台（前端 &#x2F; 后端微信云托管）<strong>要花钱！</strong></li></ol><p>容器平台的好处：</p><ol><li>不用输命令来操作，更方便省事</li><li>不用在控制台操作，更傻瓜式、更简单</li><li>大厂运维，比自己运维更省心</li><li>额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩缩容、流水线）</li></ol><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>用户中心（上线）1.mp4  时间：01:05:00</p><p>前端项目访问流程：用户输入网址 &#x3D;&gt; 域名解析服务器（把网址解析为 ip 地址 &#x2F; 交给其他的域名解析服务） &#x3D;&gt; 服务器 &#x3D;&gt;（防火墙）&#x3D;&gt; nginx 接收请求，找到对应的文件，返回文件给前端 &#x3D;&gt; 前端加载文件到浏览器中（js、css） &#x3D;&gt; 渲染页面</p><p>后端项目访问流程：用户输入网址 &#x3D;&gt; 域名解析服务器 &#x3D;&gt; 服务器 &#x3D;&gt; nginx 接收请求 &#x3D;&gt; 后端项目（比如 8080端口）</p><p>nginx 反向代理的作用：替服务器接收请求，转发请求</p><h2 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h2><p>浏览器为了用户的安全，仅允许向 <strong>同域名、同端口</strong> 的服务器发送请求。</p><p>如何解决跨域？</p><p>最直接的方式：把域名、端口改成相同的</p><h3 id="添加跨域头"><a href="#添加跨域头" class="headerlink" title="添加跨域头"></a>添加跨域头</h3><p>让服务器告诉浏览器：允许跨域（返回 cross-origin-allow 响应头）</p><h4 id="1-网关支持（Nginx）"><a href="#1-网关支持（Nginx）" class="headerlink" title="1. 网关支持（Nginx）"></a>1. 网关支持（Nginx）</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跨域配置</span></span><br><span class="line"><span class="section">location</span><span class="regexp"> ^~</span> /api/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:8080/api/;</span><br><span class="line">    <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="variable">$http_origin</span>;</span><br><span class="line">    <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Methods <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Headers <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="variable">$http_origin</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="number">1728000</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Content-Type&#x27;</span> <span class="string">&#x27;text/plain; charset=utf-8&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Content-Length&#x27;</span> <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-修改后端服务–用户中心上线（2）-00-32-00"><a href="#2-修改后端服务–用户中心上线（2）-00-32-00" class="headerlink" title="2. 修改后端服务–用户中心上线（2） 00:32:00"></a>2. 修改后端服务–用户中心上线（2） 00:32:00</h4><ol><li><p>配置 @CrossOrigin 注解</p></li><li><p>添加 web 全局请求拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfg</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//设置允许跨域的路径</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">//设置允许跨域请求的域名</span></span><br><span class="line">                <span class="comment">//当**Credentials为true时，**Origin不能为星号，需为具体的ip地址【如果接口不带cookie,ip无需设成具体ip】</span></span><br><span class="line">                .allowedOrigins(<span class="string">&quot;http://localhost:9527&quot;</span>, <span class="string">&quot;http://127.0.0.1:9527&quot;</span>, <span class="string">&quot;http://127.0.0.1:8082&quot;</span>, <span class="string">&quot;http://127.0.0.1:8083&quot;</span>)</span><br><span class="line">                <span class="comment">//是否允许证书 不再默认开启</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">//设置允许的方法</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">//跨域允许时间</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义新的 corsFilter Bean，参考：<a href="https://www.jianshu.com/p/b02099a435bd">https://www.jianshu.com/p/b02099a435bd</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目部署上线-用户中心示例&quot;&gt;&lt;a href=&quot;#项目部署上线-用户中心示例&quot; class=&quot;headerlink&quot; title=&quot;项目部署上线-用户中心示例&quot;&gt;&lt;/a&gt;项目部署上线-用户中心示例&lt;/h1&gt;&lt;h2 id=&quot;多环境&quot;&gt;&lt;a href=&quot;#多环境&quot; c</summary>
      
    
    
    
    <category term="项目部署上线" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF/"/>
    
    
    <category term="项目上线" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF/"/>
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="绑定域名" scheme="http://example.com/tags/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>使用 Git 上传项目</title>
    <link href="http://example.com/2022/12/04/%E4%BD%BF%E7%94%A8%20Git%20%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/"/>
    <id>http://example.com/2022/12/04/%E4%BD%BF%E7%94%A8%20Git%20%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-12-04T05:06:28.740Z</published>
    <updated>2022-12-04T05:06:13.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="上传项目到GitHub"><a href="#上传项目到GitHub" class="headerlink" title="上传项目到GitHub"></a>上传项目到GitHub</h1><ol><li>全局绑定账户</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 绑定用户</span><br><span class="line">git config --global user.name <span class="string">&quot; &quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>2.进到本地项目目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git coommit - m &quot;第一次上传&quot;</span><br></pre></td></tr></table></figure><p>已将本地仓库建立好</p><p>3.关联 GitHub 仓库 (示例宠物医院管理系统仓库地址)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 关联 GitHub 仓库地址</span><br><span class="line">git remote add origin git@github.com:xxxx.git</span><br><span class="line"># 上传本地代码 使用 origin 来指定上传的分支</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>git remote add origin <a href="mailto:&#103;&#105;&#x74;&#64;&#103;&#105;&#x74;&#104;&#117;&#x62;&#46;&#x63;&#x6f;&#x6d;">&#103;&#105;&#x74;&#64;&#103;&#105;&#x74;&#104;&#117;&#x62;&#46;&#x63;&#x6f;&#x6d;</a>:lubenchu&#x2F;PetHospitalManagementSystem.git 报错解决</p><p>查看当前关联的仓库：git remote -v </p><p>解除当前关联仓库：git remote rm origin </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;上传项目到GitHub&quot;&gt;&lt;a href=&quot;#上传项目到GitHub&quot; class=&quot;headerlink&quot; title=&quot;上传项目到GitHub&quot;&gt;&lt;/a&gt;上传项目到GitHub&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;全局绑定账户&lt;/li&gt;
&lt;/ol&gt;
&lt;figure cl</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="GitHub" scheme="http://example.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>索引失效的几种情况</title>
    <link href="http://example.com/2022/12/03/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E4%B8%83%E7%A7%8D%E6%83%85%E5%86%B5/"/>
    <id>http://example.com/2022/12/03/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E4%B8%83%E7%A7%8D%E6%83%85%E5%86%B5/</id>
    <published>2022-12-03T14:48:51.342Z</published>
    <updated>2022-12-03T14:48:29.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引失效的几种情况"><a href="#索引失效的几种情况" class="headerlink" title="索引失效的几种情况"></a>索引失效的几种情况</h1><ol><li><strong>条件有 ‘or’。</strong>如果想使用 ‘or’ ，又想索引有效，只能将 ‘or’ 条件中的每个列都加上索引。</li><li><strong>复合索引未使用左列字段。</strong>如果不使用前列，后续列也将无法使用。</li><li>like 以 % 开头。</li><li><strong>需要类型转换。</strong>比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引。</li><li>where 中索引列有运算。</li><li><strong>where 中索引列使用了函数</strong>。</li><li><strong>如果 mysql 觉得全表查询更快时（数据少）</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;索引失效的几种情况&quot;&gt;&lt;a href=&quot;#索引失效的几种情况&quot; class=&quot;headerlink&quot; title=&quot;索引失效的几种情况&quot;&gt;&lt;/a&gt;索引失效的几种情况&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;条件有 ‘or’。&lt;/strong&gt;如果想使用 ‘or’</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="索引" scheme="http://example.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础</title>
    <link href="http://example.com/2022/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80/</id>
    <published>2022-12-03T14:48:51.339Z</published>
    <updated>2022-12-08T08:05:42.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库相关基础"><a href="#数据库相关基础" class="headerlink" title="数据库相关基础"></a>数据库相关基础</h1><h1 id="一、-触发器的作用"><a href="#一、-触发器的作用" class="headerlink" title="一、 触发器的作用"></a>一、 触发器的作用</h1><p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库的操作从而不允许未经许可的更新和变化。可以联级运算。如：某表上的触发器包含对另一张表的数据操作，二该操作又会导致该表的触发器被触发。</p><h1 id="二、-什么是存储过程？用什么来调用？"><a href="#二、-什么是存储过程？用什么来调用？" class="headerlink" title="二、 什么是存储过程？用什么来调用？"></a>二、 什么是存储过程？用什么来调用？</h1><p>存储过程：是事先经过编译并存储在数据库中的一段 SQL 语句的集合。</p><p>调用：</p><p>（1）可以用一个命令对象来调用存储过程</p><p>（2）可供外部程序调用，如JAVA程序</p><h1 id="三、-存储过程的的优缺点"><a href="#三、-存储过程的的优缺点" class="headerlink" title="三、 存储过程的的优缺点"></a>三、 存储过程的的优缺点</h1><p>优点：</p><p>（1）   执行率高：存储过程是预编译过的，执行率高</p><p>（2）   较少网络流量：存储过程的代码存在数据库中，调用时值需要传递存储过程的名称和参数即可，因此降低了网络传输的数据量</p><p>（3）   安全性高：执行存储过程需要有一定权限的用户</p><p>（4）   重复使用：存储过程可以重复使用，从而减少数据库开发人员的工作量</p><p>缺点：</p><p>（1）   可移植性差</p><p>（2）   更改比较繁琐：更改参数，更改GetValue（）调用</p><h1 id="四、-存储过程与函数的区别"><a href="#四、-存储过程与函数的区别" class="headerlink" title="四、 存储过程与函数的区别"></a>四、 存储过程与函数的区别</h1><table><thead><tr><th>存储过程</th><th>函数</th></tr></thead><tbody><tr><td>用于在数据库中完成特定的操作或者任务（如插入、删除等）</td><td>用于特定的数据（如选择）</td></tr><tr><td>程序头部声明用procedure</td><td>程序头部声明用 function</td></tr><tr><td>程序头部声明时不需描述返回类型</td><td>程序头部声明要描述返回类型，而且PL&#x2F;SQL块中至少要包括一个有效的  return 语句</td></tr><tr><td>可以使用in&#x2F;out&#x2F;in  out 三种模式的参数</td><td>可以使用in&#x2F;out&#x2F;in  out 三种模式的参数</td></tr><tr><td>可作为一个独立的PL&#x2F;SQL语句来执行</td><td>不能独立执行，必须作为表达式的一部分调用</td></tr><tr><td>可以通过out&#x2F;in  out 返回零个或多个值</td><td>通过return 语句返回一个值，且改值要与声明部分一致，也可通过 out 类型的参数带出的变量</td></tr><tr><td>SQL语句(DML 或SELECT)中不可调用存储过程</td><td>SQL语句(DML 或SELECT)中可调用函数</td></tr></tbody></table><h1 id="五、-索引的作用？优缺点？"><a href="#五、-索引的作用？优缺点？" class="headerlink" title="五、 索引的作用？优缺点？"></a>五、 索引的作用？优缺点？</h1><p>作用：提高系统的性能</p><p>优点：</p><p>（1）   通过创建唯一索引，可保证数据库表中的每一行数据的唯一性</p><p>（2）   加快数据的检索速度</p><p>（3）   加速表与表之间的连接</p><p>（4）   在使用分组和排序语句进行数据检索时，显著减少查询分组和排序的时间</p><p>（5）   通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统性能</p><p>缺点：</p><p>（1）   耗费时间：创建和维护索引要耗费时间，且耗费时间随数据量增加而增加</p><p>（2）   耗费空间：索引需要占物理空间，如建立聚簇索引耗费更大的空间</p><p>（3）   维护数据速度慢：对表进行增、改、删时，索引也要动态维护</p><h1 id="六、-什么样的字段适合建索引？"><a href="#六、-什么样的字段适合建索引？" class="headerlink" title="六、 什么样的字段适合建索引？"></a>六、 什么样的字段适合建索引？</h1><p>（1）   唯一的字段</p><p>（2）   不为空的字段</p><p>（3）   经常被查询的字段</p><h1 id="七、-索引的类型有哪些？"><a href="#七、-索引的类型有哪些？" class="headerlink" title="七、 索引的类型有哪些？"></a>七、 索引的类型有哪些？</h1><ol><li><p>单行索引：Single column</p></li><li><p>多行索引：Concatenated </p></li><li><p>唯一索引：Unique </p></li><li><p>非唯一索引：NonUnique </p></li><li><p>函数索引：Function-based</p></li><li><p>分区索引：Partitioned </p></li><li><p>非分区索引：NonPartitioned</p></li></ol><h1 id="八、-什么是事务？什么是锁？"><a href="#八、-什么是事务？什么是锁？" class="headerlink" title="八、 什么是事务？什么是锁？"></a>八、 什么是事务？什么是锁？</h1><ol><li><p>事务：一条语句或者一组语句要么全部成功，对数据中的某些数据成功修改；要么全部失败，回滚，数据中的数据还原到这些语句执行前</p></li><li><p>锁：<br> （1）共享锁（S）：可以并发读取数据，但不能修改数据。也就是说当数据资源上存在共享锁的时候，所有的事务都不能对这个资源进行修改，直到数据读取完成，共享锁释放。<br> （2）排它锁（X）：如果你对数据资源进行增删改操作时，不允许其它任何事务操作这块资源，直到排它锁被释放，防止同时对同一资源进行多重操作。<br> （3）更新锁（U）：防止出现死锁的锁模式，两个事务对一个数据资源进行先读取在修改的情况下，使用共享锁和排它锁有时会出现死锁现象，而使用更新锁则可以避免死锁的出现。资源的更新锁一次只能分配给一个事务，如果需要对资源进行修改，更新锁会变成排他锁，否则变为共享锁。<br> （4）意向锁：SQL Server需要在层次结构中的底层资源上（如行，列）获取共享锁，排它锁，更新锁。例如表级放置了意向共享锁，就表示事务要对表的页或行上使用共享锁。在表的某一行上上放置意向锁，可以防止其它事务获取其它不兼容的的锁。意向锁可以提高性能，因为数据引擎不需要检测资源的每一列每一行，就能判断是否可以获取到该资源的兼容锁。意向锁包括三种类型：意向共享锁（IS），意向排他锁（IX），意向排他共享锁（SIX）。<br> （5）架构锁：防止修改表结构时，并发访问的锁。<br> （6）大容量更新锁：允许多个线程将大容量数据并发的插入到同一个表中，在加载的同时，不允许其它进程访问该表。</p></li></ol><p><strong>在多用户都用事务同时访问同一个数据资源的情况下，就会造成以下几种数据错误。</strong></p><p><strong>（1）</strong>   <code>更新丢失</code>：多个用户同时对一个数据资源进行更新，必定会产生被覆盖的数据，造成数据读写异常。</p><p><strong>（2）</strong>   <code>不可重复读</code>：如果一个用户在一个事务中多次读取一条数据，而另外一个用户则同时更新啦这条数据，造成第一个用户多次读取数据不一致。</p><p><strong>（3）</strong>   <code>脏读</code>：第一个事务读取第二个事务正在更新的数据表，如果第二个事务还没有更新完成，那么第一个事务读取的数据将是一半为更新过的，一半还没更新过的数据，这样的数据毫无意义。</p><p><strong>（4）</strong>   <code>幻读</code>：第一个事务读取一个结果集后，第二个事务，对这个结果集经行增删操作，然而第一个事务中再次对这个结果集进行查询时，数据发现丢失或新增。</p><h1 id="九、-什么叫视图？游标是什么？"><a href="#九、-什么叫视图？游标是什么？" class="headerlink" title="九、 什么叫视图？游标是什么？"></a>九、 什么叫视图？游标是什么？</h1><p>视图：是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。</p><p>游标：是对查询出来的结果集作为一个单元来有效的处理。</p><p>游标是SQL 的一种数据访问机制 ，游标是一种处理数据的方法。</p><p>众所周知，使用SQL的select查询操作返回的结果是一个包含一行或者是多行的数据集，如果我们要对查询的结果再进行查询，比如（查看结果的第一行、下一行、最后一行、前十行等等操作）简单的通过select语句是无法完成的，因为这时候索要查询的结果不是数据表，而是已经查询出来的结果集。游标就是针对这种情况而出现的。</p><p><strong>游标的操作步骤：声明游标—&gt;打开游标—&gt;读取数据—&gt;关闭游标—&gt;删除游标</strong></p><h1 id="十、-视图的优缺点？"><a href="#十、-视图的优缺点？" class="headerlink" title="十、 视图的优缺点？"></a>十、 视图的优缺点？</h1><p>优点：</p><p>（1）   对数据库的访问，视图可以有选择性的选区数据库里的一部分。可选表中的行或列的子集</p><p>（2）   通过简单的查询可以从复杂查询中得到结果</p><p>（3）   维护数据的独立性，视图可以从多个表检索数据</p><p>（4）   对于相同的数据可产生不同的视图</p><p>缺点：</p><p>（1）   性能：SQL Server必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，SQL Server也把它变成一个复杂的结合体，需要花费一定的时间。</p><p>（2）   修改限制：当用户试图修改视图的某些行时，SQL Server必须把它转化为对基本表的某些行的修改。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的。 </p><h1 id="十一、列举几种表的连接方式，有什么区别？"><a href="#十一、列举几种表的连接方式，有什么区别？" class="headerlink" title="十一、列举几种表的连接方式，有什么区别？"></a>十一、列举几种表的连接方式，有什么区别？</h1><p>内连接：只有两个元素表相匹配的才能在结果集中显示</p><p>外连接：</p><p>（1）   左外连接：左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示</p><p>（2）   右外连接：右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。</p><p>全外连接：连接的表中不匹配的数据全部会显示出来</p><p>交叉连接： 笛卡尔效应，显示的结果是链接表数的乘积。</p><h1 id="十二、主键和外键的区别？"><a href="#十二、主键和外键的区别？" class="headerlink" title="十二、主键和外键的区别？"></a>十二、主键和外键的区别？</h1><p>主键：在本表中是唯一的、不可唯空的，外键可以重复可以唯空</p><p>外键：外键和另一张表的主键关联，不能创建对应表中不存在的外键</p><h1 id="十三、在数据库中查询语句速度很慢，如何优化？"><a href="#十三、在数据库中查询语句速度很慢，如何优化？" class="headerlink" title="十三、在数据库中查询语句速度很慢，如何优化？"></a>十三、在数据库中查询语句速度很慢，如何优化？</h1><p>1.建索引 </p><p>2.减少表之间的关联 </p><p>3.优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据 量大的表排在前面 </p><p>4.简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据 </p><p>5.尽量用PreparedStatement来查询，不要用Statement</p><h1 id="十四、数据库的三范式是什么？"><a href="#十四、数据库的三范式是什么？" class="headerlink" title="十四、数据库的三范式是什么？"></a>十四、数据库的三范式是什么？</h1><p>第一范式：列不可再分 </p><p>第二范式：行可以唯一区分，主键约束 </p><p>第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束 且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上</p><h1 id="十五、Union-和-union-all-有什么不同？"><a href="#十五、Union-和-union-all-有什么不同？" class="headerlink" title="十五、Union 和 union all 有什么不同？"></a>十五、Union 和 union all 有什么不同？</h1><p>UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION。</p><p>UNION ALL只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。 从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用UNION ALL。</p><h1 id="十六、Varchar2-和-Varchar-有什么区别？"><a href="#十六、Varchar2-和-Varchar-有什么区别？" class="headerlink" title="十六、Varchar2 和 Varchar 有什么区别？"></a>十六、Varchar2 和 Varchar 有什么区别？</h1><p>Char的长度是固定的，而varchar2的长度是可以变化的，比如，存储字符串“abc”对于char(20)，表示你存储的字符将占20个字节，包含17个空，而同样的varchar2（20）只占了3个字节，20只是最大值，当你存储的字符小于20时，按实际长度存储。 char的效率要被varchar2的效率高。 目前varchar是varchar2的同义词，工业标准的varchar类型可以存储空字符串，但是oracle不能这样做，尽管它保留以后这样做的权利。Oracle自己开发了一个数据类型varchar2,这个类型不是一个标准的varchar，他将在数据库中varchar列可以存储空字符串的特性改为存储null值，如果你想有向后兼容的能力，oracle建议使用varchar2而不是varchar</p><h1 id="十七、Oracle-和-Mysql-的区别？"><a href="#十七、Oracle-和-Mysql-的区别？" class="headerlink" title="十七、Oracle 和 Mysql 的区别？"></a>十七、Oracle 和 Mysql 的区别？</h1><p>1）库函数不同。</p><p>2）Oracle是用表空间来管理的，Mysql不是。</p><p>3）显示当前所有的表、用户、改变连接用户、显示当前连接用户、执行外部脚本的语句的不同。</p><p>4）分页查询时候，mysql用limit oracle用rownum</p><p>\1. mysql&gt; <strong>SELECT</strong> * <strong>FROM</strong> <strong>table</strong> LIMIT 5,10; &#x2F;&#x2F; 检索记录行 6-15 &#x2F;&#x2F;为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： mysql&gt; <strong>SELECT</strong> * <strong>FROM</strong> <strong>table</strong> LIMIT 95,-1; &#x2F;&#x2F; 检索记录行 96-<strong>last</strong>. &#x2F;&#x2F;如果只给定一个参数，它表示返回最大的记录行数目： mysql&gt; <strong>SELECT</strong> * <strong>FROM</strong> <strong>table</strong> LIMIT 5; &#x2F;&#x2F;检索前 5 个记录行 &#x2F;&#x2F;换句话说，LIMIT n 等价于 LIMIT 0,n。 5）sql的语法的不同。</p><h1 id="十七、乐观锁和悲观锁"><a href="#十七、乐观锁和悲观锁" class="headerlink" title="十七、乐观锁和悲观锁"></a>十七、乐观锁和悲观锁</h1><p>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据，如果别人修改了数据则放弃操作，否则执行操作。</p><p>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁，上锁期间其他人不能修改数据。</p><p>悲观锁的实现方式是加锁，加锁既可以是对代码加锁（如Java 的 synchronized 关键字），也可以是对数据加锁（如 mysql 的排它锁）</p><p>Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><h2 id="乐观锁的实现方式：CAS-机制-和-版本号机制"><a href="#乐观锁的实现方式：CAS-机制-和-版本号机制" class="headerlink" title="乐观锁的实现方式：CAS 机制 和 版本号机制"></a>乐观锁的实现方式：CAS 机制 和 版本号机制</h2><h2 id="1-版本号控制"><a href="#1-版本号控制" class="headerlink" title="1.版本号控制"></a>1.版本号控制</h2><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><p>注意：使用版本号作为判断数据变化的标记，实际上可以根据实际情况选用其他能够标记数据版本的字段，如时间戳等</p><h2 id="2-CAS机制"><a href="#2-CAS机制" class="headerlink" title="2.  CAS机制"></a>2.  CAS机制</h2><p>CAS即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。</p><p><strong>CAS算法</strong>涉及到三个操作数</p><p>（1）   需要读写的内存值 V</p><p>（2）   进行比较的值 A</p><p>（3）   拟写入的新值 B</p><p>当且仅当 V 的值等于 A（A &#x3D;&#x3D; V） 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断地重试，直到操作成功为止</p><h2 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h2><ol><li><p>ABA问题：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 **”ABA”问题。<br>** 假设有两个线程——线程1和线程2，两个线程按照顺序进行以下操作：</p><p>(1)线程1读取内存中数据为A；</p><p>(2)线程2将该数据修改为B；</p><p>(3)线程2将该数据修改为A；</p><p>(4)线程1对数据进行CAS操作</p><p>在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题</p></li><li><p>循环时间长，开销大：自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p></li><li><p>只能保证一个共享变量的原子操作：CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p></li></ol><h2 id="悲观锁的实现"><a href="#悲观锁的实现" class="headerlink" title="悲观锁的实现"></a>悲观锁的实现</h2><p>场景：有用户A和用户B，在同一家店铺去购买同一个商品，但是商品的可购买数量只有一个</p><p>商品表t_goods</p><p>​                               </p><p>如果不加锁情况下，用户A和用户B同时下单会报错。</p><ul><li><p>加入当用户A对下单购买商品（臭豆腐）的时候，先去尝试对该数据（臭豆腐）加上悲观锁</p></li><li><p>加锁失败：说明商品（臭豆腐）正在被其他事务进行修改，当前查询需要等待或者抛出异常，具体返回的方式需要由开发者根据具体情况去定义</p></li><li><p>加锁成功：对商品（臭豆腐）进行修改，也就是只有用户A能买，用户B想买（臭豆腐）就必须一直等待。当用户A买好后，用户B再想去买（臭豆腐）的时候会发现数量已经为0，那么B看到后就会放弃购买 </p></li><li><p>在此期间如果有其他对该数据（臭豆腐）做修改或加锁的操作，都会等待我们解锁后或者直接抛出异常</p></li></ul><p>首先关闭 MySql 数据库的自动提交属性。因为 MYSQL默认使用的是 autocommit 模式，即当我们执行一个更新操作后，MYSQL 会立即将结果进行提交（SQL：set autocommit &#x3D; 0）</p><p>悲观锁加锁的SQL语句：select num t_goods where id &#x3D; 2 for update</p><p>事务A：查询数据 num &#x3D; 1</p><p>​    Select num from t_goods where id &#x3D; 2 for update;</p><p>事务B：事务B会一直等待事务A释放锁，如果事务A长期不释放锁，那么最终事务B会报错。报错：Lock wait timeout exceeded;try restarting transaction,表示语句被锁</p><h2 id="乐观锁的实现"><a href="#乐观锁的实现" class="headerlink" title="乐观锁的实现"></a>乐观锁的实现</h2><p>在进行更新语句的时候，加上版本号一起判断，如果版本号相同，则成功，版本号 version + 1；否则为失败，提示重新查询最新数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库相关基础&quot;&gt;&lt;a href=&quot;#数据库相关基础&quot; class=&quot;headerlink&quot; title=&quot;数据库相关基础&quot;&gt;&lt;/a&gt;数据库相关基础&lt;/h1&gt;&lt;h1 id=&quot;一、-触发器的作用&quot;&gt;&lt;a href=&quot;#一、-触发器的作用&quot; class=&quot;header</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="索引" scheme="http://example.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>如何实现乐观锁和悲观锁？</title>
    <link href="http://example.com/2022/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F/"/>
    <id>http://example.com/2022/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F/</id>
    <published>2022-12-03T14:48:51.337Z</published>
    <updated>2022-12-08T08:05:30.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何实现乐观锁和悲观锁？"><a href="#如何实现乐观锁和悲观锁？" class="headerlink" title="如何实现乐观锁和悲观锁？"></a>如何实现乐观锁和悲观锁？</h1><ul><li><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p></li><li><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//核心SQL,主要靠for update</span><br><span class="line">select status from t_goods where id=1 for update;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//核心SQL</span><br><span class="line">update table set x=x+1, version=version+1 where id=#&#123;id&#125; and version=#&#123;version&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><p><strong>两种锁的使用场景</strong></p><ul><li>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</li><li>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何实现乐观锁和悲观锁？&quot;&gt;&lt;a href=&quot;#如何实现乐观锁和悲观锁？&quot; class=&quot;headerlink&quot; title=&quot;如何实现乐观锁和悲观锁？&quot;&gt;&lt;/a&gt;如何实现乐观锁和悲观锁？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据库管理系统（DBMS）中的并发控制的任</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>使用PreparedStatement防止SQL注入</title>
    <link href="http://example.com/2022/12/03/%E4%BD%BF%E7%94%A8PreparedStatement%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/2022/12/03/%E4%BD%BF%E7%94%A8PreparedStatement%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5/</id>
    <published>2022-12-03T14:48:51.335Z</published>
    <updated>2022-12-03T14:42:03.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用PreparedStatement防止SQL注入"><a href="#使用PreparedStatement防止SQL注入" class="headerlink" title="使用PreparedStatement防止SQL注入"></a>使用PreparedStatement防止SQL注入</h1><p>使用Statement对象执行静态SQL语句，如果执行了特殊构造的语句，会导致SQL注入，出现安全漏洞。</p><p>使用PreparedStatement对象能够防止 SQL 注入。</p><p>PreparedStatement对象是<strong>预编译的SQL语句</strong>的对象，继承自Statement。</p><p>什么是预编译的SQL语句？</p><p>静态SQL语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; and password = &#x27; &quot;</span> + password + <span class="string">&quot;&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure><p>改为预编译的SQL语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ? and password = ? &quot;</span>;</span><br></pre></td></tr></table></figure><p>编写SQL语句时，不使用字符串进行拼接，而是使用问号？占位符代替变量。</p><p>使用JDBC的步骤有所变化：</p><ol><li>注册驱动</li><li>获取连接对象</li><li>创建SQL语句</li><li><strong>创建执行SQL语句的PreparedStatement对象</strong></li><li><strong>给 ? 赋值</strong></li><li>执行SQL语句</li><li>释放资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//获取连接对象</span></span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&amp;useSSL=false&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//创建SQL语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;行小观&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ? and password = ?&quot;</span>;</span><br><span class="line">        <span class="comment">//创建PreparedStatement对象</span></span><br><span class="line">        pstmt = conn.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//给?赋值</span></span><br><span class="line">        pstmt.setString(<span class="number">1</span>, username);</span><br><span class="line">        pstmt.setString(<span class="number">2</span>, password);</span><br><span class="line">        <span class="comment">//执行SQL语句</span></span><br><span class="line">        rs = pstmt.executeQuery();</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">unm</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            System.out.println(id + <span class="string">&quot;--&quot;</span>+ unm + <span class="string">&quot;--&quot;</span> + pwd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pstmt != <span class="literal">null</span>) &#123;<span class="comment">//避免空指针异常</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pstmt.close();<span class="comment">//释放资源</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用PreparedStatement防止SQL注入&quot;&gt;&lt;a href=&quot;#使用PreparedStatement防止SQL注入&quot; class=&quot;headerlink&quot; title=&quot;使用PreparedStatement防止SQL注入&quot;&gt;&lt;/a&gt;使用Prepar</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL 注入" scheme="http://example.com/tags/SQL-%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL 注入</title>
    <link href="http://example.com/2022/12/03/SQL%20%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/2022/12/03/SQL%20%E6%B3%A8%E5%85%A5/</id>
    <published>2022-12-03T14:48:51.331Z</published>
    <updated>2022-12-03T14:41:03.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h1><p>静态 SQL 语句是使用字符串拼接起来的。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;行小观&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; and password = &#x27;&quot;</span> + password + <span class="string">&quot;&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure><p>我们将变量代入后的效果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user <span class="type">where</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&#x27;行小观&#x27;</span> <span class="type">and</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&#x27;1234&#x27;</span></span><br></pre></td></tr></table></figure><p>这样执行是没问题的。</p><p>但是现在情况变了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;行小观&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;</span><br></pre></td></tr></table></figure><p>我们将变量代入后的效果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user <span class="type">where</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&#x27;行小观&#x27;</span> <span class="type">and</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> or <span class="string">&#x27;1&#x27;</span> = <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>因为<code>or &#39;1&#39;=&#39;1&#39;</code>的原因，导致 SQL 语句的 where 子句为 true，等价于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user</span><br></pre></td></tr></table></figure><p>所以会将整张表给查询出来。</p><p>以上便是SQL注入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL-注入&quot;&gt;&lt;a href=&quot;#SQL-注入&quot; class=&quot;headerlink&quot; title=&quot;SQL 注入&quot;&gt;&lt;/a&gt;SQL 注入&lt;/h1&gt;&lt;p&gt;静态 SQL 语句是使用字符串拼接起来的。如：&lt;/p&gt;
&lt;figure class=&quot;highlight j</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL 注入" scheme="http://example.com/tags/SQL-%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
</feed>
