<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>墨枫个人博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-11T16:43:39.689Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>墨枫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读《霍乱时期的爱情》</title>
    <link href="http://example.com/2023/04/12/%E8%AF%BB%E3%80%8A%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85%E3%80%8B/"/>
    <id>http://example.com/2023/04/12/%E8%AF%BB%E3%80%8A%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85%E3%80%8B/</id>
    <published>2023-04-11T16:44:24.610Z</published>
    <updated>2023-04-11T16:43:39.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读马尔克斯的《霍乱时期的爱情》"><a href="#读马尔克斯的《霍乱时期的爱情》" class="headerlink" title="读马尔克斯的《霍乱时期的爱情》"></a>读马尔克斯的《霍乱时期的爱情》</h1><p>这场跨越半个世纪的悲欢离合，少年时的悸动，暮年时的相互依靠。中间历经千辛万苦，最后一起旅行，享受了一段短暂的美好时光。</p><p>惊叹于马尔克斯叙述语言的魅力，那无尽的赞美和无情的诅咒，一个个小故事来丰富情节。</p><p>弗洛伦蒂诺·阿里萨可以说是一个一穷二白的年轻人，而洛伦索·达萨想让他女儿将来能嫁给名门贵族，所以洛伦索·达萨需要拆散他们，企图向他女儿的舅舅寻求帮助时，不曾想他年轻的时候为了娶到现在的妻子，也曾是弗洛伦蒂诺·阿里萨现在的处境。马尔克斯用极具讽刺的手法，描述了洛伦索·达萨内心的贪婪和自私。</p><p>在叙述养鸽女和弗洛伦蒂诺·阿里萨的故事中，正当我看得入迷，以为故事情节达到高潮之时，养鸽女直接被丈夫残忍杀害的时候，故事情节戛然而止，最后只剩下坟墓前那盛开的玫瑰花，弗洛伦蒂诺·阿里萨来看他的母亲时会一起清理一下，以减少他内心的愧疚，可最后墓园里的所有玫瑰花都被政府清除掉了，并把墓园改成了公墓。</p><p>作者马尔克斯描写最后的结局中，以弗洛伦蒂诺·阿里萨回答船长的话“一生一世”作为结尾，给人无限的遐想，船既没有停泊，也没有继续前进，也暗示着弗洛伦蒂诺·阿里萨和费尔明娜·达萨的关系，留一段空白给读者细细品味。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;读马尔克斯的《霍乱时期的爱情》&quot;&gt;&lt;a href=&quot;#读马尔克斯的《霍乱时期的爱情》&quot; class=&quot;headerlink&quot; title=&quot;读马尔克斯的《霍乱时期的爱情》&quot;&gt;&lt;/a&gt;读马尔克斯的《霍乱时期的爱情》&lt;/h1&gt;&lt;p&gt;这场跨越半个世纪的悲欢离合，少年时的</summary>
      
    
    
    
    <category term="墨枫的读书感想" scheme="http://example.com/categories/%E5%A2%A8%E6%9E%AB%E7%9A%84%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%83%B3/"/>
    
    
    <category term="读书感想" scheme="http://example.com/tags/%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="http://example.com/2023/02/09/%E5%A2%A8%E6%9E%AB%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2023/02/09/%E5%A2%A8%E6%9E%AB%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</id>
    <published>2023-02-09T12:43:10.910Z</published>
    <updated>2023-02-09T12:42:47.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="1-MQ的相关概念"><a href="#1-MQ的相关概念" class="headerlink" title="1.MQ的相关概念"></a>1.MQ的相关概念</h2><h3 id="1-1什么是-MQ"><a href="#1-1什么是-MQ" class="headerlink" title="1.1什么是 MQ"></a>1.1什么是 MQ</h3><p>​MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。</p><h3 id="1-2为什么要用-MQ"><a href="#1-2为什么要用-MQ" class="headerlink" title="1.2为什么要用 MQ"></a>1.2为什么要用 MQ</h3><ol><li><p>流量消峰 举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正 常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限 制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体 验要好。</p></li><li><p>应用解耦 以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于 消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p></li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302011220299.png" alt="image-20230201122049081"></p><ol start="3"><li>异步处理 有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可 以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此 消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不 用做这些操作。A 服务还能及时的得到异步处理成功的消息。</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302011221858.png" alt="image-20230201122130327"></p><h3 id="1-3MQ-的分类"><a href="#1-3MQ-的分类" class="headerlink" title="1.3MQ 的分类"></a>1.3MQ 的分类</h3><ol><li><p>ActiveMQ<br><strong>优点：</strong>单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据<br>**缺点:**官方社区现在对 ActiveMQ 5.x <strong>维护越来越少，高吞吐量场景较少使用。</strong><br>尚硅谷官网视频: <a href="http://www.gulixueyuan.com/course/322">http://www.gulixueyuan.com/course/322</a></p></li><li><p>Kafka 大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为大数据而生的消息中间件， 以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。<br><strong>优点:</strong> 性能卓越，单机写入 TPS 约在百万条&#x2F;秒，最大的优点，就是<strong>吞吐量高</strong>。时效性 ms 级可用性非 常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方 Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持： 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及<strong>日志采集</strong>被大规模使用<br><strong>缺点：</strong>Kafka 单机超过 64 个队列&#x2F;分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，社区更新较慢； </p></li><li><p>RocketMQ RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场 景。<br><strong>优点:单机吞吐量十万级</strong>,可用性非常高，分布式架构,<strong>消息可以做到 0 丢失</strong>,MQ 功能较为完善，还是分 布式的，扩展性好,<strong>支持 10 亿级别的消息堆积</strong>，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 MQ<br><strong>缺点：支持的客户端语言不多</strong>，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在 MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码 </p></li><li><p>RabbitMQ 2007 年发布，是一个在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，<strong>是当前最 主流的消息中间件之一。</strong><br><strong>优点:<strong>由于 erlang 语言的</strong>高并发特性</strong>，性能较好；<strong>吞吐量到万级</strong>，MQ 功能比较完备,健壮、稳定、易 用、跨平台、<strong>支持多种语言</strong> 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,<strong>社区活跃度高</strong>；<br>更新频率相当高 <a href="https://www.rabbitmq.com/news.html">https://www.rabbitmq.com/news.html</a><br><strong>缺点：</strong>商业版需要收费,学习成本较高</p></li></ol><h3 id="1-4MQ-的选择"><a href="#1-4MQ-的选择" class="headerlink" title="1.4MQ 的选择"></a>1.4MQ 的选择</h3><ol><li><p>Kafka<br>Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集 和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能， 肯定是首选 kafka 了。尚硅谷官网 kafka 视频连接 <a href="http://www.gulixueyuan.com/course/330/tasks">http://www.gulixueyuan.com/course/330/tasks</a></p></li><li><p>RocketMQ<br>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削 峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p></li><li><p>RabbitMQ<br>结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。</p></li></ol><h2 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2.RabbitMQ"></a>2.RabbitMQ</h2><h3 id="2-1-RabbitMQ-的概念"><a href="#2-1-RabbitMQ-的概念" class="headerlink" title="2.1 RabbitMQ 的概念"></a>2.1 RabbitMQ 的概念</h3><p>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包 裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。</p><h3 id="2-2-四大核心概念"><a href="#2-2-四大核心概念" class="headerlink" title="2.2 四大核心概念"></a>2.2 四大核心概念</h3><ol><li><p>生产者</p><p>产生数据发送消息的程序是生产者</p></li><li><p>交换机</p><p>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息</p><p>推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推</p><p>送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p></li><li><p>队列</p><p>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存</p><p>储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可</p><p>以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p></li><li><p>消费者</p><p>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费</p><p>者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p></li></ol><h3 id="2-3-RabbitMQ-核心部分"><a href="#2-3-RabbitMQ-核心部分" class="headerlink" title="2.3 RabbitMQ 核心部分"></a>2.3 RabbitMQ 核心部分</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302011234736.png" alt="image-20230201123408865"></p><h3 id="2-5各个名词介绍"><a href="#2-5各个名词介绍" class="headerlink" title="2.5各个名词介绍"></a>2.5各个名词介绍</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302011234537.png" alt="image-20230201123452541"></p><ul><li><p><strong>Broker：</strong>接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p></li><li><p><strong>Virtual host：</strong>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似</p><p>于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出</p><p>多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p></li><li><p><strong>Connection：</strong>publisher／consumer 和 broker 之间的 TCP 连接</p></li><li><p><strong>Channel：</strong>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP </p><p>Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程</p><p>序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客</p><p>户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的</p><p><strong>Connection 极大减少了操作系统建立 TCP connection 的开销</strong> </p></li><li><p><strong>Exchange：</strong>message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发</p><p>消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout </p><p>(multicast)</p></li><li><p><strong>Queue：</strong>消息最终被送到这里等待 consumer 取走</p></li><li><p><strong>Binding：</strong>exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保</p></li><li><p>存到 exchange 中的查询表中，用于 message 的分发依据</p></li></ul><h3 id="2-6RabbitMQ-安装"><a href="#2-6RabbitMQ-安装" class="headerlink" title="2.6RabbitMQ 安装"></a>2.6RabbitMQ 安装</h3><ol><li><p>官网地址下载<br><a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a></p></li><li><p>文件上传<br>上传到 &#x2F;usr&#x2F;local&#x2F;software 目录下（可以使用 Xftp 上传）<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151047302.png" alt="image-20230115104710973"></p></li><li><p>安装文件（按照顺序安装）<br>rpm -ivh erlang-21.3-1.el7.x86_64.rpm    安装 Erlang </p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151049919.png" alt="image-20230115104905385">yum install socat -y安装依赖包</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151054823.png" alt="image-20230115105402243">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230115105503632.png" alt="image-20230115105503632">注：i 命令表示 install 安装；vh 命令显示安装进度；yum 命令需要联网</p></li><li><p>常用命令（按顺序）<br>添加开机启动 RabbitMQ 服务<br>chkconfig rabbitmq-server on<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151058073.png" alt="image-20230115105835506"></p><p>启动服务<br>&#x2F;sbin&#x2F;service rabbitmq-server start<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151102110.png" alt="image-20230115110208280"><br>查看服务状态<br>&#x2F;sbin&#x2F;service rabbitmq-server status<br>Active: active (running)    表示启动好了</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151103464.png" alt="image-20230115110311101"></p></li></ol><p>​停止服务（选择执行）<br>​ &#x2F;sbin&#x2F;service rabbitmq-server stop<br>​开启 web 插件<br>​rabbitmq-plugins enable rabbitmq_management<br>​查看防火墙的状态<br>​systemctl status firewalld<br>​关闭防火墙<br>​systemctl stop firewalld<br>​开机时防火墙不再开启<br>​systemctl enable firewalld<br>​用默认账号密码(guest)访问地址 <a href="http://47.115.185.244:15672/%E5%87%BA%E7%8E%B0%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98">http://47.115.185.244:15672/出现权限问题</a>(服务器需要开放 15672 端口)</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151119523.png" alt="image-20230115111908386"></p><ol start="5"><li><p>添加一个新用户</p><ol><li><p>创建账号 rabbitmqctl add_user admin 123 </p></li><li><p>设置用户角色 rabbitmqctl set_user_tags admin administrator </p></li><li><p>设置用户权限 set_permissions [-p ] <user> <conf> <wirte> <read></p><p>执行命令： rabbitmqctl set_permissions -p “&#x2F;“ admin “.<em>“ “.</em>“ “.*”</p><p>用户 user_admin 具有&#x2F;vhost1 这个 virtual host 中所有资源的配置、写、读权限 当前用户和角色</p><p>展示 rabbitmq 的用户：rabbitmqctl list_users</p><p>输入账户密码 admin 123 登录即可</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151135084.png" alt="image-20230115113515504"><strong>注：rebbitmqctl 命令表示设置权限；不同的 Virtual Hosts 交换机（Exchanges)和队列(Queuees)是不一样的</strong></p></li></ol></li><li><p>重置命令</p><ol><li>关闭应用命令 rabbitmqctl stop_app</li><li>清除命令 rabbitmqctl resest</li><li>重新启动命令 rabbitmqctl start_app</li></ol></li></ol><h2 id="3-RabbitMQ"><a href="#3-RabbitMQ" class="headerlink" title="3.RabbitMQ"></a>3.RabbitMQ</h2><h3 id="3-1Hello-World-案例"><a href="#3-1Hello-World-案例" class="headerlink" title="3.1Hello World 案例"></a>3.1Hello World 案例</h3><p>在本教程的这一部分中，我们将用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印 出来的消费者。我们将介绍 Java API 中的一些细节。</p><p> 在下图中，“ P”是我们的生产者，“ C”是我们的消费者。中间的框是一个队列-RabbitMQ 代 表使用者保留的消息缓冲区<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151155281.png" alt="image-20230115115509389"></p><h4 id="3-1-1配置环境"><a href="#3-1-1配置环境" class="headerlink" title="3.1.1配置环境"></a>3.1.1配置环境</h4><p>创建一个空项目，然后创建 rabbitmq-hello 模块，在 rabbitmq-hello 添加依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--指定 jdk 编译版本--&gt;</span><br><span class="line">   &lt;build&gt;</span><br><span class="line">       &lt;plugins&gt;</span><br><span class="line">           &lt;plugin&gt;</span><br><span class="line">               &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">               &lt;configuration&gt;</span><br><span class="line">                   &lt;source&gt;<span class="number">8</span>&lt;/source&gt;</span><br><span class="line">                   &lt;target&gt;<span class="number">8</span>&lt;/target&gt;</span><br><span class="line">               &lt;/configuration&gt;</span><br><span class="line">           &lt;/plugin&gt;</span><br><span class="line">       &lt;/plugins&gt;</span><br><span class="line">   &lt;/build&gt;</span><br><span class="line">   &lt;dependencies&gt;</span><br><span class="line">       &lt;!--rabbitmq 依赖客户端--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">5.8</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--操作文件流的一个依赖--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">2.6</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">1.7</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h4 id="3-1-2消费生产者"><a href="#3-1-2消费生产者" class="headerlink" title="3.1.2消费生产者"></a>3.1.2消费生产者</h4><p>RabbitMQ 工作原理图<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151447611.png" alt="image-20230115144729758"></p><p>步骤：</p><ol><li>创建连接工厂</li><li>设置连接 RabbitMQ 的 IP 地址</li><li>设置用户名和密码</li><li>创建连接</li><li>获取信道</li><li>生成队列</li><li>发送消息</li></ol><p>创建一个生产者类 Producer，发送消息 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 生产者：发送消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/1/15 12:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RABBITMQ_HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 工厂 IP 连接 RabbitMQ 的队列</span></span><br><span class="line">        connectionFactory.setHost(RABBITMQ_HOST);</span><br><span class="line">        <span class="comment">// 用户名</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 密码</span></span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">// 获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.队列里面的消息是否持久化（磁盘） 默认情况下消息存储在内存中</span></span><br><span class="line"><span class="comment">         * 3.该队列是否只供一个消费者消费，是否进行消息共享，true: 多个消费者消费 flase: 只能一个消费者消费</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除，最后一个消费者端开连接以后 该队列是否自动删除，true 自动删除 false 不自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 发消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消费</span></span><br><span class="line"><span class="comment">         * 1.发送到哪个交换机</span></span><br><span class="line"><span class="comment">         * 2.路由的 key 值是哪个 本次队列的名称</span></span><br><span class="line"><span class="comment">         * 3.其他参数信息</span></span><br><span class="line"><span class="comment">         * 4.发送消息的本体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送成功后可以在管理客户端中 Queues 中查看详情</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151256110.png" alt="image-20230115125655206"></p><h4 id="3-1-3消息消费者"><a href="#3-1-3消息消费者" class="headerlink" title="3.1.3消息消费者"></a>3.1.3消息消费者</h4><p>创建一个消费者 Consumer 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 生产者：发送消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/1/15 12:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RABBITMQ_HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 工厂 IP 连接 RabbitMQ 的队列</span></span><br><span class="line">        connectionFactory.setHost(RABBITMQ_HOST);</span><br><span class="line">        <span class="comment">// 用户名</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 密码</span></span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">// 获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.队列里面的消息是否持久化（磁盘） 默认情况下消息存储在内存中</span></span><br><span class="line"><span class="comment">         * 3.该队列是否只供一个消费者消费，是否进行消息共享，true: 多个消费者消费 flase: 只能一个消费者消费</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除，最后一个消费者端开连接以后 该队列是否自动删除，true 自动删除 false 不自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 发消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消费</span></span><br><span class="line"><span class="comment">         * 1.发送到哪个交换机</span></span><br><span class="line"><span class="comment">         * 2.路由的 key 值是哪个 本次队列的名称</span></span><br><span class="line"><span class="comment">         * 3.其他参数信息</span></span><br><span class="line"><span class="comment">         * 4.发送消息的本体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-4常见报错以及解决"><a href="#3-1-4常见报错以及解决" class="headerlink" title="3.1.4常见报错以及解决"></a>3.1.4常见报错以及解决</h4><ol><li>SQL4J 错误</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151235731.png" alt="image-20230115123511995"></p><p>添加 SLF4J 依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.7</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建连接java.net.ConnectException: Connection timed out: connect</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301151254283.png" alt="image-20230115125416151"></p><p>​原因：服务器的 5672 端口没有开启，在服务器开启 5672 端口，重新启动即可</p><h3 id="3-2-Work-Queues-案例"><a href="#3-2-Work-Queues-案例" class="headerlink" title="3.2 Work Queues 案例"></a>3.2 Work Queues 案例</h3><p>工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p><p><img src="E:\java\Learn\消息队列\墨枫消息队列.assets\202301151502309.png" alt="image-20230115150241640"></p><h4 id="3-2-1-轮询分发消息"><a href="#3-2-1-轮询分发消息" class="headerlink" title="3.2.1 轮询分发消息"></a>3.2.1 轮询分发消息</h4><p>在这个案例中我们会启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程 是如何工作的。</p><h4 id="3-2-2-抽取工具类"><a href="#3-2-2-抽取工具类" class="headerlink" title="3.2.2 抽取工具类"></a>3.2.2 抽取工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接工厂创建信道的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqUtils</span> &#123;</span><br><span class="line">  <span class="comment">// 队列名称</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RABBITMQ_HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//创建一个连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(RABBITMQ_HOST);</span><br><span class="line">    factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">    <span class="keyword">return</span> channel;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-启动两个线程"><a href="#3-2-3-启动两个线程" class="headerlink" title="3.2.3 启动两个线程"></a>3.2.3 启动两个线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 工作线程（相当于之前的消费者）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/1/15 15:13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 取消消息时的回调</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">&quot;消费者取消消接口回调逻辑！！&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;A1 等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="comment">// System.out.println(&quot;A2 等待接收消息.....&quot;);</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费者消费</span></span><br><span class="line"><span class="comment">         * 1.消费哪个队列</span></span><br><span class="line"><span class="comment">         * 2.消费成功后是否需要自动应答 true 代表自动应答 false 代表手动应答</span></span><br><span class="line"><span class="comment">         * 3.消费者未成功消费的回调</span></span><br><span class="line"><span class="comment">         * 4.消费者取录消费的回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IDEA 配置</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301152127541.png" alt="image-20230115212723655"></p><p>点击 Modify options </p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301152129021.png" alt="image-20230115212858945"></p><p>勾选 Allow mutiple instances 即可</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301152129589.png" alt="image-20230115212929005"></p><p>启动后控制台输出</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301152131294.png" alt="image-20230115213101094"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301152131294.png" alt="image-20230115213113872"></p><h4 id="3-2-4-启动一个发送线程"><a href="#3-2-4-启动一个发送线程" class="headerlink" title="3.2.4 启动一个发送线程"></a>3.2.4 启动一个发送线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 生产者 发送大量消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/1/15 15:30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送发量消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 队列声明</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.队列里面的消息是否持久化（磁盘） 默认情况下消息存储在内存中</span></span><br><span class="line"><span class="comment">         * 3.该队列是否只供一个消费者消费，是否进行消息共享，true: 多个消费者消费 flase: 只能一个消费者消费</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除，最后一个消费者端开连接以后 该队列是否自动删除，true 自动删除 false 不自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 从控制台当中接收信息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 发送一个消费</span></span><br><span class="line"><span class="comment">             * 1.发送到哪个交换机</span></span><br><span class="line"><span class="comment">             * 2.路由的 key 值是哪个 本次队列的名称</span></span><br><span class="line"><span class="comment">             * 3.其他参数信息</span></span><br><span class="line"><span class="comment">             * 4.发送消息的本体</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息完成：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-5-结果展示"><a href="#3-2-5-结果展示" class="headerlink" title="3.2.5 结果展示"></a>3.2.5 结果展示</h4><p>生产者控制台</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301152133408.png" alt="image-20230115213341185"></p><p>消费者</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301152134867.png" alt="image-20230115213424143"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301152134447.png" alt="image-20230115213454899"></p><h3 id="3-3消息应答"><a href="#3-3消息应答" class="headerlink" title="3.3消息应答"></a>3.3消息应答</h3><h4 id="3-3-1概念"><a href="#3-3-1概念" class="headerlink" title="3.3.1概念"></a>3.3.1概念</h4><p>​消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成 了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消 息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续 发送给该消费这的消息，因为它无法接收到。</p><p>​为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是:<strong>消费者在接 收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong> </p><h4 id="3-3-2自动应答"><a href="#3-3-2自动应答" class="headerlink" title="3.3.2自动应答"></a>3.3.2自动应答</h4><p>​消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢 失了,当然另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>， 当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终 使得内存耗尽，最终这些消费者线程被操作系统杀死，<strong>所以这种模式仅适用在消费者可以高效并 以某种速率能够处理这些消息的情况下使用。</strong></p><h4 id="3-3-3消息应答的方法"><a href="#3-3-3消息应答的方法" class="headerlink" title="3.3.3消息应答的方法"></a>3.3.3消息应答的方法</h4><ul><li>A.Channel.basicAck(用于肯定确认)</li></ul><p>​RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了 </p><ul><li><p>B.Channel.basicNack(用于否定确认) </p></li><li><p>C.Channel.basicReject(用于否定确认)</p></li></ul><p>​与 Channel.basicNack 相比少一个参数 </p><p>​不处理该消息了直接拒绝，可以将其丢弃了</p><h4 id="3-3-4Multiple-的解释"><a href="#3-3-4Multiple-的解释" class="headerlink" title="3.3.4Multiple 的解释"></a>3.3.4Multiple 的解释</h4><p><strong>手动应答的好处是可以批量应答并且减少网络拥堵</strong> </p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302011244918.png" alt="image-20230201124424828"></p><p>multiple 的 true 和 false 代表不同意思</p><ul><li><p><strong>true 代表批量应答 channel 上未应答的消息</strong><br>比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答</p></li><li><p>false 同上面相比</p><p>只会应答 tag&#x3D;8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</p></li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302011246745.png" alt="image-20230201124615067"></p><h4 id="3-3-5消息自动重新入队"><a href="#3-3-5消息自动重新入队" class="headerlink" title="3.3.5消息自动重新入队"></a>3.3.5消息自动重新入队</h4><p>​如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息 未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302011249441.png" alt="image-20230201124936989"></p><h4 id="3-3-6消息手动应答代码"><a href="#3-3-6消息手动应答代码" class="headerlink" title="3.3.6消息手动应答代码"></a>3.3.6消息手动应答代码</h4><p>​默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改 为手动应答，消费者在上面代码的基础上增加下面画红色部分代码。</p><p>WorkConsumer03.java</p><p>消费生产者 Task2.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消息在手动应答时是不丢失、放回队列中重新消费</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/1/15 21:22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 在控制台输入信息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者 01</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消息在手动应答时是不丢失、放回队列中重新消费</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/1 19:54</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkConsumer03</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1 等待接收消息处理时间较短&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 沉睡一秒</span></span><br><span class="line">            SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">// 手动应答</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1. 消息的标记</span></span><br><span class="line"><span class="comment">             * 2. 是否批量应答 false:不批量应答信道中的消息 true: 批量</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, (consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>消费者 02</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消息在手动应答时是不丢失、放回队列中重新消费</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/1 19:54</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkConsumer04</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C2 等待接收消息处理时间较长&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 沉睡一秒</span></span><br><span class="line">            SleepUtils.sleep(<span class="number">30</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">// 手动应答</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1. 消息的标记</span></span><br><span class="line"><span class="comment">             * 2. 是否批量应答 false:不批量应答信道中的消息 true: 批量</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, (consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>睡眠工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepUtils</span> &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 睡眠工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Params</span>: [second]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> void</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 20:06 2023/2/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> second)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   Thread.sleep(<span class="number">1000</span> * second);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException _ignored) &#123;</span><br><span class="line">   Thread.currentThread().interrupt();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-7手动应答效果演示"><a href="#3-3-7手动应答效果演示" class="headerlink" title="3.3.7手动应答效果演示"></a>3.3.7手动应答效果演示</h4><p>正常情况下消息发送方发送两个消息 C1 和 C2 分别接收到消息并进行处理</p><p><img src="E:\java\Learn\消息队列\墨枫消息队列.assets\202302012217011.png" alt="image-20230201221717743"></p><p>在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是 由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了， 此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302012218291.png" alt="image-20230201221845892"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302012219238.png" alt="image-20230201221859910"></p><h3 id="3-4RabbitMQ-持久化"><a href="#3-4RabbitMQ-持久化" class="headerlink" title="3.4RabbitMQ 持久化"></a>3.4RabbitMQ 持久化</h3><h4 id="3-4-1概念"><a href="#3-4-1概念" class="headerlink" title="3.4.1概念"></a>3.4.1概念</h4><p>​刚刚我们已经看到了如何处理任务不丢失的情况，但是如何保障当 RabbitMQ 服务停掉以后消息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化。</strong></p><h4 id="3-4-2队列如何实现持久化"><a href="#3-4-2队列如何实现持久化" class="headerlink" title="3.4.2队列如何实现持久化"></a>3.4.2队列如何实现持久化</h4><p>​之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果 要队列实现持久化 需要在声明队列的时候把 durable 参数设置为持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让消息队列持久化</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">channel.queueDeclare(ACK_QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>​但是需要注意的就是如果之前声明的队列不是持久化的，需要把<strong>原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302021052636.png"></p><p>以下为控制台中持久化与非持久化队列的 UI 显示区</p><p>Features 显示 ”D“ 表示已经进行持久化了，Durable 首字母</p><p>显示 “AD Excl” 表示临时的</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302021054586.png" alt="image-20230202105412616"></p><p><strong>这个时候即使重启 rabbitmq 队列也依然存在</strong></p><h4 id="3-4-3消息实现持久化"><a href="#3-4-3消息实现持久化" class="headerlink" title="3.4.3消息实现持久化"></a>3.4.3消息实现持久化</h4><p>​要想让消息实现持久化需要在消息生产者修改代码，MessageProperties.PERSISTENT_TEXT_PLAIN 添 加这个属性。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302021104433.png" alt="image-20230202110410839"></p><p>​将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是 这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果需要 更强有力的持久化策略，参考后边课件发布确认章节。</p><h4 id="3-4-4不公开分发"><a href="#3-4-4不公开分发" class="headerlink" title="3.4.4不公开分发"></a>3.4.4不公开分发</h4><p>​在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是 很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间 处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p><p>为了避免这种情况，我们可以在消费者中设置参数 channel.basicQos(1);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 设置不公平分发</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302021114259.png" alt="image-20230202111414999"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302021116053.png" alt="image-20230202111647356"></p><p>​意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个 任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加 新的 worker 或者改变其他存储任务的策略。</p><h4 id="3-4-5预取值"><a href="#3-4-5预取值" class="headerlink" title="3.4.5预取值"></a>3.4.5预取值</h4><p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费<br>者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此</strong><br><strong>缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。</strong>这个时候就可以通过使用 basic.qos 方法设<br>置“预取计数”值来完成的。<strong>该值定义通道上允许的未确认消息的最大数量。</strong>一旦数量达到配置的数量，<br>RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有<br>未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何<br>消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知<br>这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高<br>向消费者传递消息的速度<strong>。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理</strong><br><strong>的消息的数量也会增加，从而增加了消费者的 RAM 消耗</strong>(随机存取存储器)应该小心使用具有无限预处理<br>的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的<br>内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范<br>围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为 1 是最保守的。当然这<br>将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境<br>中。对于大多数应用来说，稍微高一点的值将是最佳的。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302021144460.png" alt="image-20230202114359020"></p><h2 id="4-发布确认"><a href="#4-发布确认" class="headerlink" title="4.发布确认"></a>4.发布确认</h2><h3 id="4-1发布确认原理"><a href="#4-1发布确认原理" class="headerlink" title="4.1发布确认原理"></a>4.1发布确认原理</h3><p>​生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，**所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)**，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队 列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p><p>​confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消 息，生产者应用程序同样可以在回调方法中处理该 nack 消息</p><h3 id="4-2发布确认策略"><a href="#4-2发布确认策略" class="headerlink" title="4.2发布确认策略"></a>4.2发布确认策略</h3><h4 id="4-2-1开启发布确认的方法"><a href="#4-2-1开启发布确认的方法" class="headerlink" title="4.2.1开启发布确认的方法"></a>4.2.1开启发布确认的方法</h4><p>​发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布 确认，都需要在 channel 上调用该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel(); </span><br><span class="line"><span class="comment">// 开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure><h4 id="4-2-2单个确认发布"><a href="#4-2-2单个确认发布" class="headerlink" title="4.2.2单个确认发布"></a>4.2.2单个确认发布</h4><p>​这是一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，也就是发布一个消息之后只有它 被确认发布，后续的消息才能继续发布, waitForConfirmsOrDie(long) 这个方法只有在消息被确认 的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p><p>​这种确认方式有一个最大的缺点就是:<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会 阻塞所有后续消息的发布，<strong>这种方式最多提供每秒不超过数百条发布消息的吞吐量</strong>。当然对于某 些应用程序来说这可能已经足够了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">SinglePublishMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 队列的声明</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 批量发消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            <span class="comment">// 单个消息就马上进行发布确认</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送成功！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个单独确认消息，耗时&quot;</span> + (endTime - beginTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3批量发布确认"><a href="#4-2-3批量发布确认" class="headerlink" title="4.2.3批量发布确认"></a>4.2.3批量发布确认</h4><p>​上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是:<strong>当发生故障导致发布出现问题时，不知道是哪个消息出现 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。</strong>当然这种 方案仍然是同步的，也一样阻塞消息的发布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">BatchPublishMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 队列的声明</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 批量确认大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 批量发消息 批量发布确认</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            <span class="comment">// 判断达到 100 条消息的时候，批量确认一次</span></span><br><span class="line">            <span class="keyword">if</span>((i + <span class="number">1</span>) % batchSize == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 发布确认</span></span><br><span class="line">                channel.waitForConfirms();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个批量确认消息，耗时&quot;</span> + (endTime - beginTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4如何处理异步未确认的消息"><a href="#4-2-4如何处理异步未确认的消息" class="headerlink" title="4.2.4如何处理异步未确认的消息"></a>4.2.4如何处理异步未确认的消息</h4><p>​最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传 递。</p><h4 id="4-2-5-ConcurrentSkipListMap"><a href="#4-2-5-ConcurrentSkipListMap" class="headerlink" title="4.2.5 ConcurrentSkipListMap"></a>4.2.5 ConcurrentSkipListMap</h4><p>ConcurrentSkipListMap 是线程安全的有序的哈希表，适用于高并发的场景。<br>ConcurrentSkipListMap 和T reeMap，它们虽然都是有序的哈希表。</p><ul><li>第一，它们的线程安全机制不同，TreeMap 是非线程安全的，而 ConcurrentSkipListMap 是线程安全的。</li><li>第二，ConcurrentSkipListMap 是通过跳表实现的，而TreeMap是通过红黑树实现的。</li></ul><p>在4线程1.6万数据的条件下，ConcurrentHashMap 存取速度是ConcurrentSkipListMap 的4倍左右。</p><p>但ConcurrentSkipListMap有几个ConcurrentHashMap 不能比拟的优点：</p><ol><li>ConcurrentSkipListMap 的key是有序的。</li><li>ConcurrentSkipListMap 支持更高的并发。<br>ConcurrentSkipListMap 的存取时间是log（N），和线程数几乎无关。也就是说在数据量一定的情况下，并发的线程越多，ConcurrentSkipListMap越能体现出他的优势。</li></ol><p>在非多线程的情况下，应当尽量使用 TreeMap。此外对于并发性相对较低的并行程序可以使用Collections.synchronizedSortedMap 将 TreeMap 进行包装，也可以提供较好的效率。对于高并发程序，应当使用 ConcurrentSkipListMap，能够提供更高的并发度。<br>所以在多线程程序中，如果需要对Map的键值进行排序时，请尽量使用 ConcurrentSkipListMap，可能得到更好的并发度。<br>注意，调用 ConcurrentSkipListMap 的 size 时，由于多个线程可以同时对映射表进行操作，所以映射表需要遍历整个链表才能返回元素个数，这个操作是个 O(log(n)) 的操作。</p><h4 id="4-2-6异步确认发布"><a href="#4-2-6异步确认发布" class="headerlink" title="4.2.6异步确认发布"></a>4.2.6异步确认发布</h4><p>​异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302031021754.png" alt="image-20230203102145627"></p><p>异步确认实现具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">AsyncPublishMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 队列的声明</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程安全的有序的哈希表</span></span><br><span class="line"><span class="comment">         * 1. 轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment">         * 2. 轻松地批量删除条目 只要给到序号</span></span><br><span class="line"><span class="comment">         * 3. 支持高并发 （多线程）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 消息确认成功 回调函数</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">                <span class="comment">// 2、删除已经确认的消息 剩下的就是未确认的消息</span></span><br><span class="line">                ConcurrentNavigableMap&lt;Long, String&gt; confirms = outstandingConfirms.headMap(deliveryTag);</span><br><span class="line">                confirms.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                outstandingConfirms.remove(deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;确认的消息&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 消息确认失败 回调函数 参数1：消息的标记 参数2：是否为批量确认</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 3、打印未确认的消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> outstandingConfirms.get(deliveryTag);</span><br><span class="line">            System.out.println(<span class="string">&quot;未确认的消息时：&quot;</span> + message + <span class="string">&quot;未确认的消息 tag: &quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 准备消息的监听器 监听消息的发送状态 异步通知</span></span><br><span class="line">        channel.addConfirmListener(ackCallback, nackCallback);</span><br><span class="line">        <span class="comment">// 批量发消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;消息&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            <span class="comment">// 1、此处记录下所有发送的消息 消息的总和</span></span><br><span class="line">            outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个异步发布确认消息，耗时&quot;</span> + (endTime - beginTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-7单个、批量、异步批量确认发布速度对比"><a href="#4-2-7单个、批量、异步批量确认发布速度对比" class="headerlink" title="4.2.7单个、批量、异步批量确认发布速度对比"></a>4.2.7单个、批量、异步批量确认发布速度对比</h4><ul><li><strong>单独发布消息</strong><br>同步等待确认，简单，但吞吐量非常有限。 </li><li><strong>批量发布消息</strong><br>批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条 消息出现了问题。 </li><li><strong>异步处理</strong><br>最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 单个确认 发布1000个单独确认消息，耗时58713ms</span></span><br><span class="line">        <span class="comment">//SinglePublishMessage();</span></span><br><span class="line">        <span class="comment">// 2. 批量确认 发布1000个批量确认消息，耗时303ms</span></span><br><span class="line">        <span class="comment">//BatchPublishMessage();</span></span><br><span class="line">        <span class="comment">// 3. 异步批量确认 发布1000个异步发布确认消息，耗时123ms</span></span><br><span class="line">        AsyncPublishMessage();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-交换机"><a href="#5-交换机" class="headerlink" title="5.交换机"></a>5.交换机</h2><p>​在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消 费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式 称为 ”发布&#x2F;订阅”.</p><p>​为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘， 另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费 者者</p><h3 id="5-1Exchange"><a href="#5-1Exchange" class="headerlink" title="5.1Exchange"></a>5.1Exchange</h3><h4 id="5-1-1Exhcange-概念"><a href="#5-1-1Exhcange-概念" class="headerlink" title="5.1.1Exhcange 概念"></a>5.1.1Exhcange 概念</h4><p>​RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列。</strong>实际上，通常生产 者甚至都不知道这些消息传递传递到了哪些队列中。</p><p>​相反，**生产者只能将消息发送到交换机(exchange)**，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消 息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p><h4 id="5-1-2Exchange-的类型"><a href="#5-1-2Exchange-的类型" class="headerlink" title="5.1.2Exchange 的类型"></a>5.1.2Exchange 的类型</h4><p>一共有四种类型：</p><ul><li>扇出（fanout)</li><li>直接（direct)</li><li>主题（topic)</li><li>标题（headers)</li></ul><h4 id="5-1-3无名-Exchange"><a href="#5-1-3无名-Exchange" class="headerlink" title="5.1.3无名 Exchange"></a>5.1.3无名 Exchange</h4><p>​在本教程的前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure><p>​第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实 是由 routingKey(bindingkey) 绑定 key 指定的，如果它存在的话</p><h3 id="5-2临时队列"><a href="#5-2临时队列" class="headerlink" title="5.2临时队列"></a>5.2临时队列</h3><p>​之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们 来说至关重要-我们需要指定我们的消费者去消费哪个队列的消息。</p><p>​每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个<strong>具有随机名称的队列</strong>，或者能让服务器为我们选择一个随机队列名称那就更好了。其次<strong>一旦我们断开了消费者的连接，队列将被自动删除。</strong></p><p>创建临时队列的方式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061443690.png" alt="image-20230206144301384"></p><h3 id="5-3绑定（bindings）"><a href="#5-3绑定（bindings）" class="headerlink" title="5.3绑定（bindings）"></a>5.3绑定（bindings）</h3><p>​什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队 列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061443553.png" alt="image-20230206144353313"></p><h3 id="5-4Fanout"><a href="#5-4Fanout" class="headerlink" title="5.4Fanout"></a>5.4Fanout</h3><h4 id="5-4-1Fanout-介绍"><a href="#5-4-1Fanout-介绍" class="headerlink" title="5.4.1Fanout 介绍"></a>5.4.1Fanout 介绍</h4><p>​Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息<strong>广播</strong>到它知道的 所有队列中。系统中默认有些 exchange 类型</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061446628.png" alt="image-20230206144651541"></p><h4 id="5-4-2-Fanout-实战"><a href="#5-4-2-Fanout-实战" class="headerlink" title="5.4.2 Fanout 实战"></a>5.4.2 Fanout 实战</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061447080.png" alt="image-20230206144736810"></p><p>Logs 和临时队列的绑定关系如下图</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061449491.png" alt="image-20230206144927335"></p><p>ReceiveLogs01 将接收到的消息打印在控制台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消息接收</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/5 9:58</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLog01</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明一个临时队列（非连接状态会删除）</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个临时队列、队列的名称是随机的</span></span><br><span class="line"><span class="comment">         * 当消费者断开与队列的连接的时候，队列会自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">// 绑定交换机与队列</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息，把接收消息打印在屏幕上。。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLog01控制台打印接收到的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 消费者取消消息时回调接口</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReceiveLogs02 将接收到的消息打印在控制台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消息接收</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/5 9:58</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLog02</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明一个临时队列（非连接状态会删除）</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个临时队列、队列的名称是随机的</span></span><br><span class="line"><span class="comment">         * 当消费者断开与队列的连接的时候，队列会自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">// 绑定交换机与队列</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息，把接收消息打印在屏幕上。。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLog02 控制台打印接收到的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">//File file = new File(&quot;D:\\桌面\\RabbitMQ\\fanoutPrint.txt&quot;);</span></span><br><span class="line">            <span class="comment">//FileUtils.writeStringToFile(file, new String(message.getBody(), &quot;UTF-8&quot;), &quot;UTF-8&quot;);</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;数据写入文件成功！&quot;);</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 消费者取消消息时回调接口</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EmitLog 发送消息给两个消费者接收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 发消息 交换机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 12:09</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-Direct-exchange"><a href="#5-5-Direct-exchange" class="headerlink" title="5.5 Direct exchange"></a>5.5 Direct exchange</h3><h4 id="5-5-1回顾"><a href="#5-5-1回顾" class="headerlink" title="5.5.1回顾"></a>5.5.1回顾</h4><p>​在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本 节我们将向其中添加一些特别的功能-比方说我们只让某个消费者订阅发布的部分消息。例如我们只把 严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。</p><p>​我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： <strong>队列只对它绑定的交换机的消息感兴趣。</strong>绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);<strong>绑定之后的 意义由其交换类型决定。</strong></p><h4 id="5-5-2-Direct-exhcange-介绍"><a href="#5-5-2-Direct-exhcange-介绍" class="headerlink" title="5.5.2 Direct exhcange 介绍"></a>5.5.2 Direct exhcange 介绍</h4><p>​上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希 望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061502033.png" alt="image-20230206150241071"></p><p>​在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列 Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green.</p><p>​在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p><h4 id="5-5-3-多重绑定"><a href="#5-5-3-多重绑定" class="headerlink" title="5.5.3 多重绑定"></a>5.5.3 多重绑定</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061503490.png" alt="image-20230206150325345"></p><p>​当然如果 exchange 的绑定类型是 direct，<strong>但是它绑定的多个队列的 key 如果都相同</strong>，在这种情 况下虽然绑定类型是 direct <strong>但是它表现的就和 fanout 有点类似了</strong>，就跟广播差不多，如上图所示。</p><h4 id="5-5-4-Direct-Exchange-实战"><a href="#5-5-4-Direct-Exchange-实战" class="headerlink" title="5.5.4 Direct Exchange 实战"></a>5.5.4 Direct Exchange 实战</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061504204.png" alt="image-20230206150431067"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061506532.png" alt="image-20230206150649262"></p><p>ReceiveLogsDirect01.java 接收消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:等待接收消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 12:21</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">// 声明一个队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;console&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;console&quot;</span>, EXCHANGE_NAME, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;console&quot;</span>, EXCHANGE_NAME, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLogsDirect01 控制台打印接收到的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 消费者取消消息时回调接口</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;console&quot;</span>, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReceiveLogsDirect02.java 接收消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 等待接收消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 12:21</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">// 声明一个队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;disk&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;disk&quot;</span>, EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLogsDirect02 控制台打印接收到的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 消费者取消消息时回调接口</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;disk&quot;</span>, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DirectLogs 生产者发消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 发消息 交换机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 12:09</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectLogs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-Topics"><a href="#5-6-Topics" class="headerlink" title="5.6 Topics"></a>5.6 Topics</h3><h4 id="5-6-1-fanout、direct类型的问题"><a href="#5-6-1-fanout、direct类型的问题" class="headerlink" title="5.6.1 fanout、direct类型的问题"></a>5.6.1 fanout、direct类型的问题</h4><p>​在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是 使用了 direct 交换机，从而有能实现有选择性地接收日志。</p><p>​尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候 direct 就办不到了。这个时候 就只能使用 topic 类型</p><h4 id="5-6-2-Topic-的要求"><a href="#5-6-2-Topic-的要求" class="headerlink" title="5.6.2 Topic 的要求"></a>5.6.2 Topic 的要求</h4><p>​发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它<strong>必须是一个单词列表，以点号分隔开。</strong>这些单词可以是任意单词，比如说：”stock.usd.nyse”, “nyse.vmw”,  “quick.orange.rabbit”.这种类型的。当然这个单词列表最多不能超过 255 个字节。</p><p>在这个规则列表中，其中有两个替换符是大家需要注意的 </p><ul><li>***(星号)可以代替一个单词** </li><li><strong>#(井号)可以替代零个或多个单词</strong></li></ul><h4 id="5-6-3-Topic-匹配案例"><a href="#5-6-3-Topic-匹配案例" class="headerlink" title="5.6.3 Topic 匹配案例"></a>5.6.3 Topic 匹配案例</h4><p>下图绑定关系如下<br>Q1–&gt;绑定的是<br>         中间带 orange 带 3 个单词的字符串(<em>.orange.</em>)<br>Q2–&gt;绑定的是<br>        最后一个单词是 rabbit 的 3 个单词(<em>.</em>.rabbit)<br>        第一个单词是 lazy 的多个单词(lazy.#)</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061513539.png" alt="image-20230206151331534"></p><p>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的</p><table><thead><tr><th>routingKey</th><th>数据内容</th></tr></thead><tbody><tr><td>quick.orange.rabbit</td><td>被队列 Q1Q2 接收到</td></tr><tr><td>lazy.orange.elephant</td><td>被队列 Q1Q2 接收到</td></tr><tr><td>quick.orange.fox</td><td>被队列 Q1 接收到</td></tr><tr><td>lazy.brown.fox</td><td>被队列 Q2 接收到</td></tr><tr><td>lazy.pink.rabbit</td><td>虽然满足两个绑定但只被队列 Q2 接收一次</td></tr><tr><td>quick.brown.fox</td><td>不匹配任何绑定不会被任何队列接收到会被丢弃</td></tr><tr><td>quick.orange.male.rabbit</td><td>是四个单词不匹配任何绑定会被丢弃</td></tr><tr><td>lazy.orange.male.rabbit</td><td>是四个单词但匹配 Q2</td></tr></tbody></table><p>当队列绑定关系是下列这种情况时需要引起注意</p><ul><li><strong>当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像 fanout 了</strong> </li><li><strong>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了</strong></li></ul><h4 id="5-6-4-Topic-实战"><a href="#5-6-4-Topic-实战" class="headerlink" title="5.6.4 Topic 实战"></a>5.6.4 Topic 实战</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061520103.png" alt="image-20230206152004674"></p><p>生产者 EmitLogTopic</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 生产者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 13:32</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLogTopic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Q1--&gt;绑定的是</span></span><br><span class="line"><span class="comment">         *  中间带 orange 带 3 个单词的字符串(*.orange.*)</span></span><br><span class="line"><span class="comment">         * Q2--&gt;绑定的是</span></span><br><span class="line"><span class="comment">         * 最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)</span></span><br><span class="line"><span class="comment">         * 第一个单词是 lazy 的多个单词(lazy.#)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.rabbit&quot;</span>,<span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.orange.elephant&quot;</span>,<span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.fox&quot;</span>,<span class="string">&quot;被队列 Q1 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.brown.fox&quot;</span>,<span class="string">&quot;被队列 Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.pink.rabbit&quot;</span>,<span class="string">&quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.brown.fox&quot;</span>,<span class="string">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.male.rabbit&quot;</span>,<span class="string">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.orange.male.rabbit&quot;</span>,<span class="string">&quot;是四个单词但匹配 Q2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者 ReceiveLogsTopic01</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 声明主题交换机及相关队列</span></span><br><span class="line"><span class="comment"> * 消费者 C1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 13:18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;Q1&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息......&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;接收队列：&quot;</span> + queueName + <span class="string">&quot;    绑定键：&quot;</span> + message.getEnvelope().getRoutingKey());</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者 ReceiveLogsTopic02</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 声明主题交换机及相关队列</span></span><br><span class="line"><span class="comment"> * 消费者 C2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 13:18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;Q2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息......&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;接收队列：&quot;</span> + queueName + <span class="string">&quot;    绑定键：&quot;</span> + message.getEnvelope().getRoutingKey());</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-5-实战结果"><a href="#5-6-5-实战结果" class="headerlink" title="5.6.5 实战结果"></a>5.6.5 实战结果</h4><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061523899.png" alt="image-20230206152253327" style="zoom: 80%;" /><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061523044.png" alt="image-20230206152331685" style="zoom:80%;" /><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302061524085.png" alt="image-20230206152357134" style="zoom:80%;" /><h2 id="6-死信队列"><a href="#6-死信队列" class="headerlink" title="6.死信队列"></a>6.死信队列</h2><h3 id="6-1-死信的概念"><a href="#6-1-死信的概念" class="headerlink" title="6.1 死信的概念"></a>6.1 死信的概念</h3><p>​先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候<strong>由于特定的原因导致 queue 中的某些消息无法被消费</strong>，这样的消息如果没有 后续的处理，就变成了死信，有死信自然就有了死信队列。</p><p>​应用场景:为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息 消费发生异常时，将消息投入死信队列中.还有比如说: 用户在商城下单成功并点击去支付后在指定时 间未支付时自动失效</p><h3 id="6-2-死信的来源"><a href="#6-2-死信的来源" class="headerlink" title="6.2 死信的来源"></a>6.2 死信的来源</h3><ul><li>消息 TTL 过期</li><li>队列达到最大长度(队列满了，无法再添加数据到 mq 中)</li><li>消息被拒绝(basic.reject 或 basic.nack)并且 requeue&#x3D;false</li></ul><h3 id="6-3-死信实战"><a href="#6-3-死信实战" class="headerlink" title="6.3 死信实战"></a>6.3 死信实战</h3><h4 id="6-3-1-代码架构图"><a href="#6-3-1-代码架构图" class="headerlink" title="6.3.1 代码架构图"></a>6.3.1 代码架构图</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062010451.png" alt="image-20230206201046563"></p><h4 id="6-3-2-消息-TTL-过期"><a href="#6-3-2-消息-TTL-过期" class="headerlink" title="6.3.2 消息 TTL 过期"></a>6.3.2 消息 TTL 过期</h4><p>生产者代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 死信队列之生产者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 16:59</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadQueueProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 死信消息 设置 TTL 时间 time to live 单位是 ms 1000ms = 10s</span></span><br><span class="line">        AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties()</span><br><span class="line">                        .builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, properties, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者 C1 代码(<strong>启动之后关闭该消费者 模拟其接收不到消息</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 19:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest01</span> &#123;</span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//死信队列绑定死信交换机与 routingkey</span></span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">normalQueue</span> <span class="operator">=</span> <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(normalQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(normalQueue, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者未发消息</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062017485.png" alt="image-20230206201726068"></p><p><strong>关闭该消费者 模拟其接收不到消息，</strong>生产者发送了 10 条消息 此时正常消息队列有 10 条未消费消息</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062019755.png" alt="image-20230206201902124"></p><p>时间过去 10 秒正常队列里面的消息由于没有被消费 消息进入死信队列</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062020450.png" alt="image-20230206202022049"></p><p>消费者 C2 代码(<strong>以上步骤完成后 启动 C2 消费者 它消费死信队列里面的消息</strong>) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消费者 2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 19:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收死信队列消息.....&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer02 接收死信队列的消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(deadQueue, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062028996.png" alt="image-20230206202810630"></p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062029507.png" alt="image-20230206202853014" style="zoom:80%;" /><h4 id="6-3-3-队列达到最大长度"><a href="#6-3-3-队列达到最大长度" class="headerlink" title="6.3.3 队列达到最大长度"></a>6.3.3 队列达到最大长度</h4><ol><li>消息生产者代码去掉 TTL 属性<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 死信队列之生产者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 16:59</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadQueueProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 死信消息 设置 TTL 时间 time to live 单位是 ms 1000ms = 10s</span></span><br><span class="line">        <span class="comment">//AMQP.BasicProperties properties =</span></span><br><span class="line">        <span class="comment">//        new AMQP.BasicProperties()</span></span><br><span class="line">        <span class="comment">//                .builder().expiration(&quot;10000&quot;).build();</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062040910.png" alt="image-20230206204034841"></p><ol start="2"><li>C1 消费者修改以下代码(<strong>启动之后关闭该消费者 模拟其接收不到消息</strong>)</li></ol><p>​主要是修改一下代码<br>​<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062043693.png" alt="image-20230206204318136" style="zoom: 80%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消费者 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 19:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest01</span> &#123;</span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//死信队列绑定死信交换机与 routingkey</span></span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置正常队列的长度的限制</span></span><br><span class="line">        params.put(<span class="string">&quot;x-max-length&quot;</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">normalQueue</span> <span class="operator">=</span> <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(normalQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(normalQueue, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意此时需要把原先队列删除 因为参数改变了</strong></p><ol start="3"><li>C2 消费者不变，直接启动即可<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062046744.png" alt="image-20230206204541411"></li></ol><p>​<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062046084.png" alt="image-20230206204628773"></p><h4 id="6-3-4-消息被拒"><a href="#6-3-4-消息被拒" class="headerlink" title="6.3.4 消息被拒"></a>6.3.4 消息被拒</h4><p>1.消息生产者代码同上生产者一致 </p><p>2.C1 消费者代码(<strong>启动之后关闭该消费者 模拟其接收不到消息</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消费者 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/6 19:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest01</span> &#123;</span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//死信队列绑定死信交换机与 routingkey</span></span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置正常队列的长度的限制</span></span><br><span class="line">        <span class="comment">//params.put(&quot;x-max-length&quot;, 6);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">normalQueue</span> <span class="operator">=</span> <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(normalQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;info5&quot;</span>.equals(message))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message + <span class="string">&quot;此消息是被 C1 拒绝的&quot;</span>);</span><br><span class="line">                channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span>+message);</span><br><span class="line">                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 开启手动应答</span></span><br><span class="line">        channel.basicConsume(normalQueue, <span class="literal">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动消费者 C1 ，启动生产者发送消息；有一条消息未被消费</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062108663.png" alt="image-20230206210828079"></p><p>启动 C2 消费死信队列</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302062109067.png" alt="image-20230206210949858"></p><h2 id="7-延迟队列"><a href="#7-延迟队列" class="headerlink" title="7.延迟队列"></a>7.延迟队列</h2><h3 id="7-1-延迟队列的概念"><a href="#7-1-延迟队列的概念" class="headerlink" title="7.1 延迟队列的概念"></a>7.1 延迟队列的概念</h3><p>​延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。</p><h3 id="7-2-延迟队列使用场景"><a href="#7-2-延迟队列使用场景" class="headerlink" title="7.2 延迟队列使用场景"></a>7.2 延迟队列使用场景</h3><ol><li>订单在十分钟之内未支付则自动取消</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。 </li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒。 </li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。 </li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li></ol><p>​这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎 使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果 数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支 付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十 分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万 级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单 的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081157842.png" alt="image-20230208115734612"></p><h3 id="7-3-RabbitMQ-中的-TTL"><a href="#7-3-RabbitMQ-中的-TTL" class="headerlink" title="7.3 RabbitMQ 中的 TTL"></a>7.3 RabbitMQ 中的 TTL</h3><p>​TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有 消息的最大存活时间，</p><p>​单位是毫秒。换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这 条消息如果在 TTL 设置的时间内没有被消费，则会成为”死信”。如果同时配置了队列的 TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p><h3 id="7-4-整合-springboot"><a href="#7-4-整合-springboot" class="headerlink" title="7.4 整合 springboot"></a>7.4 整合 springboot</h3><h4 id="7-4-1-创建项目"><a href="#7-4-1-创建项目" class="headerlink" title="7.4.1 创建项目"></a>7.4.1 创建项目</h4><ol><li>创建 spring initializr<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081200689.png" alt="image-20230208120020531"></li></ol><h4 id="7-4-2添加依赖"><a href="#7-4-2添加依赖" class="headerlink" title="7.4.2添加依赖"></a>7.4.2添加依赖</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--RabbitMQ 依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">1.2</span><span class="number">.47</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--swagger--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--RabbitMQ 测试依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h4 id="7-4-3-修改配置文件"><a href="#7-4-3-修改配置文件" class="headerlink" title="7.4.3 修改配置文件"></a>7.4.3 修改配置文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: admin</span><br><span class="line">    password: <span class="number">123</span></span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">8088</span></span><br></pre></td></tr></table></figure><h4 id="7-4-4-添加-Swagger-配置类"><a href="#7-4-4-添加-Swagger-配置类" class="headerlink" title="7.4.4 添加 Swagger 配置类"></a>7.4.4 添加 Swagger 配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mofeng.rabbitmq.springbootrabbitmq.config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="keyword">public</span> Docket <span class="title function_">webApiConfig</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line"> .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line"> .apiInfo(webApiInfo())</span><br><span class="line"> .select()</span><br><span class="line"> .build();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">private</span> ApiInfo <span class="title function_">webApiInfo</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line"> .title(<span class="string">&quot;rabbitmq 接口文档&quot;</span>)</span><br><span class="line"> .description(<span class="string">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)</span><br><span class="line"> .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line"> .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;enjoy6288&quot;</span>, <span class="string">&quot;inkmaple.xyz&quot;</span>, </span><br><span class="line"><span class="string">&quot;2435301806@qq.com&quot;</span>))</span><br><span class="line"> .build();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-5-队列-TTL"><a href="#7-5-队列-TTL" class="headerlink" title="7.5 队列 TTL"></a>7.5 队列 TTL</h3><h4 id="7-5-1-代码结构图"><a href="#7-5-1-代码结构图" class="headerlink" title="7.5.1 代码结构图"></a>7.5.1 代码结构图</h4><p>​创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交 换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081233133.png" alt="image-20230208123334952"></p><h4 id="7-5-2-配置文件类代码"><a href="#7-5-2-配置文件类代码" class="headerlink" title="7.5.2 配置文件类代码"></a>7.5.2 配置文件类代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TTL 队列 配置文件类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 12:34</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlQueueConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">X_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_A</span> <span class="operator">=</span> <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_B</span> <span class="operator">=</span> <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;QD&quot;</span>;</span><br><span class="line">    <span class="comment">// 声明 xExchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">xExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(X_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明 xExchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">yExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明队列 A ttl 为 10s 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//声明队列的 TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明队列 A 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueaBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明队列 B ttl 为 40s 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//声明队列的 TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">40000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明队列 B 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queuebBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queue1B,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue1B).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明死信队列 QD</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueD</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DEAD_LETTER_QUEUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明死信队列 QD 绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">deadLetterBindingQAD</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span></span><br><span class="line"><span class="params">                                        <span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-5-3-消息生产者代码"><a href="#7-5-3-消息生产者代码" class="headerlink" title="7.5.3 消息生产者代码"></a>7.5.3 消息生产者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 发送延迟消息</span></span><br><span class="line"><span class="comment"> * http://localhost:8080/ttl/sendMsg/嘻嘻嘻</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 13:05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMsgController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始发消息</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;, 发送一条信息给两个 TTL 队列：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot;消息来自 TTL 为 10s 的队列：&quot;</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;消息来自 TTL 为 40s 的队列：&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-5-4-消息消费者代码"><a href="#7-5-4-消息消费者代码" class="headerlink" title="7.5.4 消息消费者代码"></a>7.5.4 消息消费者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 队列 TTL 的消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 13:14</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterQueueConsumer</span> &#123;</span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到死信队列信息&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-5-5-启动类失败"><a href="#7-5-5-启动类失败" class="headerlink" title="7.5.5 启动类失败"></a>7.5.5 启动类失败</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081343513.png" alt="image-20230208134356194"></p><p><strong>解决方案：在启动类添加注解 @EnableWebMvc</strong></p><h4 id="7-5-6-发送消息报错"><a href="#7-5-6-发送消息报错" class="headerlink" title="7.5.6 发送消息报错"></a>7.5.6 发送消息报错</h4><p>发送<a href="http://localhost:8088/ttl/sendMsg/xxx">http://localhost:8088/ttl/sendMsg/xxx</a></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081347300.png" alt="image-20230208134739893"></p><p>检查 controller 类的 Mapping 是否正确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span></span><br></pre></td></tr></table></figure><h4 id="7-5-7-Channel-导包错误"><a href="#7-5-7-Channel-导包错误" class="headerlink" title="7.5.7 Channel 导包错误"></a>7.5.7 Channel 导包错误</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081402510.png" alt="image-20230208140219774"></p><p>错误的包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.channels.Channel;</span><br></pre></td></tr></table></figure><p>导入正确的包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br></pre></td></tr></table></figure><h4 id="7-5-8-结果展示"><a href="#7-5-8-结果展示" class="headerlink" title="7.5.8 结果展示"></a>7.5.8 结果展示</h4><p>10s 和 40s 后会在控制台输出结果</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081406242.png" alt="image-20230208140621305"></p><p>​第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。</p><p>​不过，如果这样使用的话，岂不是<strong>每增加一个新的时间需求，就要新增一个队列</strong>，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然 后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p><h3 id="7-6-延时队列优化"><a href="#7-6-延时队列优化" class="headerlink" title="7.6 延时队列优化"></a>7.6 延时队列优化</h3><h4 id="7-6-1-代码架构图"><a href="#7-6-1-代码架构图" class="headerlink" title="7.6.1 代码架构图"></a>7.6.1 代码架构图</h4><p>​在这里新增了一个队列 QC,绑定关系如下,该队列不设置 TTL 时间</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081636571.png" alt="image-20230208163609478"></p><h4 id="7-6-2-配置文件类添加代码"><a href="#7-6-2-配置文件类添加代码" class="headerlink" title="7.6.2 配置文件类添加代码"></a>7.6.2 配置文件类添加代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgTtlQueueConfig</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_C</span> <span class="operator">=</span> <span class="string">&quot;QC&quot;</span>;</span><br><span class="line"> <span class="comment">//声明队列 C 死信交换机</span></span><br><span class="line"> <span class="meta">@Bean(&quot;queueC&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span>&#123;</span><br><span class="line"> Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"> <span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line"> args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line"> <span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line"> args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line"> <span class="comment">//没有声明 TTL 属性</span></span><br><span class="line"> <span class="keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(args).build();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//声明队列 B 绑定 X 交换机</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="keyword">public</span> Binding <span class="title function_">queuecBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span></span><br><span class="line"><span class="params"> <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-6-3-消息生产者添加代码"><a href="#7-6-3-消息生产者添加代码" class="headerlink" title="7.6.3 消息生产者添加代码"></a>7.6.3 消息生产者添加代码</h4><p>在控制类中添加 sendMsg 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message,<span class="meta">@PathVariable</span> String ttlTime)</span> &#123;</span><br><span class="line"> rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, message, correlationData -&gt;&#123;</span><br><span class="line"> correlationData.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line"> <span class="keyword">return</span> correlationData;</span><br><span class="line"> &#125;);</span><br><span class="line"> log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒 TTL 信息给队列 C:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(),ttlTime, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起请求 </p><ul><li><p><a href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendExpirationMsg/你好</a> 1&#x2F;20000 </p></li><li><p><a href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendExpirationMsg/你好</a> 2&#x2F;2000</p></li></ul><p>控制台输出结果</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081646330.png" alt="image-20230208164611943"></p><p>​看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消 息可能并不会按时“死亡“，因为 <strong>RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。</strong></p><p>​<strong>队列中，实行先进先出的原则</strong></p><h3 id="7-7-RabbitMQ-插件实现延迟队列"><a href="#7-7-RabbitMQ-插件实现延迟队列" class="headerlink" title="7.7 RabbitMQ 插件实现延迟队列"></a>7.7 RabbitMQ 插件实现延迟队列</h3><p>​上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的 TTL 时间 及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。</p><h4 id="7-7-1-安装延时队列插件"><a href="#7-7-1-安装延时队列插件" class="headerlink" title="7.7.1 安装延时队列插件"></a>7.7.1 安装延时队列插件</h4><p>官网下载 <a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></p><p>下载 rabbitmq_delayed_message_exchange 插件，然后解压放置到 RabbitMQ 的插件目录。</p><p>参考下载和安装文章：<a href="https://blog.csdn.net/u010404909/article/details/125329160">https://blog.csdn.net/u010404909/article/details/125329160</a></p><ol><li>下载</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081704718.png" alt="image-20230208170412118"></p><ol start="2"><li>下载之后上传到 plugins 目录下</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081708179.png" alt="image-20230208170850734"></p><ol start="3"><li>进入 rabbitmq 的插件目录</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/lib/rabbitmq/lib/rabbitmq_server-<span class="number">3.8</span><span class="number">.8</span>/plugins</span><br></pre></td></tr></table></figure><ol start="4"><li>安裝</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><ol start="5"><li>重启 RabbitMQ</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><ol start="6"><li>重启之后在 RabbitMQ 控制后台如下显示即可</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302081711108.png" alt="image-20230208171155972"></p><h4 id="7-7-2-代码架构图"><a href="#7-7-2-代码架构图" class="headerlink" title="7.7.2 代码架构图"></a>7.7.2 代码架构图</h4><p>​在这里新增了一个队列 delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下:</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302082121961.png" alt="image-20230208212145760"></p><h4 id="7-7-3-配置文件类-DelayedQueueConfig"><a href="#7-7-3-配置文件类-DelayedQueueConfig" class="headerlink" title="7.7.3 配置文件类 DelayedQueueConfig"></a>7.7.3 配置文件类 DelayedQueueConfig</h4><p>​在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制 消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才 投递到目标队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayedQueueConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DELAYED_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义交换机 我们在这里定义的是一个延迟交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomExchange <span class="title function_">delayedExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//自定义交换机的类型</span></span><br><span class="line">        args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>,</span><br><span class="line">                args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDelayedQueue</span><span class="params">(<span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange</span></span><br><span class="line"><span class="params">                                               delayedExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">                BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-7-4-消息生产者代码"><a href="#7-7-4-消息生产者代码" class="headerlink" title="7.7.4 消息生产者代码"></a>7.7.4 消息生产者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line"><span class="comment">// 基于插件的 开始发消息 消息 以及 延迟的时间</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> Integer delayTime)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;, 发送一条时长 &#123;&#125; 毫秒 信息给延迟队列delayed.queue ：&#123;&#125;&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), delayTime, message);</span><br><span class="line">        rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME, DelayedQueueConfig.DELAYED_ROUTING_KEY, message, msg -&gt;&#123;</span><br><span class="line">            <span class="comment">// 发送消息的时候 延长时长 单位是 ms</span></span><br><span class="line">            msg.getMessageProperties().setDelay(delayTime);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="7-7-5-消息消费者代码"><a href="#7-7-5-消息消费者代码" class="headerlink" title="7.7.5 消息消费者代码"></a>7.7.5 消息消费者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 基于的插件延迟消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 21:03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueueConsumer</span> &#123;</span><br><span class="line">    <span class="comment">// 监听消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DelayedQueueConfig.DELAYED_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDelayQueue</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;， 收到延迟队列的消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-7-6-结果展示"><a href="#7-7-6-结果展示" class="headerlink" title="7.7.6 结果展示"></a>7.7.6 结果展示</h4><p>发送请求：</p><ul><li><a href="http://localhost:8080/ttl/sendDelayMsg/come">http://localhost:8080/ttl/sendDelayMsg/come</a> on baby1&#x2F;20000</li><li><a href="http://localhost:8080/ttl/sendDelayMsg/come">http://localhost:8080/ttl/sendDelayMsg/come</a> on baby2&#x2F;2000</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302082126200.png" alt="image-20230208212615797"></p><p>第二个消息被消费掉，复合预期</p><h3 id="7-8-总结"><a href="#7-8-总结" class="headerlink" title="7.8 总结"></a>7.8 总结</h3><p>​延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正 确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。</p><p>​当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景</p><h2 id="8-发布确认高级"><a href="#8-发布确认高级" class="headerlink" title="8.发布确认高级"></a>8.发布确认高级</h2><p>​在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？ 特别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">应 用 [xxx] 在 [08-<span class="number">1516</span>:<span class="number">36</span>:<span class="number">04</span>] 发 生 [ 错误日志异常 ] ， alertId=[xxx] 。 由</span><br><span class="line">[org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:<span class="number">620</span>] 触发。 </span><br><span class="line">应用 xxx 可能原因如下</span><br><span class="line">服务名为： </span><br><span class="line">异常为： org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:<span class="number">620</span>, </span><br><span class="line">产 生 原 因 如 下 :<span class="number">1.</span>org.springframework.amqp.rabbit.listener.QueuesNotAvailableException: </span><br><span class="line">Cannot prepare queue <span class="keyword">for</span> listener. Either the queue doesn<span class="string">&#x27;t exist or the broker will not </span></span><br><span class="line"><span class="string">allow us to use it.||Consumer received fatal=false exception on startup:</span></span><br></pre></td></tr></table></figure><h3 id="8-1-发布确认-springboot-版本"><a href="#8-1-发布确认-springboot-版本" class="headerlink" title="8.1 发布确认 springboot 版本"></a>8.1 发布确认 springboot 版本</h3><h4 id="8-1-1-确认机制方案"><a href="#8-1-1-确认机制方案" class="headerlink" title="8.1.1 确认机制方案"></a>8.1.1 确认机制方案</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302082241533.png" alt="image-20230208224129404"></p><h4 id="8-1-2-代码架构图"><a href="#8-1-2-代码架构图" class="headerlink" title="8.1.2 代码架构图"></a>8.1.2 代码架构图</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302082242563.png" alt="image-20230208224247445"></p><h4 id="8-1-3-配置文件"><a href="#8-1-3-配置文件" class="headerlink" title="8.1.3 配置文件"></a>8.1.3 配置文件</h4><p>在 application.yml 配置文件中添加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br></pre></td></tr></table></figure><p>publisher-confirm-type 有三种值：</p><ul><li>NONE ：禁用发布确认模式，是默认值</li><li>CORRELATED ：发布消息成功到交换器后会触发回调方法</li><li>SIMPLE</li></ul><p>​经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法， </p><p>​其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法 等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，<strong>要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker</strong></p><h4 id="8-1-4-添加配置类"><a href="#8-1-4-添加配置类" class="headerlink" title="8.1.4 添加配置类"></a>8.1.4 添加配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 配置类 发布确认（高级）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 22:13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// routingKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;key1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBindingExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue,</span></span><br><span class="line"><span class="params">                                        <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-5-消息生产者"><a href="#8-1-5-消息生产者" class="headerlink" title="8.1.5 消息生产者"></a>8.1.5 消息生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 开始发消息 测试确认</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 22:30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;sendMessage/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">                ConfirmConfig.CONFIRM_ROUTING_KEY, message + <span class="string">&quot;key1&quot;</span>, correlationData1);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息内容：&#123;&#125;&quot;</span>, message + <span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">                ConfirmConfig.CONFIRM_ROUTING_KEY + <span class="string">&quot;2&quot;</span>, message + <span class="string">&quot;key12&quot;</span>, correlationData2);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息内容：&#123;&#125;&quot;</span>, message + <span class="string">&quot;key2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-6-回调接口"><a href="#8-1-6-回调接口" class="headerlink" title="8.1.6 回调接口"></a>8.1.6 回调接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 回调接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 22:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 注入</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机确认回调方法</span></span><br><span class="line"><span class="comment">     * 1.发消息 交换机接收到了 回调</span></span><br><span class="line"><span class="comment">     *  1.1 correlationData 保存回调消息的 ID 及相关信息</span></span><br><span class="line"><span class="comment">     *  1.2 交换机收到消息 ack = true</span></span><br><span class="line"><span class="comment">     * 2.发消息 交换机接收失败了 回调</span></span><br><span class="line"><span class="comment">     *  2.1 correlationData 保存回调消息的 ID 及相关信息</span></span><br><span class="line"><span class="comment">     *  2.2 交换机收到消息 ack = false</span></span><br><span class="line"><span class="comment">     *  2.3 cause 引起失败的原因</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机已经收到 Id 为：&#123;&#125; 的消息&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机还未收到 Id 为：&#123;&#125; 的消息，原因为：&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-7-消息消费者"><a href="#8-1-7-消息消费者" class="headerlink" title="8.1.7 消息消费者"></a>8.1.7 消息消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 接收消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 22:34</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.CONFIRM_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfirmMessage</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接受到的队列 confirm.queue 消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-8-结果分析"><a href="#8-1-8-结果分析" class="headerlink" title="8.1.8 结果分析"></a>8.1.8 结果分析</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302091338917.png" alt="image-20230209133818410"></p><p>上图结果显示，发送了两条消息，第一条消息是 routingKey 为 “key1”,第二条消息是 routingKey 为 “key2”,两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为 第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条 消息被直接丢弃了。</p><h3 id="8-2-回退消息"><a href="#8-2-回退消息" class="headerlink" title="8.2 回退消息"></a>8.2 回退消息</h3><h4 id="8-2-1-Mandatory-参数"><a href="#8-2-1-Mandatory-参数" class="headerlink" title="8.2.1 Mandatory 参数"></a>8.2.1 Mandatory 参数</h4><p>​<strong>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如 果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。</strong>那么如何 让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参 数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p><h4 id="8-2-2-application-yml-添加"><a href="#8-2-2-application-yml-添加" class="headerlink" title="8.2.2 application.yml 添加"></a>8.2.2 application.yml 添加</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="8-2-3-回调接口"><a href="#8-2-3-回调接口" class="headerlink" title="8.2.3 回调接口"></a>8.2.3 回调接口</h4><p>设置回调接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.setReturnsCallback(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure><p>重写 returnedMessage 方法，具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 回调接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 22:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback, RabbitTemplate.ReturnsCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 注入</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机确认回调方法</span></span><br><span class="line"><span class="comment">     * 1.发消息 交换机接收到了 回调</span></span><br><span class="line"><span class="comment">     *  1.1 correlationData 保存回调消息的 ID 及相关信息</span></span><br><span class="line"><span class="comment">     *  1.2 交换机收到消息 ack = true</span></span><br><span class="line"><span class="comment">     * 2.发消息 交换机接收失败了 回调</span></span><br><span class="line"><span class="comment">     *  2.1 correlationData 保存回调消息的 ID 及相关信息</span></span><br><span class="line"><span class="comment">     *  2.2 交换机收到消息 ack = false</span></span><br><span class="line"><span class="comment">     *  2.3 cause 引起失败的原因</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机已经收到 Id 为：&#123;&#125; 的消息&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机还未收到 Id 为：&#123;&#125; 的消息，原因为：&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有消息到达不了目的地的时候， 才进行回退</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;消息 &#123;&#125;， 被交换机 &#123;&#125; 退回， 退回原因：&#123;&#125;， 路由 key ：&#123;&#125;&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>(returned.getMessage().getBody()),</span><br><span class="line">                returned.getExchange(), returned.getReplyText(), returned.getRoutingKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-4-结果"><a href="#8-2-4-结果" class="headerlink" title="8.2.4 结果"></a>8.2.4 结果</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302091421109.png" alt="image-20230209142155747"></p><h3 id="8-3-备份交换机"><a href="#8-3-备份交换机" class="headerlink" title="8.3 备份交换机"></a>8.3 备份交换机</h3><p>​有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息 无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然 后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者 所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增 加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的 复杂性，该怎么做呢？前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些 处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。什么是备份交换机呢？备份 交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时， 就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由 备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑 定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都 进入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</p><h4 id="8-3-1-代码架构图"><a href="#8-3-1-代码架构图" class="headerlink" title="8.3.1 代码架构图"></a>8.3.1 代码架构图</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302091453657.png" alt="image-20230209145343572"></p><h4 id="8-3-2-修改配置类-ConfirmConfig"><a href="#8-3-2-修改配置类-ConfirmConfig" class="headerlink" title="8.3.2 修改配置类 ConfirmConfig"></a>8.3.2 修改配置类 ConfirmConfig</h4><ul><li>主要是声明和绑定备份交换机、备份队列和报警队列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 配置类 发布确认（高级）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/8 22:13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// routingKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;key1&quot;</span>;</span><br><span class="line">    <span class="comment">// 备份交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;backup_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 备份队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;backup_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 报警队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WARNING_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;warning_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)</span><br><span class="line">                .durable(<span class="literal">true</span>).withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBindingExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue,</span></span><br><span class="line"><span class="params">                                        <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备份交换机创建</span></span><br><span class="line">    <span class="meta">@Bean(&quot;backupExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">BackupExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(BACKUP_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 备份队列创建</span></span><br><span class="line">    <span class="meta">@Bean(&quot;backupQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">backupQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 报警队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;warningQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">warningQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 备份交换机绑定备份队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">backupQueueBindingBackupExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;backupQueue&quot;)</span> Queue backupQueue,</span></span><br><span class="line"><span class="params">                                        <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(backupQueue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备份交换机绑定报警队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">warningQueueBindingBackupExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue warningQueue,</span></span><br><span class="line"><span class="params">                                                    <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(warningQueue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-3-报警消费者-WarningConsumer"><a href="#8-3-3-报警消费者-WarningConsumer" class="headerlink" title="8.3.3 报警消费者 WarningConsumer"></a>8.3.3 报警消费者 WarningConsumer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 报警消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/9 14:44</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarningConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收报警消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.WARNING_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveWarningMsg</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;报警发现不可路由消息： &#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-4-测试注意事项"><a href="#8-3-4-测试注意事项" class="headerlink" title="8.3.4 测试注意事项"></a>8.3.4 测试注意事项</h4><p>重新启动项目的时候需要把原来的 confirm.exchange 删除因为我们修改了其绑定属性，不然报以下错:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inequivalent arg <span class="string">&#x27;alternate-exchange&#x27;</span><span class="keyword">for</span> exchange <span class="string">&#x27;confirm.exchange&#x27;</span>in vhost <span class="string">&#x27;/</span></span><br><span class="line"><span class="string">inequivalent arg &#x27;</span>alternate-exchange<span class="string">&#x27;for exchange &#x27;</span>confirm.exchange<span class="string">&#x27;in vhost &#x27;</span>/<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="8-3-5-结果分析"><a href="#8-3-5-结果分析" class="headerlink" title="8.3.5 结果分析"></a>8.3.5 结果分析</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302091457828.png" alt="image-20230209145728615"></p><p>​mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先 级高，经过上面结果显示答案是<strong>备份交换机优先级高。</strong></p><h2 id="9-RabbitMQ-其他知识点"><a href="#9-RabbitMQ-其他知识点" class="headerlink" title="9. RabbitMQ 其他知识点"></a>9. RabbitMQ 其他知识点</h2><h3 id="9-1-幂等性"><a href="#9-1-幂等性" class="headerlink" title="9.1 幂等性"></a>9.1 幂等性</h3><h4 id="9-1-1-概念"><a href="#9-1-1-概念" class="headerlink" title="9.1.1 概念"></a>9.1.1 概念</h4><p>​用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误 立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等</p><h4 id="9-1-2-消息重复消费"><a href="#9-1-2-消息重复消费" class="headerlink" title="9.1.2 消息重复消费"></a>9.1.2 消息重复消费</h4><p>​消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但 实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p><h4 id="9-1-3-解决思路"><a href="#9-1-3-解决思路" class="headerlink" title="9.1.3 解决思路"></a>9.1.3 解决思路</h4><p>​MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消 息时用该 id 先判断该消息是否已消费过。</p><h4 id="9-1-4-消费端的幂等性保障"><a href="#9-1-4-消费端的幂等性保障" class="headerlink" title="9.1.4 消费端的幂等性保障"></a>9.1.4 消费端的幂等性保障</h4><p>​在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。业界主流的幂等性有两种操作:a. 唯一 ID+指纹码机制,利用数据库主键去重, b.利用 redis 的原子性去实现</p><h4 id="9-1-5-唯一-ID-指纹码机制"><a href="#9-1-5-唯一-ID-指纹码机制" class="headerlink" title="9.1.5 唯一 ID + 指纹码机制"></a>9.1.5 唯一 ID + 指纹码机制</h4><p>​指纹码:我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存 在数据库中,优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数 据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</p><h4 id="9-1-6-Redis-原子性"><a href="#9-1-6-Redis-原子性" class="headerlink" title="9.1.6 Redis 原子性"></a>9.1.6 Redis 原子性</h4><p>​利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费</p><h3 id="9-2-优先队列"><a href="#9-2-优先队列" class="headerlink" title="9.2 优先队列"></a>9.2 优先队列</h3><h4 id="9-2-1-使用场景"><a href="#9-2-1-使用场景" class="headerlink" title="9.2.1 使用场景"></a>9.2.1 使用场景</h4><p>​在我们系统中有一个<strong>订单催付</strong>的场景，我们的客户在天猫下的订单,淘宝会及时将订单推送给我们，如 果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创 造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存 放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景， 所以订单量大了后采用 RabbitMQ 进行改造和优化,如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。</p><h4 id="9-2-2-如何添加优先队列"><a href="#9-2-2-如何添加优先队列" class="headerlink" title="9.2.2 如何添加优先队列"></a>9.2.2 如何添加优先队列</h4><ul><li><p>方法一：在控制台<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302091545995.png" alt="image-20230209154459351"></p></li><li><p>队列中代码添加优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 官方允许是 0-255 之间 此处允许优先级的范围设置为  0-10 设置太大会浪费 CPU 和内存</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, arguments);</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302091601764.png" alt="image-20230209160115369"></p></li><li><p>消息中代码添加优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br></pre></td></tr></table></figure></li><li><p>注意事项：<br>要让队列实现优先级需要做的事情有如下事情:<strong>队列需要设置为优先级队列，消息需要设置消息的优先 级，消费者需要等待消息已经发送到队列中才去消费，因为这样才有机会对消息进行排序</strong></p></li></ul><h4 id="9-2-3-优先队列实战"><a href="#9-2-3-优先队列实战" class="headerlink" title="9.2.3 优先队列实战"></a>9.2.3 优先队列实战</h4><ol><li><p>消息生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * <span class="meta">@Description</span>: 生产者：发送消息</span><br><span class="line"> * <span class="meta">@Author</span>: mofeng</span><br><span class="line"> * <span class="meta">@DateTime</span>: <span class="number">2023</span>/<span class="number">1</span>/<span class="number">15</span> <span class="number">12</span>:<span class="number">07</span></span><br><span class="line"> **/</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RABBITMQ_HOST</span> <span class="operator">=</span> <span class="string">&quot;43.139.46.240&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 工厂 IP 连接 RabbitMQ 的队列</span></span><br><span class="line">        connectionFactory.setHost(RABBITMQ_HOST);</span><br><span class="line">        <span class="comment">// 用户名</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 密码</span></span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">// 获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.队列里面的消息是否持久化（磁盘） 默认情况下消息存储在内存中</span></span><br><span class="line"><span class="comment">         * 3.该队列是否只供一个消费者消费，是否进行消息共享，true: 多个消费者消费 flase: 只能一个消费者消费</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除，最后一个消费者端开连接以后 该队列是否自动删除，true 自动删除 false 不自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 官方允许是 0-255 之间 此处允许优先级的范围设置为  0-10 设置太大会浪费 CPU 和内存</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, arguments);</span><br><span class="line">        <span class="comment">// 发消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME, properties, message.getBytes());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消费</span></span><br><span class="line"><span class="comment">         * 1.发送到哪个交换机</span></span><br><span class="line"><span class="comment">         * 2.路由的 key 值是哪个 本次队列的名称</span></span><br><span class="line"><span class="comment">         * 3.其他参数信息</span></span><br><span class="line"><span class="comment">         * 4.发送消息的本体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//channel.basicPublish(&quot;&quot;,QUEUE_NAME, null, message.getBytes());</span></span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消息消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消费者 接受消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/1/15 14:19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RABBITMQ_HOST</span> <span class="operator">=</span> <span class="string">&quot;43.139.46.240&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 工厂 IP 连接 RabbitMQ 的队列</span></span><br><span class="line">        connectionFactory.setHost(RABBITMQ_HOST);</span><br><span class="line">        <span class="comment">// 用户名</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 密码</span></span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">// 获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消消息时的回调</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断！！&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费者消费</span></span><br><span class="line"><span class="comment">         * 1.消费哪个队列</span></span><br><span class="line"><span class="comment">         * 2.消费成功后是否需要自动应答 true 代表自动应答 false 代表手动应答</span></span><br><span class="line"><span class="comment">         * 3.消费者未成功消费的回调</span></span><br><span class="line"><span class="comment">         * 4.消费者取录消费的回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>运行结果<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302091600334.png" alt="image-20230209160006737"></p><h3 id="9-3-惰性队列"><a href="#9-3-惰性队列" class="headerlink" title="9.3 惰性队列"></a>9.3 惰性队列</h3><h4 id="9-3-1-使用场景"><a href="#9-3-1-使用场景" class="headerlink" title="9.3.1 使用场景"></a>9.3.1 使用场景</h4><p>​RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致 使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p><p>​默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中， 这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留 一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候</p><h4 id="9-3-2-两种模式"><a href="#9-3-2-两种模式" class="headerlink" title="9.3.2 两种模式"></a>9.3.2 两种模式</h4><p>​队列具备两种模式：<strong>default 和 lazy。</strong><br>​默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。 如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p><p>在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示 例中演示了一个惰性队列的声明细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br></pre></td></tr></table></figure><h4 id="9-3-3-内存开销对比"><a href="#9-3-3-内存开销对比" class="headerlink" title="9.3.3 内存开销对比"></a>9.3.3 内存开销对比</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202302091611857.png" alt="image-20230209161131829"></p><p>​在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅 占用 1.5MB</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RabbitMQ&quot;&gt;&lt;a href=&quot;#RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ&quot;&gt;&lt;/a&gt;RabbitMQ&lt;/h1&gt;&lt;h2 id=&quot;1-MQ的相关概念&quot;&gt;&lt;a href=&quot;#1-MQ的相关概念&quot; class=&quot;he</summary>
      
    
    
    
    <category term="消息中间件" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="RabbitMQ" scheme="http://example.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>七、API 接口分析功能</title>
    <link href="http://example.com/2023/01/12/%E4%B8%83%E3%80%81API-%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90%E5%8A%9F%E8%83%BD/"/>
    <id>http://example.com/2023/01/12/%E4%B8%83%E3%80%81API-%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90%E5%8A%9F%E8%83%BD/</id>
    <published>2023-01-12T14:26:36.622Z</published>
    <updated>2023-01-12T14:24:11.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七、API-接口分析功能"><a href="#七、API-接口分析功能" class="headerlink" title="七、API 接口分析功能"></a>七、API 接口分析功能</h1><p>主要内容：</p><ol><li>开发抽象公共服务</li><li>实现网关核心业务流程</li><li>开发管理员接口分析功能</li><li>上线分析和发展</li></ol><h2 id="梳理网关业务流程"><a href="#梳理网关业务流程" class="headerlink" title="梳理网关业务流程"></a>梳理网关业务流程</h2><p>一下操作可以复用：</p><ol><li>实际情况应该是去数据库中查询是否已分配给用户秘钥（accessKey, secretKey 是否合法）<ol><li>先根据 accessKey 判断用户是否存在，查到 secretKey</li><li>对比 secretKey 和用户传的加密后的 secretKey 是否一致</li></ol></li><li>从数据库中查询模拟接口是否存在，以及请求方法是否匹配（还可以校验参数）</li><li>调用成功，接口调用次数 + 1 invokeCount</li></ol><h2 id="临时问题：如何获取接口转发服务器的地址"><a href="#临时问题：如何获取接口转发服务器的地址" class="headerlink" title="临时问题：如何获取接口转发服务器的地址"></a>临时问题：如何获取接口转发服务器的地址</h2><p>思路：网关启动时，获取所有的接口信息，维护到内存的 hashmap 中；有请求时，根据请求的 URL 路径或其他参数（比如 host 请求头） 来判断应该转发到哪台服务器、以及用户校验接口是否存在</p><h2 id="抽象公共服务"><a href="#抽象公共服务" class="headerlink" title="抽象公共服务"></a>抽象公共服务</h2><p>项目名：mofeng-common</p><p>目的是让方法、实体类在多个项目之间复用，提高代码复用率。</p><p>服务抽取：</p><ol><li>数据库中查询是否已分配给用户秘钥（根据 accessKey, 拿到用户信息，返回用户信息，为空表示不存在）</li><li>从数据库中查询模拟接口是否存在（请求方法、请求路径、请求参数、返回接口信息，为空表示不存在）</li><li>调用成功，接口调用次数 + 1 invokeCount （accessKey、secretKey （标识用户），请求接口路径）</li></ol><p>步骤：</p><ol><li>新建干净的 maven 项目，只保留必要的公共依赖</li><li>抽取 service 和实体类</li><li>install 本地 maven 包</li><li>让服务提供者引入 common 包，测试是否正常运行</li><li>让服务消费者引入 common 包</li></ol><h2 id="统计分析功能"><a href="#统计分析功能" class="headerlink" title="统计分析功能"></a>统计分析功能</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>各接口的总调用次数占比（饼图）取调用最多的前 3 个接口，从而分析哪些属于废弃接口（降低资源、或者下线），高频接口（增加资源、提高收费）</p><p>用饼图展示</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>可以使用现成的库</p><p>比如：</p><ul><li>ECharts:<a href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a>    (推荐)</li><li>AntV:<a href="https://antv.vision/">https://antv.vision/</a>     （推荐）</li><li>BizCharts</li></ul><p>如果是 React 项目，ECharts 用这个库：<a href="https://github.com/hustcc/echarts-for-react">https://github.com/hustcc/echarts-for-react</a></p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>编写一个接口，得到下列示例数据：</p><p>接口 A：2 次（调用）</p><p>接口 B：4 次（调用）</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202301122208482.png" alt="image-20230112220759966"></p><p>步骤：</p><ol><li><p>SQL 查询调用数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> interfaceInfoId,<span class="built_in">sum</span>(totalNum) <span class="keyword">as</span> totalNum</span><br><span class="line"><span class="keyword">from</span> user_interface_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> interfaceInfoId</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> totalNum <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>业务层去关联查询接口信息</p></li></ol><h2 id="上线计划"><a href="#上线计划" class="headerlink" title="上线计划"></a>上线计划</h2><p>前端：直接打包部署即可</p><p>后端：</p><ul><li>backend 项目：web 项目，部署 spring boot 的 jar 包（对外）</li><li>gateway 项目：web 项目，部署 spring boot 的 jar 包（对外）</li><li>interface 项目：web 项目，部署 spring boot 的 jar 包（对内）</li></ul><p><strong>关键：网络必须联通</strong></p><p>项目由自己学习使用：单个服务器部署这三个项目就足够了</p><p>安全可靠：多个服务器建议在 <strong>同一内网</strong>，内网交互会更快、且更安全</p><h2 id="扩展思路"><a href="#扩展思路" class="headerlink" title="扩展思路"></a>扩展思路</h2><h3 id="1-用户可以申请更换签名"><a href="#1-用户可以申请更换签名" class="headerlink" title="1.用户可以申请更换签名"></a>1.用户可以申请更换签名</h3><h3 id="2-怎么让其他用户也上传接口？"><a href="#2-怎么让其他用户也上传接口？" class="headerlink" title="2.怎么让其他用户也上传接口？"></a>2.怎么让其他用户也上传接口？</h3><ul><li><p>需要提供一个机制（界面），让用户输入自己的接口 host （服务器地址）、接口信息，将接口信息写入数据库，可以在 interfaceInfo 表里添加一个 host 字段，区分服务器地址，让接口提供者更地接入系统</p></li><li><p>将接口信息写入数据库之前，要对接口进行校验（比如检查地址是否遵循规则，测试调用），保证接口使用正常</p></li><li><p>将接口信息写入数据库之前遵循本系统的要求（并且使用本系统的 SDK）</p></li><li><p>在接入时，平台需要测试调用这个接口，保证接口可以正常使用</p></li></ul><h3 id="3-网关校验是否还有调用次数"><a href="#3-网关校验是否还有调用次数" class="headerlink" title="3.网关校验是否还有调用次数"></a>3.网关校验是否还有调用次数</h3><p>需要考虑并发问题，防止瞬间调用超额</p><h3 id="4-网关优化"><a href="#4-网关优化" class="headerlink" title="4.网关优化"></a>4.网关优化</h3><p>比如增加限流 &#x2F; 降级保护，提高性能等。还可以考虑搭配 Nginx 网关使用</p><h3 id="5-更能增强"><a href="#5-更能增强" class="headerlink" title="5.更能增强"></a>5.更能增强</h3><p>可以针对不同的请求头或者接口类型来设计前端界面和表单，便于用户调用，获得更好的体验。</p><p>可以参考 swagger、postman、knife4j 的页面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;七、API-接口分析功能&quot;&gt;&lt;a href=&quot;#七、API-接口分析功能&quot; class=&quot;headerlink&quot; title=&quot;七、API 接口分析功能&quot;&gt;&lt;/a&gt;七、API 接口分析功能&lt;/h1&gt;&lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发抽象公共服务&lt;/l</summary>
      
    
    
    
    <category term="API 开放平台" scheme="http://example.com/categories/API-%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/"/>
    
    
    <category term="星球项目" scheme="http://example.com/tags/%E6%98%9F%E7%90%83%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>六、Dubbo 框架</title>
    <link href="http://example.com/2023/01/03/%E5%85%AD%E3%80%81Dubbo-%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2023/01/03/%E5%85%AD%E3%80%81Dubbo-%E6%A1%86%E6%9E%B6/</id>
    <published>2023-01-03T07:11:51.910Z</published>
    <updated>2023-01-03T07:14:52.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="六、Dubbo-框架"><a href="#六、Dubbo-框架" class="headerlink" title="六、Dubbo 框架"></a>六、Dubbo 框架</h1><h2 id="网关业务逻辑"><a href="#网关业务逻辑" class="headerlink" title="网关业务逻辑"></a>网关业务逻辑</h2><p>问题：网关项目比较纯净，没有操作数据库的包、并且还要调用我们之前写过的代码？复制粘贴维护麻烦</p><p>解决：直接请求到其他项目的方法</p><h3 id="如何调用其他项目的方法"><a href="#如何调用其他项目的方法" class="headerlink" title="如何调用其他项目的方法"></a>如何调用其他项目的方法</h3><ol><li>复制代码、依赖和环境</li><li>HTTP 请求（提供一个接口，供其他项目使用）</li><li>RPC</li><li>把公共的代码打包 JAR 包，其他项目引用（客户端 SDK）</li></ol><h3 id="HTTP-请求如何调用？"><a href="#HTTP-请求如何调用？" class="headerlink" title="HTTP 请求如何调用？"></a>HTTP 请求如何调用？</h3><ol><li>提供开发一个接口（地址、请求方法、参数、返回值）</li><li>调用方使用 HTTP Client 之类的代码包去发送 HTTP 请求</li></ol><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p><strong>作用：像本地方法一样调用远程方法</strong></p><ol><li>对开发者更透明，减少了很多的沟通 成本</li><li>RPC 想远程服务器发送请求时，未必要使用 HTTP 请求，比如还可以用 TCP&#x2F;IP，性能更高（内部服务更适用）</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202212272020718.png" alt="image-20221227202039865"></p><h3 id="Dubbo-框架（RPC-实现）"><a href="#Dubbo-框架（RPC-实现）" class="headerlink" title="Dubbo 框架（RPC 实现）"></a>Dubbo 框架（RPC 实现）</h3><p>GRPC、TRPC</p><p>阅读官方文档：<a href="https://cn.dubbo.apache.org/zh/docs3-v2/java-sdk/quick-start/spring-boot/">https://cn.dubbo.apache.org/zh/docs3-v2/java-sdk/quick-start/spring-boot/</a></p><p>两种使用方式：</p><ol><li>Spring Boot 代码（注解 + 编程式）：写 Java 接口，服务提供者和消费者都去引用这个接口</li><li>IDL（接口调用语言）：创建一个公共的接口定义文件，服务提供者和消费者都去读取这个文件。优点是跨语言，所有的框架都熟悉。</li></ol><p>底层是 Triple 协议：<a href="https://cn.dubbo.apache.org/zh/docs3-v2/java-sdk/concepts-and-architecture/triple/">https://cn.dubbo.apache.org/zh/docs3-v2/java-sdk/concepts-and-architecture/triple/</a></p><h4 id="示例学习"><a href="#示例学习" class="headerlink" title="示例学习"></a>示例学习</h4><p>zookeeper 注册中心：通过内嵌的方式运行，更方便</p><p>最先启动注册中心，先启动服务提供者，在启动服务消费者</p><h3 id="整合运用"><a href="#整合运用" class="headerlink" title="整合运用"></a>整合运用</h3><ol><li>backend 项目作为服务提供者，提供 3 个方法：<ol><li>实际情况应该是去数据库中查是否已分配给用户</li><li>从数据库中查询模拟接口是否存在，以及请求方法是否匹配（还可以校验请求参数）</li><li>调用成功，接口调用次数 + 1 invokeCount</li></ol></li><li>gateway 项目作为服务调用者，调用这 3 个方法</li></ol><p>整合 Nacos 注册中心：<a href="https://cn.dubbo.apache.org/zh/docs3-v2/java-sdk/reference-manual/registry/nacos/">https://cn.dubbo.apache.org/zh/docs3-v2/java-sdk/reference-manual/registry/nacos/</a></p><p>注意：</p><ol><li>服务调用类必须在同一包下，建议是抽象出一个公共项目（放接口、实体类等）</li><li>设置注解（比如启动类的 EnableDubbo、接口实现类和 Bean 引用的注解）</li><li>添加配置</li><li>服务调用项目和提供者项目尽量引入相同的依赖和配置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.apache.dubbo/dubbo --&gt;</span></span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;<span class="number">3.1</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;<span class="number">2.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;六、Dubbo-框架&quot;&gt;&lt;a href=&quot;#六、Dubbo-框架&quot; class=&quot;headerlink&quot; title=&quot;六、Dubbo 框架&quot;&gt;&lt;/a&gt;六、Dubbo 框架&lt;/h1&gt;&lt;h2 id=&quot;网关业务逻辑&quot;&gt;&lt;a href=&quot;#网关业务逻辑&quot; class=&quot;</summary>
      
    
    
    
    <category term="API 开放平台" scheme="http://example.com/categories/API-%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/"/>
    
    
    <category term="星球项目" scheme="http://example.com/tags/%E6%98%9F%E7%90%83%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>三、API 开放平台-接口发布</title>
    <link href="http://example.com/2022/12/22/%E4%B8%89%E3%80%81API%20%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E6%8E%A5%E5%8F%A3%E5%8F%91%E5%B8%83/"/>
    <id>http://example.com/2022/12/22/%E4%B8%89%E3%80%81API%20%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E6%8E%A5%E5%8F%A3%E5%8F%91%E5%B8%83/</id>
    <published>2022-12-22T04:05:34.057Z</published>
    <updated>2022-12-22T04:17:19.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三、接口发布-下线-调用"><a href="#三、接口发布-下线-调用" class="headerlink" title="三、接口发布-下线-调用"></a>三、接口发布-下线-调用</h1><ol><li>开发接口发布、下线的功能（管理员）</li><li>前端去浏览接口、查看接口文档、申请签名（注册）</li><li>在线调试（用户）</li><li>统计用户调用接口的次数</li><li>优化系统 - API 网关</li></ol><h2 id="开发接口发布-x2F-下线功能"><a href="#开发接口发布-x2F-下线功能" class="headerlink" title="开发接口发布&#x2F;下线功能"></a>开发接口发布&#x2F;下线功能</h2><p>后台接口：</p><p>发布接口（仅管理员可操作）</p><ol><li>校验该接口是否存在</li><li>判断该接口是否可以调用</li><li>修改接口数据库中的状态字段为 1</li></ol><p>下线接口（仅管理员可操作）</p><ol><li>校验接口是否存在</li><li>修改接口数据库中的状态字段为 0</li></ol><h2 id="查看接口文档"><a href="#查看接口文档" class="headerlink" title="查看接口文档"></a>查看接口文档</h2><p>动态路由，用 url 来传递 id, 加载不同的接口信息</p><h2 id="申请签名"><a href="#申请签名" class="headerlink" title="申请签名"></a>申请签名</h2><p>用户在注册成功时，自动分配 accessKey、secretKey </p><p>扩展点：用户可以申请更换签名</p><h2 id="在线调用"><a href="#在线调用" class="headerlink" title="在线调用"></a>在线调用</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;username&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;string&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>先跑通整个接口流程，再去针对不同的请求头或者接口类型来设计界面和表单，给用户更好的体验。（可以参考 swagger、postman、knife4j)</p><h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202212041910410.png" alt="image-20221204191022426"></p><p>流程：</p><ol><li>前端将用户输入的请求参数和要测试的接口 id 发给平台后端</li><li>在调用前可以做一些校验</li><li>平台后端去调用模拟接口</li></ol><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li>判断该接口是否可以调用时有固定方法名改为根据测试地址来调用</li><li>用户测试接口固定方法名改为根据测试地址来调用</li><li>模拟接口改为从数据库校验 accessKey</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三、接口发布-下线-调用&quot;&gt;&lt;a href=&quot;#三、接口发布-下线-调用&quot; class=&quot;headerlink&quot; title=&quot;三、接口发布-下线-调用&quot;&gt;&lt;/a&gt;三、接口发布-下线-调用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;开发接口发布、下线的功能（管理员）&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="API 开放平台" scheme="http://example.com/categories/API-%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/"/>
    
    
    <category term="星球项目" scheme="http://example.com/tags/%E6%98%9F%E7%90%83%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>API 开放平台设计</title>
    <link href="http://example.com/2022/12/22/%E4%B8%80%E3%80%81API%20%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2022/12/22/%E4%B8%80%E3%80%81API%20%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-12-22T04:04:12.627Z</published>
    <updated>2022-12-22T03:54:19.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API-开放平台"><a href="#API-开放平台" class="headerlink" title="API 开放平台"></a>API 开放平台</h1><h2 id="第一期"><a href="#第一期" class="headerlink" title="第一期"></a>第一期</h2><p>项目背景：</p><ol><li>前端开发需要用到后端接口</li><li>使用现成的系统的功能（<a href="http://api.btstu.cn/%EF%BC%89">http://api.btstu.cn/）</a></li></ol><p>API 接口平台：</p><ol><li>防止攻击（安全性）</li><li>不能随便调用（限制、开通）</li><li><strong>统计调用次数</strong></li><li>计费</li><li>流量保护</li><li>API 接口</li></ol><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>做一个提供 API 接口调用的平台，用户可以注册登录，开通接口调用权限，用户可以使用接口，并且每次调用会进行统计。管理员可以发布接口、下线接口、接入接口，以及可视化接口的调用情况、数据。</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li>Ant Design Pro</li><li>React</li><li>Ant Design Procompoments</li><li>Umi</li><li>Umi Request (Axios 的封装)</li></ul><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul><li>Java Spring Boot</li><li>Sring Boot Starter （SDK 开发）</li></ul><h2 id="项目计划"><a href="#项目计划" class="headerlink" title="项目计划"></a>项目计划</h2><h3 id="第一期-—-初始化展示"><a href="#第一期-—-初始化展示" class="headerlink" title="第一期 —- 初始化展示"></a>第一期 —- 初始化展示</h3><p>项目介绍、设计、技术选型</p><p>基础项目搭建</p><p>接口管理</p><p>用户查看接口</p><h3 id="第二期-—-接口调用"><a href="#第二期-—-接口调用" class="headerlink" title="第二期 —- 接口调用"></a>第二期 —- 接口调用</h3><ol><li>继续开发接口管理前端页面</li><li>开发调用这个接口的代码</li><li>保证调用的安全性<strong>（API 签名认证）</strong></li><li>客户端 SDK  的开发</li><li>管理员接口 <strong>发布</strong> 与调用</li><li>接口文档展示、接口在线调用</li></ol><h3 id="第三期-—–-接口计费与保护"><a href="#第三期-—–-接口计费与保护" class="headerlink" title="第三期 —– 接口计费与保护"></a>第三期 —– 接口计费与保护</h3><p>统计用户调用接口次数</p><p>限流</p><p>计费</p><p>日志</p><p>开通</p><h3 id="第四期-—-管理、统计分析"><a href="#第四期-—-管理、统计分析" class="headerlink" title="第四期 —- 管理、统计分析"></a>第四期 —- 管理、统计分析</h3><p>提供可视化平台，用图表的方展示所有接口的调用情况，便于调整业务</p><p><strong>实现预警</strong></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li>管理员可以对接口信息进行增删改查</li><li>用户可以访问前台，查看接口信息</li></ol><h2 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h2><h3 id="接口信息表"><a href="#接口信息表" class="headerlink" title="接口信息表"></a>接口信息表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 接口信息表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> mofeng.`interface_info`</span><br><span class="line">(</span><br><span class="line">    `id` <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;主键&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">    `description` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">null</span> comment <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">    `url` <span class="type">varchar</span>(<span class="number">512</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;接口地址&#x27;</span>,</span><br><span class="line">    `requestHeader` text <span class="keyword">null</span> comment <span class="string">&#x27;请求头&#x27;</span>,</span><br><span class="line">    `responseHeader` text <span class="keyword">null</span> comment <span class="string">&#x27;响应头&#x27;</span>,</span><br><span class="line">    `userId` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">    `status` <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;接口状态（0 - 关闭， 1 - 开启））&#x27;</span>,</span><br><span class="line">    `<span class="keyword">method</span>` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;请求类型&#x27;</span>,</span><br><span class="line">    `createTime` datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    `updateTime` datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    `isDelete` tinyint <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;是否删除(0-未删, 1-已删)&#x27;</span></span><br><span class="line">    ) comment <span class="string">&#x27;接口信息表&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="项目脚手架"><a href="#项目脚手架" class="headerlink" title="项目脚手架"></a>项目脚手架</h2><p>前端：Ant Design Pro 脚手架</p><p>后端：Spring Boot 通用模板</p><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><p>增删改查、登录（复制、粘贴）</p><p>前端接口调用：oneapi 插件自动生成</p><p>openapi  的规范</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;API-开放平台&quot;&gt;&lt;a href=&quot;#API-开放平台&quot; class=&quot;headerlink&quot; title=&quot;API 开放平台&quot;&gt;&lt;/a&gt;API 开放平台&lt;/h1&gt;&lt;h2 id=&quot;第一期&quot;&gt;&lt;a href=&quot;#第一期&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="API 开放平台" scheme="http://example.com/categories/API-%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/"/>
    
    
    <category term="星球项目" scheme="http://example.com/tags/%E6%98%9F%E7%90%83%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>API 开放平台四-网关</title>
    <link href="http://example.com/2022/12/22/%E5%9B%9B%E3%80%81API-%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E7%BD%91%E5%85%B3/"/>
    <id>http://example.com/2022/12/22/%E5%9B%9B%E3%80%81API-%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E7%BD%91%E5%85%B3/</id>
    <published>2022-12-22T04:04:12.625Z</published>
    <updated>2022-12-22T03:59:14.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四、网关"><a href="#四、网关" class="headerlink" title="四、网关"></a>四、网关</h1><ol><li>开发接口调用次数的设计</li><li>优化整个系统的架构（API 网关）<ol><li>网关是什么？</li><li>网关的作用</li><li>网关的应用场景及实现</li><li>结合业务应用网关</li></ol></li></ol><h2 id="接口调用次数统计"><a href="#接口调用次数统计" class="headerlink" title="接口调用次数统计"></a>接口调用次数统计</h2><p>需求：</p><ol><li><strong>用户每次调用接口成功，次数 + 1</strong></li><li>给用户分配或者用户自主申请接口调用次数</li></ol><p>业务流程：</p><ol><li>用户调用接口</li><li>修改数据库，调用次数 + 1</li></ol><p>设计库表：</p><p>哪个用户？哪个接口？</p><p>用户 &#x3D;&gt; 接口 （多对多关系）</p><p>用户调用接口关系表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用户调用接口关系表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> user_interface_info</span><br><span class="line">(</span><br><span class="line">    id            <span class="type">bigint</span> auto_increment comment <span class="string">&#x27;id&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">    userId        <span class="type">bigint</span>  comment <span class="string">&#x27;调用用户 id&#x27;</span>,</span><br><span class="line">    interfaceInfoId        <span class="type">bigint</span>  comment <span class="string">&#x27;接口 id&#x27;</span>,</span><br><span class="line">    totalNum       <span class="type">int</span>     <span class="keyword">default</span> <span class="number">0</span> comment <span class="string">&#x27;总调用次数&#x27;</span>,</span><br><span class="line">    leftNum       <span class="type">int</span>     <span class="keyword">default</span> <span class="number">0</span> comment <span class="string">&#x27;剩余调用次数&#x27;</span>,</span><br><span class="line">    status       <span class="type">int</span>     <span class="keyword">default</span> <span class="number">0</span> comment <span class="string">&#x27;0-正常， 1-禁用&#x27;</span>,</span><br><span class="line">    createTime    datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    updateTime    datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    isDelete      tinyint  <span class="keyword">default</span> <span class="number">0</span>                 <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;是否删除&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;用户调用接口关系表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li>开发基本的增删改查（给管理员用）</li><li>开发用户调用接口次数 + 1 的功能（service）</li></ol><p>问题：</p><p>如果每个接口的方法都写调用次数 + 1， 过于麻烦</p><p>致命问题：接口开发者需要自己去添加统计代码</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221204192719518.png" alt="image-20221204192719518"></p><p>使用 AOP 切面的优点：独立于接口，在每个接口调用后次数 + 1</p><p>AOP 切面的缺点：只存在单个项目中，如果每个团队都要开发自己的模拟接口，那么都要写一个切面</p><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><h3 id="网关的作用"><a href="#网关的作用" class="headerlink" title="网关的作用"></a>网关的作用</h3><ol><li>路由</li><li>负载均衡</li><li>统一鉴权</li><li>跨域</li><li>统一业务处理（缓存）</li><li>访问控制</li><li>发布控制</li><li>流量染色</li><li>接口保护<ol><li>限制请求</li><li>信息脱敏</li><li>降级（熔断）</li><li>限流：学习令牌桶算法、学习漏桶算法，学习一下 RedisLimitHandler</li><li>超时时间</li></ol></li><li>统一日志</li><li>统一文档</li></ol><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>起到转发的作用，比如有接口 A 和接口 B， 网关会记录这些信息，根据用户访问的地址和参数，转发请求到对应的接口（服务器&#x2F;集群）</p><p>&#x2F;a &#x3D;&gt; 接口 A</p><p>&#x2F;b &#x3D;&gt; 接口 B</p><p>Gateway 路由：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories</a></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>在路由的基础上</p><p>&#x2F;c &#x3D;&gt; 服务 A &#x2F; 集群 A （随机转发到其中的某一个机器）</p><p>uri 从固定地址改成 lb:xxxx</p><h3 id="统一处理跨域"><a href="#统一处理跨域" class="headerlink" title="统一处理跨域"></a>统一处理跨域</h3><p>网关统一处理跨域，不用在每个项目里单独处理</p><p>GateWay 处理跨域：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#cors-configuration">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#cors-configuration</a></p><h3 id="发布控制"><a href="#发布控制" class="headerlink" title="发布控制"></a>发布控制</h3><p>灰度发布，比如上线新接口，先给新接口分配 20% 的流量，老接口 80%， 再慢慢调整比例</p><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-weight-route-predicate-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-weight-route-predicate-factory</a></p><h3 id="流量染色"><a href="#流量染色" class="headerlink" title="流量染色"></a>流量染色</h3><p>给请求（流量）添加一些标识，一般是设置请求头中，添加新的请求头</p><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-addrequestheader-gatewayfilter-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-addrequestheader-gatewayfilter-factory</a></p><p>全局染色：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#default-filters">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#default-filters</a></p><h3 id="统一接口保护"><a href="#统一接口保护" class="headerlink" title="统一接口保护"></a>统一接口保护</h3><ol><li>限制请求：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#requestheadersize-gatewayfilter-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#requestheadersize-gatewayfilter-factory</a></li><li>信息脱敏：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-removerequestheader-gatewayfilter-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-removerequestheader-gatewayfilter-factory</a></li><li>降级（熔断）：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#fallback-headers">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#fallback-headers</a></li><li>限流：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-requestratelimiter-gatewayfilter-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-requestratelimiter-gatewayfilter-factory</a></li><li>超时时间：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#http-timeouts-configuration">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#http-timeouts-configuration</a></li><li>重试（业务保护）：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-retry-gatewayfilter-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-retry-gatewayfilter-factory</a></li></ol><h3 id="统一业务处理"><a href="#统一业务处理" class="headerlink" title="统一业务处理"></a>统一业务处理</h3><p>把每个项目中都要做的通用逻辑放到上层（网关），统一处理，比如本项目的次数统计</p><h3 id="统一鉴权"><a href="#统一鉴权" class="headerlink" title="统一鉴权"></a>统一鉴权</h3><p>判断用户是否有权限进行操作，无论访问什么接口，都统一验证权限，避免重复写验证权限操作。</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>黑白名单，比如限制 DDOS IP</p><h3 id="统一日志"><a href="#统一日志" class="headerlink" title="统一日志"></a>统一日志</h3><p>统一的请求、响应信息记录</p><h3 id="统一文档"><a href="#统一文档" class="headerlink" title="统一文档"></a>统一文档</h3><p>将下游项目的文档进行聚合，在一个页面统一查看</p><p>可以使用 knife4j : <a href="https://doc.xiaominfo.com/docs/middleware-sources/aggregation-introduction">https://doc.xiaominfo.com/docs/middleware-sources/aggregation-introduction</a></p><h2 id="网关的分类"><a href="#网关的分类" class="headerlink" title="网关的分类"></a>网关的分类</h2><ol><li>全局网关（接入层网关）： 作用是负载均衡、请求日志等，不和业务逻辑绑定</li><li>业务网关（微服务网关）： 存在一些业务逻辑，作用是将请求转发到不同的业务&#x2F;项目&#x2F;接口&#x2F;服务</li></ol><p>参考文章：<a href="https://blog.csdn.net/qq_21040559/article/details/122961395">https://blog.csdn.net/qq_21040559/article/details/122961395</a></p><h2 id="实现网关"><a href="#实现网关" class="headerlink" title="实现网关"></a>实现网关</h2><ol><li>Nginx （全局网关）、Kong 网关 （API 网关， Kong: <a href="https://github.com/Kong/kong">https://github.com/Kong/kong</a>), 编程成本相对高点</li><li>Spring Cloud GateWay (取代了 Zuul ) , 性能高、可以用 Java 代码来写逻辑，适合学习</li></ol><p>网关的技术选型：<a href="https://zhuanlan.zhihu.com/p/500587132">https://zhuanlan.zhihu.com/p/500587132</a></p><h2 id="Spring-Cloud-GateWay-用法"><a href="#Spring-Cloud-GateWay-用法" class="headerlink" title="Spring Cloud GateWay 用法"></a>Spring Cloud GateWay 用法</h2><p>官网：<a href="https://spring.io/projects/spring-cloud-gateway/">https://spring.io/projects/spring-cloud-gateway/</a></p><p>官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/</a></p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>路由（根据什么条件，转发到哪里去）</p><p>断言：一组规则、条件， 用来确定如何转发路由</p><p>过滤器： 对请求进行一系列的处理， 比如添加请求头、添加请求参数</p><p>请求流程：</p><ol><li>客户端发起请求</li><li>Handler Mapping: 根据断言，将请求转发到对应的路由</li><li>Web Handler： 处理请求（一层层经过过滤器）</li><li>实际调用服务</li></ol><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221204202459676.png" alt="image-20221204202459676"></p><h3 id="两种配置方式"><a href="#两种配置方式" class="headerlink" title="两种配置方式"></a>两种配置方式</h3><ol><li>配置式（方便、规范）<ol><li>简化版</li><li>全称版</li></ol></li><li>编程式（灵活、相对麻烦）</li></ol><h3 id="开启日志"><a href="#开启日志" class="headerlink" title="开启日志"></a>开启日志</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org:</span></span><br><span class="line">      <span class="attr">springframework:</span></span><br><span class="line">        <span class="attr">cloud:</span></span><br><span class="line">          <span class="attr">gateway:</span> <span class="string">trace</span></span><br></pre></td></tr></table></figure><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><ol><li>After 在 xx 时间之后</li><li>Before 在 xx 时间之前</li><li>Between 在 xx 时间之间</li><li>请求类别</li><li>请求头（包含 cookie）</li><li>查询参数</li><li>客户端地址</li><li><strong>权重</strong></li></ol><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>基本功能：对请求头、请求参数、响应头的增删改查</p><ol><li>添加请求头</li><li>添加请求参数</li><li>添加响应头</li><li>降级</li><li>限流</li><li>重试</li></ol><p>引入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-circuitbreaker-reactor-resilience4j&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四、网关&quot;&gt;&lt;a href=&quot;#四、网关&quot; class=&quot;headerlink&quot; title=&quot;四、网关&quot;&gt;&lt;/a&gt;四、网关&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;开发接口调用次数的设计&lt;/li&gt;
&lt;li&gt;优化整个系统的架构（API 网关）&lt;ol&gt;
&lt;li&gt;网关是什么？&lt;/l</summary>
      
    
    
    
    <category term="API 开放平台" scheme="http://example.com/categories/API-%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/"/>
    
    
    <category term="星球项目" scheme="http://example.com/tags/%E6%98%9F%E7%90%83%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>二、API 开放平台-模拟接口</title>
    <link href="http://example.com/2022/12/22/%E4%BA%8C%E3%80%81API%20%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E6%A8%A1%E6%8B%9F%E6%8E%A5%E5%8F%A3/"/>
    <id>http://example.com/2022/12/22/%E4%BA%8C%E3%80%81API%20%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E6%A8%A1%E6%8B%9F%E6%8E%A5%E5%8F%A3/</id>
    <published>2022-12-22T04:04:12.619Z</published>
    <updated>2022-12-22T04:01:48.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二、API-开放平台-模拟接口"><a href="#二、API-开放平台-模拟接口" class="headerlink" title="二、API 开放平台-模拟接口"></a>二、API 开放平台-模拟接口</h1><h2 id="模拟接口项目-mofeng-interface"><a href="#模拟接口项目-mofeng-interface" class="headerlink" title="模拟接口项目 mofeng-interface"></a>模拟接口项目 mofeng-interface</h2><p>提供三个模拟接口</p><ol><li>GET 接口</li><li>POST 接口（URL 传参）</li><li>POST 接口 （Restful)</li></ol><h3 id="调用接口"><a href="#调用接口" class="headerlink" title="调用接口"></a>调用接口</h3><p>几种 HTTP 调用方式：</p><ol><li>HttpClient</li><li>RestTemplate</li><li>第三方库（OKHTTP、Hutool)</li></ol><p>Hutool:<a href="https://hutool.cn/docs/#/">https://hutool.cn/docs/#/</a></p><p>Http 工具类：<a href="https://hutool.cn/docs/#/http/Http%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E5%85%B7%E7%B1%BB-HttpUtil">https://hutool.cn/docs/#/http/Http%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E5%85%B7%E7%B1%BB-HttpUtil</a></p><h3 id="API-签名认证"><a href="#API-签名认证" class="headerlink" title="API 签名认证"></a>API 签名认证</h3><p>本质：</p><ol><li>签名签发</li><li>使用签名（校验签名）</li></ol><p>为什么需要签名认证？</p><p>保证安全性，防止恶意调用</p><h3 id="如何实现-API-签名认证呢？"><a href="#如何实现-API-签名认证呢？" class="headerlink" title="如何实现 API 签名认证呢？"></a>如何实现 API 签名认证呢？</h3><p>通过 http request header 头传递参数</p><ul><li><p>参数1： accessKey 调用的标识 userA, userB (复杂、无序、无规律)</p></li><li><p>参数2： secretKey 密钥 （复杂、无序、无规律），<strong>该参数不能放在请求头中</strong></p><p>类似于用户名和密码，区别：accessKey、 secretKey 是无状态的</p><p>密钥一般不用在服务器之间的传递，因为在传递过程中可能被拦截</p></li><li><p>参数3： 用户请求参数</p></li><li><p>参数4： sign</p></li><li><p>参数5：加 none 随机数， 只能用一次（服务端要保存用过的随机数）</p></li><li><p>参数6： 加 timestamp 时间戳， 校验时间戳是否过期</p></li></ul><p>加密方式：对称加密、非对称加密、md5 签名（不可解密）</p><p>用户参数 + 密钥 &#x3D;&gt; <strong>签名生成算法(MD5、Hmac、Sha1)</strong> &#x3D;&gt; 不可解密的值</p><p>如：abc + abcdefgh &#x3D;&gt; sfasfafffsfsa</p><p>如何验证签名？</p><p><strong>服务端用一模一样的参数和算法去生成签名，只要和用户传的一致，就表示一致。</strong></p><p>如果防止重放？</p><p><strong>服务端要保存用过的随机数</strong></p><p><strong>API 签名认证是一个很灵活的设计，具体要有哪个参数、参数名如何需要根据场景来设计。比如： userId、 appId、version、固定值等</strong></p><h2 id="开发一个简单易用的-SDK"><a href="#开发一个简单易用的-SDK" class="headerlink" title="开发一个简单易用的 SDK"></a>开发一个简单易用的 SDK</h2><p>理想状态下：开发者只需要关心调用哪些接口、传递哪些参数、就跟调用自己写的代码一样。</p><p>开发 starter 的好处：开发者引入后，可以直接在 application.yml 中写配置，自动创建客户端</p><p><strong>spring-boot-configuration-processor 的作用是自动生成配置的代码提示</strong></p><h3 id="starter-的开发流程"><a href="#starter-的开发流程" class="headerlink" title="starter 的开发流程"></a>starter 的开发流程</h3><p>初始化，环境依赖（一定要移除 build）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">   &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">   &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>编写配置类（启动类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 能读取 application 中的配置属性</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;mofeng.client&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MofengClientConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MofengApiClient <span class="title function_">mofengApiClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MofengApiClient</span>(accessKey, secretKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册配置类</p><p>resources&#x2F;META_INF&#x2F;spring.factories</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># starter</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.mofeng.mofengclientsdk.MofengClientConfig</span><br></pre></td></tr></table></figure><p>mvn install 打包为本地项目</p><p>创建新项目（复用 server 项目）、测试</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二、API-开放平台-模拟接口&quot;&gt;&lt;a href=&quot;#二、API-开放平台-模拟接口&quot; class=&quot;headerlink&quot; title=&quot;二、API 开放平台-模拟接口&quot;&gt;&lt;/a&gt;二、API 开放平台-模拟接口&lt;/h1&gt;&lt;h2 id=&quot;模拟接口项目-mofeng</summary>
      
    
    
    
    <category term="API 开放平台" scheme="http://example.com/categories/API-%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/"/>
    
    
    <category term="星球项目" scheme="http://example.com/tags/%E6%98%9F%E7%90%83%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>创建 starter 步骤</title>
    <link href="http://example.com/2022/12/22/%E5%88%9B%E5%BB%BAstarter%E6%AD%A5%E9%AA%A4/"/>
    <id>http://example.com/2022/12/22/%E5%88%9B%E5%BB%BAstarter%E6%AD%A5%E9%AA%A4/</id>
    <published>2022-12-22T04:04:12.616Z</published>
    <updated>2022-12-22T03:58:17.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建starter步骤"><a href="#创建starter步骤" class="headerlink" title="创建starter步骤"></a>创建starter步骤</h1><p>1.新建一个 spring boot 初始化项目<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230811084.png" alt="image-20221123081123307"></p><p>2.添加依赖，Lombok, Spring Configuration Processor</p><p>Spring Configuration Processor 的作用是自动生成代码提示<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230812657.png" alt="image-20221123081227014"></p><p>3.修改 pom 文件的版本号，并删除 build<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230816110.png" alt="image-20221123081554107"></p><p>​<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230817635.png" alt="image-20221123081718280"></p><p>4.删除原本自动创建的主类，新建一个类, 并添加需要用到的依赖</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230823121.png" alt="image-20221123082308530"></p><p>5.在 resources 目录下新建 META-INF 目录，并创建 spring.factories 文件，并指定配置类的目录</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230828618.png" alt="image-20221123082817937"></p><p>6.install 打包构建在本地的仓库</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230831488.png" alt="image-20221123083107829"></p><p>7.复制 groupId, artifactId, version,可以在其他项目中添加为依赖</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230833985.png" alt="image-20221123083345988"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230834598.png" alt="image-20221123083425190"></p><p>8.在配置文件当中就可以引用 starter 当中设置的属性</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230836055.png" alt="image-20221123083608433"></p><p>刚才在 starter 配置类中定义的属性</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230838324.png" alt="image-20221123083825791"></p><p>可以引入 starter 当中的类或者属性</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com//9963/202211230839280.png" alt="image-20221123083950711"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建starter步骤&quot;&gt;&lt;a href=&quot;#创建starter步骤&quot; class=&quot;headerlink&quot; title=&quot;创建starter步骤&quot;&gt;&lt;/a&gt;创建starter步骤&lt;/h1&gt;&lt;p&gt;1.新建一个 spring boot 初始化项目&lt;br&gt;&lt;img s</summary>
      
    
    
    
    <category term="API 开放平台" scheme="http://example.com/categories/API-%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/"/>
    
    
    <category term="星球项目" scheme="http://example.com/tags/%E6%98%9F%E7%90%83%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>GateWay 转发请求</title>
    <link href="http://example.com/2022/12/22/GateWay-%E8%BD%AC%E5%8F%91%E8%AF%B7%E6%B1%82/"/>
    <id>http://example.com/2022/12/22/GateWay-%E8%BD%AC%E5%8F%91%E8%AF%B7%E6%B1%82/</id>
    <published>2022-12-22T04:04:12.611Z</published>
    <updated>2022-12-22T03:57:33.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五、Gateway-转发请求"><a href="#五、Gateway-转发请求" class="headerlink" title="五、Gateway 转发请求"></a>五、Gateway 转发请求</h1><h2 id="使用到的特性"><a href="#使用到的特性" class="headerlink" title="使用到的特性"></a>使用到的特性</h2><ol><li>路由</li><li><del>负载均衡（需要用到注册中心）</del></li><li>统一鉴权</li><li><del>跨域</del></li><li>统一业务处理（缓存）</li><li>访问控制</li><li><del>发布控制</del></li><li>流量染色</li><li><del>接口保护</del><ol><li>限制请求</li><li>信息脱敏</li><li>降级（熔断）</li><li>限流：学习令牌桶算法、学习漏桶算法，学习一下 RedisLimitHandler</li><li>超时时间</li></ol></li><li>统一日志</li><li><del>统一文档</del></li></ol><h2 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h2><ol><li>用户发送请求到 API 网关</li><li>请求日志</li><li>（黑白名单）</li><li>用户鉴权（判断 accessKey, secretKey 是否合法）</li><li>请求的模拟接口是否存在</li><li><strong>请求转发，调用模拟接口</strong></li><li>响应日志</li><li>调用成功，次数 + 1</li><li>调用失败，返回一个规范的错误码</li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="1-请求转发"><a href="#1-请求转发" class="headerlink" title="1.请求转发"></a>1.请求转发</h3><p>使用前缀匹配断言：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-path-route-predicate-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-path-route-predicate-factory</a></p><p>所有路径为： &#x2F;api&#x2F;** 的请求进行转发，转发到 <a href="http://localhost:8123/api/">http://localhost:8123/api/</a>**</p><p>比如请求网关： <a href="http://localhost:8090/api/name/get/?name=mofeng">http://localhost:8090/api/name/get/?name=mofeng</a></p><p>转发到：<a href="http://localhost:8123/api/name/get/?name=mofeng">http://localhost:8123/api/name/get/?name=mofeng</a></p><p>配置文件添加内容， application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">api_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8123</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/api/**</span></span><br></pre></td></tr></table></figure><h3 id="2-编写业务逻辑"><a href="#2-编写业务逻辑" class="headerlink" title="2.编写业务逻辑"></a>2.编写业务逻辑</h3><p>使用了 GlobalFilter （编程式），全局请求拦截处理（类似 AOP）</p><p>因为网关项目没引入 MyBatis 等操作数据库的类库，如果该操作较为复杂，可以有 backend 增删改查项目提供接口，直接调用，不需要重复写逻辑。</p><ul><li>HTTP 请求（HTTPClient、 用 RestTemplate、 Feign）</li><li>RPC（Dubbo)</li></ul><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>预期等模拟接口调用完成，才记录响应日志、统计调用次数</p><p>但现实是 chain.filter 方法立即返回了，知道 filter 过滤器 return 后才调用模拟接口</p><p>原因是：chain.filter 是一个异步操作，理解为前端的 promise</p><p>解决方案：利用 response 装饰者，增强原有 response 的处理能力</p><p>参考博客：<a href="https://blog.csdn.net/qq_19636353/article/details/126759522">https://blog.csdn.net/qq_19636353/article/details/126759522</a></p><p>其他参考：</p><p><a href="https://blog.csdn.net/zx156955/article/details/121670681">https://blog.csdn.net/zx156955/article/details/121670681</a></p><p><a href="https://blog.csdn.net/weixin_43933728/article/details/121359727?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_43933728/article/details/121359727?spm=1001.2014.3001.5501</a></p><p><a href="https://blog.csdn.net/qq_39529562/article/details/108911983">https://blog.csdn.net/qq_39529562/article/details/108911983</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;五、Gateway-转发请求&quot;&gt;&lt;a href=&quot;#五、Gateway-转发请求&quot; class=&quot;headerlink&quot; title=&quot;五、Gateway 转发请求&quot;&gt;&lt;/a&gt;五、Gateway 转发请求&lt;/h1&gt;&lt;h2 id=&quot;使用到的特性&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="API 开放平台" scheme="http://example.com/categories/API-%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/"/>
    
    
    <category term="星球项目" scheme="http://example.com/tags/%E6%98%9F%E7%90%83%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>组队功能设计</title>
    <link href="http://example.com/2022/12/08/%E7%BB%84%E9%98%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2022/12/08/%E7%BB%84%E9%98%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-12-08T08:06:28.952Z</published>
    <updated>2022-12-08T08:03:03.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组队功能"><a href="#组队功能" class="headerlink" title="组队功能"></a>组队功能</h1><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>需要跟自己一起参加竞赛、做项目、学习，可以发起队伍或者加入别人的队伍</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ol><li><p>用户可以<strong>创建</strong>队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0<br>队长、剩余的人数</p><p>聊天</p><p>公开或私密或加密</p><p>用户最多创建 5 个队伍</p></li><li><p>展示队伍列表，根据名称搜索队伍 P0，信息流中不展示已过期的队伍</p></li><li><p>修改队伍信息  P0~P1</p></li><li><p>用户可以加入队伍（其他人、未满人、未过期），允许加入多个队伍，但是有上限 P0 </p></li><li><p>是否需要队长同意？筛选审批？</p></li><li><p>用户可以退出队伍（如果队长退出，权限转移给第二早加入的用户 – 先来先到）P1</p></li><li><p>队长可以解散队伍 P0</p></li><li><p>分享队伍 &#x3D;&gt; 邀请其他用户加入队伍 P1 </p><p>业务流程：<br>（1）生成分享连接（分享二维码）<br>（2）用户访问链接，可以点击加入</p></li></ol><p></p><h3 id="系统（接口）设计"><a href="#系统（接口）设计" class="headerlink" title="系统（接口）设计"></a>系统（接口）设计</h3><h4 id="1-创建队伍"><a href="#1-创建队伍" class="headerlink" title="1.创建队伍"></a>1.创建队伍</h4><p>用户可以<strong>创建</strong>队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0<br>队长、剩余的人数</p><p>聊天</p><p>公开或私密或加密</p><p>用户最多创建 5 个队伍</p><ol><li>请求参数是否为空</li><li>是否登录，为登录不允许创建</li><li>校验信息<br>a. 队伍人数 &gt; 1 且 &lt;&#x3D; 20<br>b. 队伍标题小于 20<br>c. 描述 &lt;&#x3D; 512<br>d. status 是否公开（int）不传默认为0（公开）<br>e. 如果 status 是加密状态，一定要有密码，且密码 &lt;&#x3D; 32<br>f. 超时时间 &gt; 当前时间<br>g.校验用户最多创建 5 个队伍</li><li>插入队伍信息到队伍表</li><li>插入用户 &#x3D;&gt; 队伍关系到关系表</li></ol><h4 id="2-查询队伍列表"><a href="#2-查询队伍列表" class="headerlink" title="2.查询队伍列表"></a>2.查询队伍列表</h4><p>展示队伍列表，根据名称搜索队伍 P0，信息流中不展示已过期的队伍</p><ol><li>从请求参数中取出队伍名称等查询条件，如果存在则作为查询条件</li><li>不展示已过期的队伍（根据过期时间筛选）</li><li>可以通过某个<strong>关键字</strong>同时对名称和描述查询</li><li><strong>只有管理员才能查看加密还有非公开的队伍</strong></li><li>关联查询已加入队伍的用户信息</li><li><strong>关联查询已加入队伍的用户信息（可能耗费性能，建议用 SQL 实现）</strong></li></ol><p>实现方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询队伍和创建人信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> team t <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> t.userId <span class="operator">=</span> u.id</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询队伍和已加入队伍成员的信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> team t</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> user_team ut <span class="keyword">on</span> t.id <span class="operator">=</span> ut.teamId</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> ut.userId <span class="operator">=</span> u.id</span><br></pre></td></tr></table></figure><h4 id="3-修改队伍信息"><a href="#3-修改队伍信息" class="headerlink" title="3.修改队伍信息"></a>3.修改队伍信息</h4><ol><li>判断请求参数是否为空</li><li>查询队伍是否存在</li><li>只有管理员或者队伍的创建者可以修改</li><li>如果传入的新值和老值一致，则不需要 update （降低数据库使用次数）</li><li><strong>如果队伍状态为加密，修改时必须带密码</strong></li><li>更新队伍信息</li></ol><h4 id="4-用户可以加入队伍"><a href="#4-用户可以加入队伍" class="headerlink" title="4.用户可以加入队伍"></a>4.用户可以加入队伍</h4><p>其他人、队伍未满、未过期、允许加入过个队伍，但是有上线 P0</p><ol><li>用户最多加入 5 个队伍</li><li>队伍必须存在，只能加入未满员、未过期的队伍</li><li>不能加入自己的队伍，不能重复加入已加入的队伍（幂等性）</li><li>禁止加入私有的队伍</li><li>如果加入的队伍是加密的，需要匹配密码</li><li>修改队伍信息，补充人数</li><li>新增队伍-用户关联信息</li></ol><p><strong>注意，加上事务注解 @Trancational</strong></p><h4 id="5-用户退出队伍"><a href="#5-用户退出队伍" class="headerlink" title="5.用户退出队伍"></a>5.用户退出队伍</h4><p>请求参数：队伍 id</p><ol><li>校验请求参数</li><li>校验队伍是否存在</li><li>校验我是否已加入队伍</li><li>如果队伍<ol><li>只剩下一人，解散队伍</li><li>如果是队长退出，权限转移给第二个人（根据 JoinTime)</li><li>非队长，自己退出队伍，队伍人数 -1</li></ol></li></ol><h4 id="6-队长解散队伍"><a href="#6-队长解散队伍" class="headerlink" title="6.队长解散队伍"></a>6.队长解散队伍</h4><p>请求参数：队伍 id</p><ol><li>校验请求参数</li><li>校验队伍是否存在</li><li>校验是否为队长</li><li>移除所有加入队伍的关联信息</li><li>删除队伍</li></ol><p><strong>注意：一定要加上事务注解！</strong></p><h4 id="7-获取当前用户已加入的队伍"><a href="#7-获取当前用户已加入的队伍" class="headerlink" title="7.获取当前用户已加入的队伍"></a>7.获取当前用户已加入的队伍</h4><h4 id="8-获取当前用户创建的队伍"><a href="#8-获取当前用户创建的队伍" class="headerlink" title="8.获取当前用户创建的队伍"></a>8.获取当前用户创建的队伍</h4><p>复用 listTeam 方法，只新增查询条件，不做修改（开闭原则）</p><h3 id="使用事务注解"><a href="#使用事务注解" class="headerlink" title="使用事务注解"></a>使用事务注解</h3><p>@Trancational(rollbackFor &#x3D; Exception.class)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组队功能&quot;&gt;&lt;a href=&quot;#组队功能&quot; class=&quot;headerlink&quot; title=&quot;组队功能&quot;&gt;&lt;/a&gt;组队功能&lt;/h1&gt;&lt;h3 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库表设计</title>
    <link href="http://example.com/2022/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2022/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-12-08T08:06:28.949Z</published>
    <updated>2022-12-08T08:01:55.563Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><h4 id="队伍表-team"><a href="#队伍表-team" class="headerlink" title="队伍表 team"></a>队伍表 team</h4><p>字段：</p><ul><li>id 主键 bigint （最简单、连续，放 URL 上比较简短，但缺点是爬虫）</li><li>name 队伍名称</li><li>decription 描述</li><li>maxNum 最大人数</li><li>expireTime 过期时间</li><li>userId 创建人</li><li>status 0 - 公开， 1- 私密， 2 - 加密</li><li>password 队伍密码</li><li>createTime 创建时间</li><li>updateTime 更新时间</li><li>isDelete 是否删除</li></ul><h4 id="用户-队伍表-user-team"><a href="#用户-队伍表-user-team" class="headerlink" title="用户-队伍表 user_team"></a>用户-队伍表 user_team</h4><p>关系：</p><ol><li>用户加入了哪些队伍？</li><li>队伍有哪些用户？</li></ol><p>两种实现方式：</p><ol><li>建立用户-队伍关系表 teamId userId （便于修改，查询性能高一点，不用全表遍历）</li><li>用户表补充已加入的队伍字段，队伍表补充已加入的用户字段（便于查询，不用写多对多连表查询代码，可以直接根据队伍查用户、根据用户查队伍）</li></ol><p>字段：</p><ul><li>id 主键</li><li>userId 用户 id</li><li>teamId 队伍 id</li><li>joinTime 加入时间</li><li>createTime 创建时间</li><li>updateTime 更新时间</li><li>isDelete 是否删除</li></ul><h3 id="为什么需要请求参数包装类？"><a href="#为什么需要请求参数包装类？" class="headerlink" title="为什么需要请求参数包装类？"></a>为什么需要请求参数包装类？</h3><ol><li>请求参数名称 &#x2F; 类型和实体类不一样</li><li>有一些参数用不到，如果要自动生成接口文档，会增加理解成本（参数太多，冗余）</li><li>对个实体类映射到同一个对象</li></ol><h3 id="为什么需要包装类？"><a href="#为什么需要包装类？" class="headerlink" title="为什么需要包装类？"></a>为什么需要包装类？</h3><ol><li>存在有些字段需要隐藏，不能返回给前端，如用户密码</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据库表设计&quot;&gt;&lt;a href=&quot;#数据库表设计&quot; class=&quot;headerlink&quot; title=&quot;数据库表设计&quot;&gt;&lt;/a&gt;数据库表设计&lt;/h3&gt;&lt;h4 id=&quot;队伍表-team&quot;&gt;&lt;a href=&quot;#队伍表-team&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="数据库" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>定时任务实现-Redisson实现分布式锁</title>
    <link href="http://example.com/2022/12/08/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0-Redisson%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://example.com/2022/12/08/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0-Redisson%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2022-12-08T08:06:28.947Z</published>
    <updated>2022-12-08T08:00:14.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定时任务实现-Redisson实现分布式锁"><a href="#定时任务实现-Redisson实现分布式锁" class="headerlink" title="定时任务实现-Redisson实现分布式锁"></a>定时任务实现-Redisson实现分布式锁</h1><p>主要内容（后端）：</p><ol><li>分布式定时任务执行控制</li><li>锁的概念</li><li>分布式锁概念和常见问题</li><li>分布式锁实践</li></ol><h2 id="定时任务实现"><a href="#定时任务实现" class="headerlink" title="定时任务实现"></a>定时任务实现</h2><ol><li>Spring Scheduler (spring boot 默认整合了，推荐使用这种方式)</li><li>Quartz （独立于 Spring 存在的定时任务框架）</li><li>XXL-Job 之类的分布式任务调度平台（界面 + SDK）</li></ol><p>采用第一种方式：</p><ol><li>主类开启 @EnableScheduling</li><li>给要定时执行的方法添加 @Scheduling , 指定 cron 表达式或者执行频率</li></ol><p><strong>cron 表达式 用现成的工具即可：</strong><br><a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a><br><a href="https://www.matools.com/crontab/">https://www.matools.com/crontab/</a></p><h2 id="控制定时任务的执行"><a href="#控制定时任务的执行" class="headerlink" title="控制定时任务的执行"></a>控制定时任务的执行</h2><p>要控制定时任务在同一时间只有 1 台服务器能执行</p><p>原因：</p><ol><li>浪费资源</li><li>脏数据，比如重复插入</li></ol><p>如何做？</p><p>方案种类：</p><ol><li>分离定时任务程序和主程序，只在 1 个服务器运行定时任务，成本太大</li><li>写死配置，每个服务器都执行定时任务，但是只有 ip 符合配置的服务器才真正执行业务逻辑，其他的直接返回。成本最低；但是我们的 ip 可能不是固定的</li><li>动态配置，配置是可以轻松的、很方便地更新（代码无需重启），但是只有 ip 符合配置的服务器才真正执行业务逻辑。<ul><li>数据库</li><li>Redis</li><li>配置中心（Nacos、 Apollo、 Spring Cloud Config）</li></ul></li></ol><p>问题：服务器多了， ip 不可控还是很麻烦，还需要人工修改</p><ol start="4"><li><p>分布式锁，只有抢到锁的服务器才能执行业务逻辑。<br>缺点：增加成本；<br>优点：不用手动配置，多少服务器都一样</p><p><strong>注意：只要是单机，就会存在单点故障</strong></p></li></ol><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>有限资源的情况下，控制同一时间（段）只有某些线程（用户 &#x2F;  服务器）能访问资源</p><p>Java 实现锁：sychronized 关键字、并发包的类</p><p>存在的问题：只对单个 JVM 有效</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="使用分布式锁的原因："><a href="#使用分布式锁的原因：" class="headerlink" title="使用分布式锁的原因："></a>使用分布式锁的原因：</h3><ol><li>有限资源的情况下，控制同一时间（段）只有某些线程（用户 &#x2F;  服务器）能访问资源</li><li>Java 实现锁：sychronized 关键字、并发包的类</li></ol><h3 id="分布式锁的关键"><a href="#分布式锁的关键" class="headerlink" title="分布式锁的关键"></a>分布式锁的关键</h3><h4 id="抢锁机制"><a href="#抢锁机制" class="headerlink" title="抢锁机制"></a>抢锁机制</h4><p>怎么保证同一时间只有 1 台服务器能抢到锁？</p><p><strong>核心思想：</strong>先来的人先把数据改成自己的标识（服务器 ip），后来的人发现标识已存在，就抢锁失败，继续等待</p><p>等待先来的人执行方法结束，把标识清空，其他人继续抢锁</p><p>MYSQL 数据库：select for update 行级锁（最简单），或者用乐观锁</p><p>Redis 实现：内存数据库，读写速度快。支持 setnx、 lua 脚本，比较方便我们实现分布式锁</p><p>setnx: set if not exists 如果不存在，则设置；只有设置成功才返回 true ，否则返回 false</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>1）用锁要释放</p><p>2）锁一定要加过期时间</p><p>3）如果方法执行时间过长，锁会提前过期</p><p>锁提前过期会导致的问题：</p><ol><li>连锁反应：释放掉别人的锁</li><li>仍然存在多个方法同时执行的情况</li></ol><p>解决方案：续期</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">end</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(!end)&#123;</span><br><span class="line">        <span class="comment">//续期</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">end = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>4)释放锁的时候，有可能先判断出自己的锁，但这时锁过期了，最后也可能释放别人的锁</p><p>解决方案：Redis + lua 脚本保证操作原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原子操作</span></span><br><span class="line"><span class="keyword">if</span>(get lock == A)&#123;</span><br><span class="line">    <span class="comment">// set lock B</span></span><br><span class="line">    del lock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5)Redis 如果是集群（不是只有一个 Redis），如果分布式锁的数据不同步怎么办？</p><p>解决方案：<a href="https://blog.csdn.net/feiying0canglang/article/details/113258494">https://blog.csdn.net/feiying0canglang/article/details/113258494</a></p><h3 id="Redisson-实现分布式锁"><a href="#Redisson-实现分布式锁" class="headerlink" title="Redisson 实现分布式锁"></a>Redisson 实现分布式锁</h3><p>Redisson 是一个 Java 操作 Redis 的客户端，<strong>提供了大量的分布式数据集来简化对 Redis 的操作和使用，可以让开发者像使用本地集合一样使用 Redis（继承了和 Java 相同的集合类）</strong></p><p>关键词：Java Redis 客户端，分布式数据结构，实现了很多 Java 里支持的集合</p><h4 id="两种引用方式"><a href="#两种引用方式" class="headerlink" title="两种引用方式"></a>两种引用方式</h4><ol><li>spring boot starter 引入（不推荐，因为版本迭代太快，容易冲突）：<br><a href="https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter">https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter</a></li><li>直接引入：<a href="https://github.com/redisson/redisson#quick-start">https://github.com/redisson/redisson#quick-start</a></li></ol><h4 id="使用Redisson"><a href="#使用Redisson" class="headerlink" title="使用Redisson"></a>使用Redisson</h4><p>示例代码，创建分布式列表、Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    list 数据存在本地 JVM   内存中</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list:&quot;</span> + list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//    数据存在 Redis 内存中</span></span><br><span class="line">RList&lt;Object&gt; rList = redissonClient.getList(<span class="string">&quot;test-list&quot;</span>);</span><br><span class="line">rList.add(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;RList:&quot;</span> + rList.get(<span class="number">0</span>));</span><br><span class="line"><span class="comment">//rList.remove(0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    map</span></span><br><span class="line">RMap&lt;Object, Object&gt; map = redissonClient.getMap(<span class="string">&quot;test-map&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;yupi&quot;</span>, <span class="number">10</span>);</span><br><span class="line">map.get(<span class="string">&quot;yupi&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="分布式锁保证定时任务不重复执行"><a href="#分布式锁保证定时任务不重复执行" class="headerlink" title="分布式锁保证定时任务不重复执行"></a>分布式锁保证定时任务不重复执行</h4><p>实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testWatchDog</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;yupao:precachejob:docache:lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//只有一个线程获取到锁</span></span><br><span class="line">        <span class="keyword">if</span>(lock.tryLock(<span class="number">0</span>, -<span class="number">1</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line"><span class="comment">// TODO 实际要执行的方法</span></span><br><span class="line">            dosomething();</span><br><span class="line">            System.out.println(<span class="string">&quot;getLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//    只能释放自己的锁</span></span><br><span class="line">        <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;unLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>waitTime 设置为 0，只抢一次，抢不到就放弃</li><li>主要释放锁要写在 finally 语句块中，保证最后一定释放锁</li></ol><h4 id="Redisson-看门狗机制"><a href="#Redisson-看门狗机制" class="headerlink" title="Redisson 看门狗机制"></a>Redisson 看门狗机制</h4><p>Redisson 中提供的续期机制</p><p>开一个监听线程，如果方法还没执行完，就帮你重置 Redis 锁的过期时间</p><p><strong>原理：</strong></p><ol><li>监听当前线程，默认过期时间是 30 秒，每 10 秒续期一次（续期到 30 秒）</li><li>如果线程挂掉（注意 debug 模式也会被它当成服务器宕机），则不会续期</li></ol><p>详情参考文档：<a href="https://blog.csdn.net/qq_26222859/article/details/79645203">https://blog.csdn.net/qq_26222859/article/details/79645203</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定时任务实现-Redisson实现分布式锁&quot;&gt;&lt;a href=&quot;#定时任务实现-Redisson实现分布式锁&quot; class=&quot;headerlink&quot; title=&quot;定时任务实现-Redisson实现分布式锁&quot;&gt;&lt;/a&gt;定时任务实现-Redisson实现分布式锁&lt;/</summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="定时任务" scheme="http://example.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis 缓存实现-定时任务</title>
    <link href="http://example.com/2022/12/08/%E7%AC%AC%E4%B8%83%E9%9B%86-Redis%20%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://example.com/2022/12/08/%E7%AC%AC%E4%B8%83%E9%9B%86-Redis%20%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</id>
    <published>2022-12-08T08:06:28.942Z</published>
    <updated>2022-12-08T08:47:42.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7、Redis-缓存实现-定时任务"><a href="#7、Redis-缓存实现-定时任务" class="headerlink" title="7、Redis 缓存实现-定时任务"></a>7、Redis 缓存实现-定时任务</h1><p>主要内容（后端）：<br>1.缓存和分布式缓存讲解<br>2.Redis介绍(5种数据结构等)<br>3.Java操作Redis的方法(4种方法+对比分析)<br>4.Java Redis Template序列化（包含源码追踪）<br>5.首页缓存开发与注意事项<br>6.缓存预热设计与实现<br>7.定时任务介绍和实现</p><h2 id="数据查询慢怎么办？"><a href="#数据查询慢怎么办？" class="headerlink" title="数据查询慢怎么办？"></a>数据查询慢怎么办？</h2><ul><li><p>用缓存：提前把数据取出来保存好（通过保存到读写更快的介质，比如内存）</p></li><li><p>用定时任务：预加载缓存，定时更新缓存</p></li></ul><p>思考：多个机器要执行同一个任务吗？</p><p>可以用用分布式锁解决：控制同一时间只有一台机器去执行定时任务，其他机器不用重复执行了</p><h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><p>分布式缓存：</p><ul><li>Redis（分布式缓存）</li><li>mencached(分布式)</li><li>Etcd （云原生架构的一个分布式存储，<strong>存储配置</strong>，扩容能力）</li></ul><p>单机缓存：</p><ul><li>ehcache</li><li>Java 内存集合，如 HashMap</li><li>Caffeine （Java 内存缓存性能之王，高性能）</li><li>Google Guava</li></ul><h2 id="Redis-缓存实现"><a href="#Redis-缓存实现" class="headerlink" title="Redis 缓存实现"></a>Redis 缓存实现</h2><p>NoSQL 数据库</p><p>key-value 存储系统（区别于 MYSQL 它存储的是键值对）</p><h3 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h3><p>基本数据结构：</p><ul><li>String 字符串类型：name:”mofeng”</li><li>List 列表：names:[“mofeng”,”dogmofeng”,”lu”]</li><li>Set 集合：names:[“mofeng”,”lu”] (值不能重复)</li><li>Hash 哈希：nameAge:{“mofeng”:1,”dogLu”:2}</li><li>Zset 集合：names[mofeng -9, doglu -12] (适合排行榜)</li></ul><p>高级：</p><ul><li>bloomfilter(布隆过滤器，主要从大量的数据中快速过滤值，比如邮件黑名单拦截)</li><li>geo(计算地理位置)</li><li>hyperloglog(pv&#x2F;uv)</li><li>pub&#x2F;sub(发布订阅，类以消息队列)</li><li>BitMap(1001010101010101010101010101)</li></ul><h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><p>为了防止写入 Redis 的数据乱码、浪费空间等，可以自定义序列化器，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.yupao.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTemplateConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-操作-Redis"><a href="#Java-操作-Redis" class="headerlink" title="Java 操作 Redis"></a>Java 操作 Redis</h3><p><strong>Spring Data Redis （推荐）</strong></p><p>地址：<a href="https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis">https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis</a></p><p>Spring Data：通用的数据访问框架，定义了一组 <strong>增删改查</strong>的接口</p><p>还可以操作：mysql、Redis、jpa</p><p>使用方式如下：</p><p>1）引入 Spring Data Redis 依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.6</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2）配置 Redis 地址</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># redis 配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>独立与 Spring 操作 Redis 的 Java 客户端</p><p>要配合 Jedis Pool 使用</p><h4 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h4><p><strong>高阶</strong>的操作 Redis 的 Java 客户端</p><p>异步、连接池</p><h4 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h4><p>分布式操作 Redis 的 Java 客户端，像使用本地集合一样操作 Redis （分布式 Redis 数据网络）</p><h4 id="几种库对比"><a href="#几种库对比" class="headerlink" title="几种库对比"></a>几种库对比</h4><ol><li>如果项目用的是 Spring，并且没有过多的定制化要求，可以用 Spring Data Redis，最方便</li><li>如果项目用的不是 Spring，并且追求简单，并且没有过高的性能要求，可以 Jedis + Jedis Pool</li><li>如果项目用的不是 Spring，并且追求高性能、高定制化，可以用 Lettuce ，支持异步、连接池</li><li>如果是分布式项目，需要用到一些分布式的特性（比如分布式锁、分布式集合），推荐使用 Redisson</li></ol><h3 id="设计缓存-key"><a href="#设计缓存-key" class="headerlink" title="设计缓存 key"></a>设计缓存 key</h3><p>关键点：不同用户看到的数据不同</p><p>建议格式：</p><p>systemId:moduleld:fuc:options (防止其他系统的冲突)</p><p>比如：yupao:user:recommend:userId</p><p><strong>注意：Redis 内存不能无限增加，一定要设置过期时间！！！</strong></p><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>问题：即使使用了缓存，第一个用户访问还是很慢</p><p>缓存预热的优点：</p><ol><li>解决第一个用户访问很慢，让用户始终快速访问</li><li>在一定程度上保护数据库</li></ol><p>缺点：</p><ol><li>增加开发成本（额外的开发、设计等）</li><li>预热的时机和时间错了，缓存的数据不对或者是未更新的数据</li><li>需要占用额外空间</li></ol><h3 id="怎么缓存预热"><a href="#怎么缓存预热" class="headerlink" title="怎么缓存预热"></a>怎么缓存预热</h3><ol><li>定时任务</li><li>手动触发</li></ol><h3 id="实现缓存预热"><a href="#实现缓存预热" class="headerlink" title="实现缓存预热"></a>实现缓存预热</h3><p>用定时任务，每天刷新所有用户的推荐列表</p><p>注意点：</p><ol><li>缓存预热的意义（新增少、总用户多）</li><li>缓存的空间不能太大，要预留给其他缓存空间</li><li>缓存数据的周期（此处为每天）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7、Redis-缓存实现-定时任务&quot;&gt;&lt;a href=&quot;#7、Redis-缓存实现-定时任务&quot; class=&quot;headerlink&quot; title=&quot;7、Redis 缓存实现-定时任务&quot;&gt;&lt;/a&gt;7、Redis 缓存实现-定时任务&lt;/h1&gt;&lt;p&gt;主要内容（后端）：&lt;</summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="redis" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring 注解使用</title>
    <link href="http://example.com/2022/12/08/Spring%20%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/12/08/Spring%20%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/</id>
    <published>2022-12-08T08:06:28.939Z</published>
    <updated>2022-12-08T07:54:01.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-注解使用"><a href="#Spring-注解使用" class="headerlink" title="Spring 注解使用"></a>Spring 注解使用</h1><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p> 该注解有一个prefix属性，通过指定的前缀，绑定配置文件中的配置，该注解可以放在类上，也可以放在方法上 </p><p> <strong>当将该注解作用于方法上时，如果想要有效的绑定配置，那么该方法需要有@Bean注解且所属Class需要有@Configuration注解。</strong> </p><p>application.yml 配置文件的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用参考代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisAddress</span> <span class="operator">=</span> String.format(<span class="string">&quot;redis://%s:%s&quot;</span>, host, port);</span><br><span class="line">        config.useSingleServer().setAddress(redisAddress).setDatabase(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 2. 创建实例</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">        <span class="keyword">return</span> redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trancational-rollbackFor-x3D-Exception-class"><a href="#Trancational-rollbackFor-x3D-Exception-class" class="headerlink" title="@Trancational(rollbackFor &#x3D; Exception.class)"></a>@Trancational(rollbackFor &#x3D; Exception.class)</h2><p>声明式事务管理，添加位置为<strong>接口实现类、接口实现方法上</strong></p><p>默认配置下， Spring 只有抛出的异常为运行时， unchecked 异常时才会回滚该事务。即抛异常为 RunTimeException 的子类 （Error 也会导致事务回滚），抛出 checked 异常不会导致事务回滚。可通过 rollbackFor 来配置</p><h2 id="CrossOrigin"><a href="#CrossOrigin" class="headerlink" title="@CrossOrigin"></a>@CrossOrigin</h2><p>解决跨域问题，默认情况下允许在该注解中指定的所有源和 HTTP 方法</p><ul><li><strong>origins</strong>： 允许可访问的域列表</li><li><strong>maxAge</strong>:准备响应前的缓存持续的最大时间（以秒为单位）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &#123;&quot;http://127.0.0.1:5173/&quot;&#125;, allowCredentials = &quot;true&quot;)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-注解使用&quot;&gt;&lt;a href=&quot;#Spring-注解使用&quot; class=&quot;headerlink&quot; title=&quot;Spring 注解使用&quot;&gt;&lt;/a&gt;Spring 注解使用&lt;/h1&gt;&lt;h2 id=&quot;ConfigurationProperties&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="spring注解" scheme="http://example.com/tags/spring%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Session 共享实现</title>
    <link href="http://example.com/2022/12/08/Session%20%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/12/08/Session%20%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-12-08T08:06:28.937Z</published>
    <updated>2022-12-08T07:52:18.406Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Session-共享实现"><a href="#Session-共享实现" class="headerlink" title="Session 共享实现"></a>Session 共享实现</h3><h4 id="1-安装-Redis"><a href="#1-安装-Redis" class="headerlink" title="1. 安装 Redis"></a>1. 安装 Redis</h4><p>官网：<a href="https://redis.io/">https://redis.io/</a></p><p>windows 下载：</p><p>Redis 5.0.14 下载：</p><p>链接：<a href="https://pan.baidu.com/s/1XcsAIrdeesQAyQU2lE3cOg">https://pan.baidu.com/s/1XcsAIrdeesQAyQU2lE3cOg</a> </p><p>提取码：vkoi </p><p>redis 管理工具 quick redis：<a href="https://quick123.net/">https://quick123.net/</a></p><ol start="2"><li>引入 redis，能够操作 redis：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>在 application.yml 中配置 Redis</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring</span><br><span class="line"># redis 配置</span><br><span class="line">  redis:</span><br><span class="line">    port: 6379</span><br><span class="line">    host: localhost</span><br><span class="line">    database: 0</span><br></pre></td></tr></table></figure></li><li><p>引入 spring-session 和 redis 的整合，使得自动将 session 存储到 redis 中：</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.session/spring-session-data-redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><pre><code class="xml">  session:    timeout: 86400    store-type: redis</code></pre></li><li><p>修改 spring-session 存储配置 <code>spring.session.store-type</code></p><p>默认是 none，表示存储在单台服务器</p><p>store-type: redis，表示从 redis 读写 session</p></li></ol><p>JWT 的优缺点：<a href="https://zhuanlan.zhihu.com/p/108999941">https://zhuanlan.zhihu.com/p/108999941</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Session-共享实现&quot;&gt;&lt;a href=&quot;#Session-共享实现&quot; class=&quot;headerlink&quot; title=&quot;Session 共享实现&quot;&gt;&lt;/a&gt;Session 共享实现&lt;/h3&gt;&lt;h4 id=&quot;1-安装-Redis&quot;&gt;&lt;a href=&quot;#1-安</summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
    <category term="Session" scheme="http://example.com/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>Redisson 实现分布式锁</title>
    <link href="http://example.com/2022/12/08/Redisson%20%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E5%85%B7%E4%BD%93)/"/>
    <id>http://example.com/2022/12/08/Redisson%20%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E5%85%B7%E4%BD%93)/</id>
    <published>2022-12-08T08:06:28.935Z</published>
    <updated>2022-12-08T07:50:53.736Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redisson-实现分布式锁"><a href="#Redisson-实现分布式锁" class="headerlink" title="Redisson 实现分布式锁"></a>Redisson 实现分布式锁</h3><p>Redisson 是一个 Java 操作 Redis 的客户端，<strong>提供了大量的分布式数据集来简化对 Redis 的操作和使用，可以让开发者像使用本地集合一样使用 Redis（继承了和 Java 相同的集合类）</strong></p><p>关键词：Java Redis 客户端，分布式数据结构，实现了很多 Java 里支持的集合</p><h4 id="两种引用方式"><a href="#两种引用方式" class="headerlink" title="两种引用方式"></a>两种引用方式</h4><ol><li>spring boot starter 引入（不推荐，因为版本迭代太快，容易冲突）：<br><a href="https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter">https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter</a></li><li>直接引入：<a href="https://github.com/redisson/redisson#quick-start">https://github.com/redisson/redisson#quick-start</a></li></ol><p>(1)引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.17</span><span class="number">.5</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>(2)新建 RedissonConfig 配置类,配置地址、端口、创建实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Redisson 配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2022/11/10 23:58</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisAddress</span> <span class="operator">=</span> String.format(<span class="string">&quot;redis://%s:%s&quot;</span>, host, port);</span><br><span class="line">        config.useSingleServer().setAddress(redisAddress).setDatabase(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 2. 创建实例</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">        <span class="keyword">return</span> redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Redisson"><a href="#使用Redisson" class="headerlink" title="使用Redisson"></a>使用Redisson</h4><p>创建分布式列表、Map，新建测试类示例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//    list 数据存在本地 JVM   内存中</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;list:&quot;</span> + list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    数据存在 Redis 内存中</span></span><br><span class="line">    RList&lt;Object&gt; rList = redissonClient.getList(<span class="string">&quot;test-list&quot;</span>);</span><br><span class="line">    rList.add(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;RList:&quot;</span> + rList.get(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//rList.remove(0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    map</span></span><br><span class="line">    RMap&lt;Object, Object&gt; map = redissonClient.getMap(<span class="string">&quot;test-map&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;yupi&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    map.get(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;yupi&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分布式锁保证定时任务不重复执行"><a href="#分布式锁保证定时任务不重复执行" class="headerlink" title="分布式锁保证定时任务不重复执行"></a>分布式锁保证定时任务不重复执行</h4><p>实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testWatchDog</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;yupao:precachejob:docache:lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//只有一个线程获取到锁</span></span><br><span class="line">        <span class="keyword">if</span>(lock.tryLock(<span class="number">0</span>, -<span class="number">1</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line"><span class="comment">// TODO 实际要执行的方法</span></span><br><span class="line">            dosomething();</span><br><span class="line">            System.out.println(<span class="string">&quot;getLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//    只能释放自己的锁</span></span><br><span class="line">        <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;unLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>waitTime 设置为 0，只抢一次，抢不到就放弃</li><li>主要释放锁要写在 finally 语句块中，保证最后一定释放锁</li></ol><h4 id="Redisson-看门狗机制"><a href="#Redisson-看门狗机制" class="headerlink" title="Redisson 看门狗机制"></a>Redisson 看门狗机制</h4><p>Redisson 中提供的续期机制</p><p>开一个监听线程，如果方法还没执行完，就帮你重置 Redis 锁的过期时间</p><p><strong>原理：</strong></p><ol><li>监听当前线程，默认过期时间是 30 秒，每 10 秒续期一次（续期到 30 秒）</li><li>如果线程挂掉（注意 debug 模式也会被它当成服务器宕机），则不会续期</li></ol><p>详情参考文档：<a href="https://blog.csdn.net/qq_26222859/article/details/79645203">https://blog.csdn.net/qq_26222859/article/details/79645203</a></p><p>定时任务全部代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.yupi.yupao.model.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.yupi.yupao.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 预热缓存任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2022/11/10 6:03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreCacheJob</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; mainUserList = Arrays.asList(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每天执行预热推荐用户 cronTable 在线表达式生成 https://cron.qqe2.com/</span></span><br><span class="line">    <span class="comment">// 前面三个参数： 秒 分 时</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 37 1 * * *&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCacheRecommendUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取到 锁对象</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;yupao:precachejob:docache:lock&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//只有一个线程获取到锁</span></span><br><span class="line">            <span class="keyword">if</span>(lock.tryLock(<span class="number">0</span>, -<span class="number">1</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;getLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">                <span class="keyword">for</span> (Long userId : mainUserList) &#123;</span><br><span class="line">                    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">                    Page&lt;User&gt; userPage = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">20</span>), queryWrapper);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> String.format(<span class="string">&quot;yupao:user:recommend:%s&quot;</span>, userId);</span><br><span class="line">                    ValueOperations&lt;String, Object&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">                    <span class="comment">//写缓存</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//指定缓存 30 秒过期</span></span><br><span class="line">                        valueOperations.set(redisKey, userPage, <span class="number">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;redis set key error&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;doCacheRecommendUser error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//    只能释放自己的锁</span></span><br><span class="line">            <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;unLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Redisson-实现分布式锁&quot;&gt;&lt;a href=&quot;#Redisson-实现分布式锁&quot; class=&quot;headerlink&quot; title=&quot;Redisson 实现分布式锁&quot;&gt;&lt;/a&gt;Redisson 实现分布式锁&lt;/h3&gt;&lt;p&gt;Redisson 是一个 Java </summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis 缓存实现</title>
    <link href="http://example.com/2022/12/08/Redis%20%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E5%92%8C%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E4%BB%BB%E5%8A%A1/"/>
    <id>http://example.com/2022/12/08/Redis%20%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E5%92%8C%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E4%BB%BB%E5%8A%A1/</id>
    <published>2022-12-08T08:06:28.933Z</published>
    <updated>2022-12-08T07:46:53.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-缓存实现"><a href="#Redis-缓存实现" class="headerlink" title="Redis 缓存实现"></a>Redis 缓存实现</h2><p>NoSQL 数据库</p><p>key-value 存储系统（区别于 MYSQL 它存储的是键值对）</p><h3 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h3><p>基本数据结构：</p><ul><li>String 字符串类型：name:”mofeng”</li><li>List 列表：names:[“mofeng”,”dogmofeng”,”lu”]</li><li>Set 集合：names:[“mofeng”,”lu”] (值不能重复)</li><li>Hash 哈希：nameAge:{“mofeng”:1,”dogLu”:2}</li><li>Zset 集合：names[mofeng -9, doglu -12] (适合排行榜)</li></ul><p>高级：</p><ul><li>bloomfilter(布隆过滤器，主要从大量的数据中快速过滤值，比如邮件黑名单拦截)</li><li>geo(计算地理位置)</li><li>hyperloglog(pv&#x2F;uv)</li><li>pub&#x2F;sub(发布订阅，类以消息队列)</li><li>BitMap(1001010101010101010101010101)</li></ul><h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><p>为了防止写入 Redis 的数据乱码、浪费空间等，可以自定义序列化器，</p><p>新建 RedisTemplateConfig 类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTemplateConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller 层代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主页 推荐用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageNum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/recommend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;Page&lt;User&gt;&gt; <span class="title function_">recommendUsers</span><span class="params">(<span class="type">long</span> pageSize, <span class="type">long</span> pageNum, HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">loginUser</span> <span class="operator">=</span> userService.getLoginUser(request);</span><br><span class="line">    <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> String.format(<span class="string">&quot;yupao:user:recommend:%s&quot;</span>, loginUser.getId());</span><br><span class="line">    ValueOperations&lt;String, Object&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">    <span class="comment">// 判断是否有缓存，有则直接读缓存</span></span><br><span class="line">    Page&lt;User&gt; userPage = (Page&lt;User&gt;) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">    <span class="keyword">if</span>(userPage != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ResultUtils.success(userPage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无缓存，则查询数据库</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    userPage = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(pageNum, pageSize), queryWrapper);</span><br><span class="line">    <span class="comment">//写缓存</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//指定缓存 30 秒过期</span></span><br><span class="line">        valueOperations.set(redisKey, userPage, <span class="number">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;redis set key error&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ResultUtils.success(userPage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Spring-Data-Redis-操作-Redis"><a href="#使用-Spring-Data-Redis-操作-Redis" class="headerlink" title="使用 Spring Data Redis 操作 Redis"></a>使用 Spring Data Redis 操作 Redis</h3><p><strong>Spring Data Redis （推荐）</strong></p><p>地址：<a href="https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis">https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis</a></p><p>Spring Data：通用的数据访问框架，定义了一组 <strong>增删改查</strong>的接口</p><p>还可以操作：mysql、Redis、jpa</p><p>使用方式如下：</p><p>1）引入 Spring Data Redis 依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.6</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2）配置 Redis 地址</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># redis 配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="设计缓存-key"><a href="#设计缓存-key" class="headerlink" title="设计缓存 key"></a>设计缓存 key</h3><p>关键点：不同用户看到的数据不同</p><p>建议格式：</p><p>systemId:moduleld:fuc:options (防止其他系统的冲突)</p><p>比如：yupao:user:recommend:userId</p><p><strong>注意：Redis 内存不能无限增加，一定要设置过期时间！！！</strong></p><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>问题：即使使用了缓存，第一个用户访问还是很慢</p><p>缓存预热的优点：</p><ol><li>解决第一个用户访问很慢，让用户始终快速访问</li><li>在一定程度上保护数据库</li></ol><p>缺点：</p><ol><li>增加开发成本（额外的开发、设计等）</li><li>预热的时机和时间错了，缓存的数据不对或者是未更新的数据</li><li>需要占用额外空间</li></ol><h3 id="怎么缓存预热"><a href="#怎么缓存预热" class="headerlink" title="怎么缓存预热"></a>怎么缓存预热</h3><ol><li>定时任务</li><li>手动触发</li></ol><h3 id="实现缓存预热"><a href="#实现缓存预热" class="headerlink" title="实现缓存预热"></a>实现缓存预热</h3><p>用定时任务，每天刷新所有用户的推荐列表</p><p>注意点：</p><ol><li>缓存预热的意义（新增少、总用户多）</li><li>缓存的空间不能太大，要预留给其他缓存空间</li><li>缓存数据的周期（此处为每天）</li></ol><p><strong>在 main 主类添加注解 @EnableScheduling</strong></p><p>cronTable 在线表达式生成，地址：<a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面三个参数： 秒 分 时</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 38 6 * * *&quot;)</span></span><br></pre></td></tr></table></figure><p>新建 PreCacheJob 类实现缓存预热任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.yupi.yupao.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.yupi.yupao.model.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.yupi.yupao.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 预热缓存任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2022/11/10 6:03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreCacheJob</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; mainUserList = Arrays.asList(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每天执行预热推荐用户 cronTable 在线表达式生成 https://cron.qqe2.com/</span></span><br><span class="line">    <span class="comment">// 前面三个参数： 秒 分 时</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 38 6 * * *&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCacheRecommendUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Long userId : mainUserList) &#123;</span><br><span class="line">            QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">            Page&lt;User&gt; userPage = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">20</span>), queryWrapper);</span><br><span class="line">            <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> String.format(<span class="string">&quot;yupao:user:recommend:%s&quot;</span>, userId);</span><br><span class="line">            ValueOperations&lt;String, Object&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">            <span class="comment">//写缓存</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//指定缓存 30 秒过期</span></span><br><span class="line">                valueOperations.set(redisKey, userPage, <span class="number">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;redis set key error&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis-缓存实现&quot;&gt;&lt;a href=&quot;#Redis-缓存实现&quot; class=&quot;headerlink&quot; title=&quot;Redis 缓存实现&quot;&gt;&lt;/a&gt;Redis 缓存实现&lt;/h2&gt;&lt;p&gt;NoSQL 数据库&lt;/p&gt;
&lt;p&gt;key-value 存储系统（区别于 MY</summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis plus 实现分页</title>
    <link href="http://example.com/2022/12/08/Mybatis%20plus%20%E5%88%86%E9%A1%B5/"/>
    <id>http://example.com/2022/12/08/Mybatis%20plus%20%E5%88%86%E9%A1%B5/</id>
    <published>2022-12-08T08:06:28.930Z</published>
    <updated>2022-12-08T07:43:32.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-plus-分页"><a href="#Mybatis-plus-分页" class="headerlink" title="Mybatis plus 分页"></a>Mybatis plus 分页</h1><p>创建 MyBatisPlusConfig 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yupi.yupao.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题(该属性会在旧插件移除后一同移除)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/recommend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;Page&lt;User&gt;&gt; <span class="title function_">recommendUsers</span><span class="params">(<span class="type">long</span> pageSize, <span class="type">long</span> pageNum, HttpServletRequest request)</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    Page&lt;User&gt; userList = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(pageNum, pageSize), queryWrapper);</span><br><span class="line">    <span class="keyword">return</span> ResultUtils.success(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">onMounted(async () =&gt;&#123;</span><br><span class="line"><span class="comment">// Optionally the request above could also be done as</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">userListData</span> <span class="operator">=</span> await myAxios.get(<span class="string">&#x27;/user/recommend&#x27;</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      pageSize: <span class="number">8</span>,</span><br><span class="line">      pageNum: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">      .then(function (response) &#123;</span><br><span class="line">        console.log(<span class="string">&#x27;/user/recommend succeed&#x27;</span>, response);</span><br><span class="line">        Toast.success(<span class="string">&#x27;请求成功&#x27;</span>);</span><br><span class="line">        console.log(response.data.data)</span><br><span class="line">        <span class="keyword">return</span> response?.data?.records;</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="keyword">catch</span>(function (error) &#123;</span><br><span class="line">        console.error(<span class="string">&#x27;/user/recommend error&#x27;</span>, error);</span><br><span class="line">        Toast.fail(<span class="string">&#x27;请求失败&#x27;</span>);</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(userListData)&#123;</span><br><span class="line">    userListData.forEach(user =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(user.tags)&#123;</span><br><span class="line">        user.tags = JSON.parse(user.tags)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    userList.value = userListData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mybatis-plus-分页&quot;&gt;&lt;a href=&quot;#Mybatis-plus-分页&quot; class=&quot;headerlink&quot; title=&quot;Mybatis plus 分页&quot;&gt;&lt;/a&gt;Mybatis plus 分页&lt;/h1&gt;&lt;p&gt;创建 MyBatisPlusConf</summary>
      
    
    
    
    <category term="伙伴匹配系统" scheme="http://example.com/categories/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Mybatis" scheme="http://example.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>整合 Swagger + Knife4j 接口文档</title>
    <link href="http://example.com/2022/12/08/Java%20%E5%90%8E%E7%AB%AF%E6%95%B4%E5%90%88%20Swagger%20+%20Knife4j%20%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2022/12/08/Java%20%E5%90%8E%E7%AB%AF%E6%95%B4%E5%90%88%20Swagger%20+%20Knife4j%20%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</id>
    <published>2022-12-08T08:06:28.926Z</published>
    <updated>2022-12-08T08:14:52.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-后端整合-Swagger-Knife4j-接口文档"><a href="#Java-后端整合-Swagger-Knife4j-接口文档" class="headerlink" title="Java 后端整合 Swagger + Knife4j 接口文档"></a>Java 后端整合 Swagger + Knife4j 接口文档</h1><p>官方文档： <a href="https://doc.xiaominfo.com/docs/quick-start">https://doc.xiaominfo.com/docs/quick-start</a> </p><p>1.引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入Knife4j的官方start包,Swagger2基于Springfox2<span class="number">.10</span><span class="number">.5</span>项目--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">    &lt;!--使用Swagger2--&gt;</span><br><span class="line">    &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.0</span><span class="number">.9</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.添加配置类，<strong>注意：basePackage 需要填写 controller 的路径</strong></p><p>千万注意：线上环境不要把接口暴露出去！！！可以通过在 SwaggerConfig 配置文件开头加上 <code>@Profile(&#123;&quot;dev&quot;, &quot;test&quot;&#125;)</code> 限定配置仅在部分环境开启</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2WebMvc</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Knife4jConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;dockerBean&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">dockerBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//指定使用Swagger2规范</span></span><br><span class="line">        Docket docket=<span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(<span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                <span class="comment">//描述字段支持Markdown语法</span></span><br><span class="line">                .description(<span class="string">&quot;# Knife4j RESTful APIs&quot;</span>)</span><br><span class="line">                .termsOfServiceUrl(<span class="string">&quot;https://doc.xiaominfo.com/&quot;</span>)</span><br><span class="line">                .contact(<span class="string">&quot;xiaoymin@foxmail.com&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build())</span><br><span class="line">                <span class="comment">//分组名称</span></span><br><span class="line">                .groupName(<span class="string">&quot;用户服务&quot;</span>)</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//这里指定Controller扫描包路径</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.yupi.yupao.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> docket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 如果开发者使用的是Knife4j 2.x版本，并且Spring Boot版本高于2.4,那么需要在Spring Boot的yml文件中做如下配置： </p><p>3.在 application.yml 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    mvc:</span><br><span class="line">        pathmatch:</span><br><span class="line">            # 配置策略</span><br><span class="line">            matching-strategy: ant-path-matcher</span><br></pre></td></tr></table></figure><p>4.controller类中备注接口相应的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &quot;首页模块&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiImplicitParam(name = &quot;name&quot;,value = &quot;姓名&quot;,required = true)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;向客人问好&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sayHi&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">sayHi</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;)</span>String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;Hi:&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.访问地址，<strong>注意端口、实际的地址</strong></p><p>端口对应，正常访问<a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></p><p>如果配置类当中有配置路径，则需要加上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8888</span></span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /api</span><br></pre></td></tr></table></figure><p>该地址访问：<a href="http://localhost:8888/api/doc.html">http://localhost:8888/api/doc.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-后端整合-Swagger-Knife4j-接口文档&quot;&gt;&lt;a href=&quot;#Java-后端整合-Swagger-Knife4j-接口文档&quot; class=&quot;headerlink&quot; title=&quot;Java 后端整合 Swagger + Knife4j 接口文档</summary>
      
    
    
    
    <category term="开源组件" scheme="http://example.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
    
  </entry>
  
</feed>
